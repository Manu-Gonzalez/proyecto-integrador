/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

'use strict'

/**
 * Module exports.
 * @public
 */

module.exports = contentDisposition
module.exports.parse = parse

/**
 * Module dependencies.
 * @private
 */

var basename = require('path').basename
var Buffer = require('safe-buffer').Buffer

/**
 * RegExp to match non attr-char, *after* encodeURIComponent (i.e. not including "%")
 * @private
 */

var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g // eslint-disable-line no-control-regex

/**
 * RegExp to match percent encoding escape.
 * @private
 */

var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g

/**
 * RegExp to match non-latin1 characters.
 * @private
 */

var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g

/**
 * RegExp to match quoted-pair in RFC 2616
 *
 * quoted-pair = "\" CHAR
 * CHAR        = <any US-ASCII character (octets 0 - 127)>
 * @private
 */

var QESC_REGEXP = /\\([\u0000-\u007f])/g // eslint-disable-line no-control-regex

/**
 * RegExp to match chars that must be quoted-pair in RFC 2616
 * @private
 */

var QUOTE_REGEXP = /([\\"])/g

/**
 * RegExp for various RFC 2616 grammar
 *
 * parameter     = token "=" ( token | quoted-string )
 * token         = 1*<any CHAR except CTLs or separators>
 * separators    = "(" | ")" | "<" | ">" | "@"
 *               | "," | ";" | ":" | "\" | <">
 *               | "/" | "[" | "]" | "?" | "="
 *               | "{" | "}" | SP | HT
 * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
 * qdtext        = <any TEXT except <">>
 * quoted-pair   = "\" CHAR
 * CHAR          = <any US-ASCII character (octets 0 - 127)>
 * TEXT          = <any OCTET except CTLs, but including LWS>
 * LWS           = [CRLF] 1*( SP | HT )
 * CRLF          = CR LF
 * CR            = <US-ASCII CR, carriage return (13)>
 * LF            = <US-ASCII LF, linefeed (10)>
 * SP            = <US-ASCII SP, space (32)>
 * HT            = <US-ASCII HT, horizontal-tab (9)>
 * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
 * OCTET         = <any 8-bit sequence of data>
 * @private
 */

var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g // eslint-disable-line no-control-regex
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/

/**
 * RegExp for various RFC 5987 grammar
 *
 * ext-value     = charset  "'" [ language ] "'" value-chars
 * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
 * mime-charset  = 1*mime-charsetc
 * mime-charsetc = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "%" / "&"
 *               / "+" / "-" / "^" / "_" / "`"
 *               / "{" / "}" / "~"
 * language      = ( 2*3ALPHA [ extlang ] )
 *               / 4ALPHA
 *               / 5*8ALPHA
 * extlang       = *3( "-" 3ALPHA )
 * value-chars   = *( pct-encoded / attr-char )
 * pct-encoded   = "%" HEXDIG HEXDIG
 * attr-char     = ALPHA / DIGIT
 *               / "!" / "#" / "$" / "&" / "+" / "-" / "."
 *               / "^" / "_" / "`" / "|" / "~"
 * @private
 */

var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/

/**
 * RegExp for various RFC 6266 grammar
 *
 * disposition-type = "inline" | "attachment" | disp-ext-type
 * disp-ext-type    = token
 * disposition-parm = filename-parm | disp-ext-parm
 * filename-parm    = "filename" "=" value
 *                  | "filename*" "=" ext-value
 * disp-ext-parm    = token "=" value
 *                  | ext-token "=" ext-value
 * ext-token        = <the characters in token, followed by "*">
 * @private
 */

var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/ // eslint-disable-line no-control-regex

/**
 * Create an attachment Content-Disposition header.
 *
 * @param {string} [filename]
 * @param {object} [options]
 * @p`)));if(a.kind===i.formula.NamePartKind.IdentNamePart){const e=b.getModules().get(a.asWhole);return e&&e.global?void de((0,p.errorFromFNode)(n,a,`Cannot reference "${e.name}" directly.`)):void de((0,p.errorFromFNode)(n,r,"Unknown identifier."))}return void((0,p.isFileSource)(e.source)&&void 0===r.qualifier&&de((0,p.errorFromFNode)(n,a,"Unqualified cell references are not allowed in named formulas.")))}case i.formula.NodeKind.FieldRef:return fe(e,t,n,r.lhs),void fe(e,t,n,r.rhs);case i.formula.NodeKind.FieldRefRHS:return void me(t,n,r.field);case i.formula.NodeKind.StructRef:{const o=r.lhs,s=r.rhs;if(o)if(o.kind===i.formula.NodeKind.Name){const e=ae(n,o);void 0===e?de((0,p.errorFromFNode)(n,o,"Unknown table.")):e.kind!==m.SymbolKind.Table&&de((0,p.errorFromFNode)(n,o,`"${e.name}" is not a table.`)),me(t,n,o)}else fe(e,t,n,o);else void 0===se(n)&&de((0,p.errorFromFNode)(n,r,"The formula is not inside a table cell."));return void fe(e,t,n,s)}case i.formula.NodeKind.StructRefRHS:return void(r.innerRef&&fe(e,t,n,r.innerRef));case i.formula.StructRefKind.CommaOpRef:return void r.refs.forEach((i=>fe(e,t,n,i)));case i.formula.StructRefKind.RangeOpRef:return fe(e,t,n,r.lhs),void fe(e,t,n,r.rhs);case i.formula.StructRefKind.ThisRowOpRef:return void(r.ref&&fe(e,t,n,r.ref));case i.formula.StructRefKind.ColumnRef:return void(ae(n,r)||de((0,p.errorFromFNode)(n,r,`Unknown column "${r.name}".`)));case i.formula.NodeKind.CellRef:return void(r.qualifier&&fe(e,t,n,r.qualifier));case i.formula.QualifierKind.Document:if(!ae(n,r)){const e=(r.path??"")+A.leftBracket+r.document+A.rightBracket;de((0,p.errorFromFNode)(n,r,`Unknown document "${e}".`))}return;case i.formula.QualifierKind.Ident:return void(ae(n,r)||de((0,p.errorFromFNode)(n,r,`Unknown sheet "${r.name}".`)));case i.formula.QualifierKind.Sheet:case i.formula.QualifierKind.SheetRange:return void(ae(n,r)||(r.document&&!ae(n,r.document)?fe(e,t,n,r.document):r.kind===i.formula.QualifierKind.SheetRange?de((0,p.errorFromFNode)(n,r,`Unknown sheet range "${r.sheet1}:${r.sheet2}".`)):de((0,p.errorFromFNode)(n,r,`Unknown sheet "${r.sheet}".`))));case i.formula.NodeKind.WSF:return void(!0===A.unsupportedFunctions[r.id]&&de((0,p.errorFromFNode)(n,r,"This function is not supported in this version of Excel.")));case i.formula.NodeKind.Literal:case i.formula.NodeKind.Operator:case i.formula.NodeKind.Ident:case i.formula.StructRefKind.SpecialRef:case i.formula.StructRefKind.BadRef:case i.formula.StructRefKind.MissingRef:case i.formula.QualifierKind.Error:case i.formula.QualifierKind.Relative:case i.formula.QualifierKind.Bad:return;default:return(0,a.assertNever)(r)}}},t.isDeclarationName=y,t.getDeclaredSymbolOfNode=C;const i=n(76979),r=n(69698),o=n(15367),s=n(93118),a=n(31339),l=n(44268),c=n(90107),u=n(55203),d=n(37478),h=n(30990),g=n(21523),m=n(99875),p=n(59904),f=(e,t)=>({kind:m.TypeKind.Function,minArgs:e,maxArgs:t});function v(e){const t=e.params.find((e=>e.name.arg.isOptional)),n=t?.name.index??e.params.length,i=e.params.length;return f(n,i)}function b(e,t){return t.kind===i.formula.NodeKind.Name&&e.lhs.node===t}function y(e){if(e.kind===m.SyntaxKind.DetachedFormula){const{root:t,node:n}=e;return!(t.parent.kind!==m.SyntaxKind.NamedFormulaDeclarationStatement||t!==t.parent.lhs||!b(t.parent,(0,p.getNameNodeParentOfNode)(t,n)))||void 0!==(0,p.getDeclarationParentOfName)(t,n)}return!1}function S(e,t){return e?.resolvedSymbols?.[t.label]}function C(e){if(e.kind===m.SyntaxKind.DetachedFormula){const{root:t,node:n}=e;if(t.parent.kind===m.SyntaxKind.NamedFormulaDeclarationStatement&&t===t.parent.lhs&&b(t.parent,(0,p.getNameNodeParentOfNode)(t,n)))return t.parent.symbol?.kind===m.SymbolKind.Definition?t.parent.symbol:void 0;const r=(0,p.getDeclarationParentOfName)(t,n);switch(r?.kind){case i.formula.NodeKind.Param:case i.formula.NodeKind.Var:return function(e,t){return e?.symbols?.[t.label]}(t,r)}}}function _(e,t,n){return!!function(e){switch(e.kind){case i.analyze.diagnostics.TypeError.Incorrect_number_of_operator_arguments:case i.analyze.diagnostics.TypeError.Excess_function_arguments:case i.analyze.diagnostics.TypeError.Insufficient_function_arguments:case i.analyze.diagnostics.SyntaxError.Unclosed_application:case i.analyze.diagnostics.SyntaxError.Unclosed_paren:case i.analyze.diagnostics.SyntaxError.Unclosed_bracket:case i.analyze.diagnostics.SyntaxError.Unclosed_array:case i.analyze.diagnostics.SyntaxError.Duplicate_binder:case i.analyze.diagnostics.SyntaxError.Invalid_name:case i.analyze.diagnostics.SyntaxError.Bad_node:return!0;default:return!1}}(n)&&((e[t]??(e[t]=[])).push(n),!0)}function w(e,t,n){let r=(0,p.getImmediateParent)(e,t);for(;r&&!(0,p.isCallLike)(r)&&r.kind!==i.formula.NodeKind.Array;)r=(0,p.getImmediateParent)(e,r);return void 0===r?"Separator expected.":r.kind===i.formula.NodeKind.Array?"Row or column separator expected.":`'${n}' expected.`}function k(e,t,n){return e===t?`Expected ${e} argument${1===e?"":"s"}, but got ${n}.`:n<e?`Expected at least ${e} argument${1===e?"":"s"}, but got ${n}.`:((0,a.assert)(void 0!==t),`Expected at most ${t} argument${1===t?"":"s"}, but got ${n}.`)}function E(e){switch(e.kind){case i.analyze.diagnostics.SyntaxError.Unclosed_application:return"Unclosed function call - add ')'.";case i.analyze.diagnostics.SyntaxError.Unclosed_paren:return"Unclosed parenthesis - add ')'.";case i.analyze.diagnostics.SyntaxError.Unclosed_bracket:return"Closing ']' expected.";case i.analyze.diagnostics.SyntaxError.Unclosed_array:return"Unclosed array literal - add '}'.";case i.analyze.diagnostics.SyntaxError.Unclosed_literal:return"Unclosed string literal.";case i.analyze.diagnostics.SyntaxError.Unclosed_comment:return"Unclosed comment - add '*/'.";case i.analyze.diagnostics.SyntaxError.Illegal_array_literal_element:return"This element is not allowed inside an array.";case i.analyze.diagnostics.SyntaxError.Empty_array_literal:return"An array cannot be empty.";case i.analyze.diagnostics.SyntaxError.Irregular_array_shape:return"Each of the rows of the array must have the same number of columns.";case i.analyze.diagnostics.SyntaxError.Bad_node:return"This syntax is not recognised.";case i.analyze.diagnostics.SyntaxError.Invalid_binder:return"This argument must be an identifier to bind.";case i.analyze.diagnostics.SyntaxError.Duplicate_binder:return"This argument repeats a previous identifier to bind.";case i.analyze.diagnostics.SyntaxError.Empty_formula:return"The formula is empty.";case i.analyze.diagnostics.SyntaxError.Invalid_re