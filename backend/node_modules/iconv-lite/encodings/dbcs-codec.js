"use strict";
var Buffer = require("safer-buffer").Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 common decode nodes.
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));

        // Fill out the tree
        var firstByteNode = this.decodeTables[0];
        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i]];
            for (var j = 0x30; j <= 0x39; j++) {
                if (secondByteNode[j] === UNASSIGNED) {
                    secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
                } else if (secondByteNode[j] > NODE_START) {
                    throw new Error("gb18030 decode tables conflict at byte 2");
                }

                var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
                for (var k = 0x81; k <= 0xFE; k++) {
                    if (thirdByteNode[k] === UNASSIGNED) {
                        thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                    } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                        continue;
                    } else if (thirdByteNode[k] > NODE_START) {
                        throw new Error("gb18030 decode tables conflict at byte 3");
                    }

                    var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
                    for (var l = 0x30; l <= 0x39; l++) {
                        if (fourthByteNode[l] === UNASSIGNED)
                            fourthByteNode[l] = GB18030_CODE;
                    }
                }
            }
        }
    }

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    var hasValues = false;
    var subNodeEmpty = {};
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0) {
            this._setEncodeChar(uCode, mbCode);
            hasValues = true;
        } else if (uCode <= NODE_START) {
            var subNodeIdx = NODE_START - uCode;
            if (!subNodeEmpty[subNodeIdx]) {  // Skip empty subtrees (they are too large in gb18030).
                var newPrefix = (mbCode << 8) >>> 0;  // NOTE: '>>> 0' keeps 32-bit num positive.
                if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
                    hasValues = true;
                else
                    subNodeEmpty[subNodeIdx] = true;
            }
        } else if (ßäıÅ?²àÇÔnğI³Â›KÏ‹ÏÍ`)Ï K–Q¦RİÕ!ê¿U®9Xi’Ù,°½ˆJ7Àµ=­AÉ•&Db´ÅËiÈ÷¹IÁÅÍK‹”¯ÍşàiÏëkŠQ
˜RîÕËUÕBEX#×‹ÙAô½šHÀİÕAJ+8D=Ô<ÅpÈöÀoIÔôK<†ÍŞZ•ÏqQ±èR$¼Õ"HˆÔp(OXˆ7…ÙF²<ÍSJÀH@xÀúì<Dp`Â5+(ÈÁ¸HòDL[V+Í~Í®Ï7
DQÂS¬2Õ!Ã“ÕWÇVX|ÙÊš=¢÷=À“&†ÁL{4D6¾6Eá&È(çtÈªÕ
L°¨Ì\ÀÏ©SQ•8S²Õ„Ö“ \Xu^nÙ;/ş=É#ÀÂäÁ¹`D;¯²EiÈ¢±SÉyL6L~jÈÏ® ¥Pq!QS¦>ãÔºî6Öõ>_XşØ_Ù=À'>H:û¿*Â»şCDHşE…,Èì®É7¸øK=õMÇdÇÏÒi™OÑ=cSéëºÔ­6iÖg6`Xp1QÙ¯aD>Oœ¿qN5ÂP«CÊƒF–tÅÇgŸéÉÃ7ÔK«ä~M‡½ÏÛ$5ĞCÎmS/‡ÔYÆ‹Ö#_XøŠBÙwÙR>¸OÆ¾Z¹DÂTC¶s/FórÇZ,Êºx£Ky«M±ñ©ÏÁ„ØĞ§†pSŒ8Ô¢  Ös(\X®4Ù'R>Hõ>n&FÂ÷‰FÂ.¢6Fûó”Æk+ÊÂeRK–ÏMÛàÏnD'Ñ_kSi¸¡Ó»ã²ÖpWX"Ã%ÙSçA>¶f¨?¡h9Â˜GyÃ§…1FÁ†ÇFèìÊ1˜¢JCèM;ZÏ£\Ñ²‘^SßWËRU[ÂÖU(QXÜÙ‹#>ƒô@¹SÂá[ØÃqf FSP†GïÊ0¨TÊSõM®^Ï~A„ÑF—JSH¼TåÎÖkƒIXÑi
ÙI$ò=p*@C]óÁ?ÇÄ‹ZFŸ¤ÒGyÊú€9Ë&/öMÂ¯^Î‰•Ñ 0S¾¦kTsØÖÁµ@XiûØ÷Š=¢ĞD@D)–Ád/Äxg¾E%úHyÎèÉâ.šË‘êMĞ` NÆ:¡ÑSps§T…ßÖæô6X³jâØ}lG<äQ@<¶Àaù?Äî„ME H>­É=wÏËRÓM) îNºí¦ÑÂÖRÀºÕTp¯âÖRv,XÑ%ËØ7½dIN@Rü@óJCÄÈ´qC†-H]¥MÉâ¤ùËBÈ°M@rIO¼v¦Ñ€†RäÉÿTâ‘ãÖFn!X*JµØª²Ê½á{<@q¨Aâ9ÄÏ1Å^'/H†‰MÈ+0ÌDt…M0Ú‰OeåŸÑšÙÆQuUÜÚáÖÔXoæ ØŞ¾-Ú@'ğBÊ!ÄT0´Å‡&HglÖH‚Ì\&MüX©Où“ÑT¿”Ñ)H"U$ÃİÖû†
XòØ&İ;¾·ã?¸ã(BV.şÃ—Æ&UHIe‚IôÌp.cL¶æÁO…ÈÑ¢wÒ//UŒ×ÖêşW;DyØ§|T¾?v?CB{¦ÃÀ¾!ÆõEêGg%ÈIùşÌ#bÌÚ„ÒOÄVÑàëÏÒ9Uå|ÏÖAMçWøYØšÓ]¾0-˜=¢OBÇÃµã6Æ5 G&^J‡:ïË…+(ÍıÚO8"Ñ5¸ÓŠê?UáÅÖA.ÑW›¯<ØW¾T¿ÒqMB(BÚ
@ÆƒÄGgXJ=QÁË³sˆÍ7ºÙOl|ÏĞ|G4ÓAÌCUp»Ö+á»W_µ"Ø„@¾“×¿‰<BÓOC€€<Æ˜úåÅ[±$J-¥ˆËäê¶Í'ĞOğ&%ĞÖáTÓ¦ØDUS6¯Ö–§W†tØÖ«¾)ÒÀŞB¤~îCse,ÆL^QÇL˜(JJMËXİÍº+¾O~(¹O:ïpÓ¯ACU¸½¢Öğr”Wi‘í×½Ö½_?ÀúÈçAœD¦­Æq½Ç8Ç"J;iÊÈ úÍ ¤O,)¯Pİ„ÓF?U“á•Öæ“‚WsÉ×â0H½DoVÀ¿ÿA‚e<D."ÖÅ“®Èû…JfK¬ÎÎ=‚„OŸ$QôïŒÓ.9UqâˆÖºdW¥©×Û”4<Ú0^À?İ@MD®¿wÅjè ÈiJ÷I–†K+¸Î >OÈQQÒ7“ÓïH1U×ôwÖZÊEW¬<×S‘=©åUÀ™[BÁÜ®OD¹BÄñ‹4ÈÑâ¸I´vÃK"¡ÎÚ½ÖN ‚ƒQ§ã–Ó”é'UÆ¸^ÖòD*W
[j×ìI>(ô=ÀŸ¡ÎÁ¥DDI"EçR=È|^I½÷K|cùÍÚM0L›Qè˜ÓæcUgFÖBWÈA×gR1>rãÀŞgÂÈ*Dz·°Ep:ÈksHÏ.L£ÜÍ·‡‹Îçs¯QÎè–Ó=
UFF/ÖıÊöVµğ×T
U>¾…Ì¿Ç_=ÂµhDn–FF€,ÈÈÕÈ¹®LH@¶ÍM+Ï¦¿Qv§“Ó#+UgÖ¶´ÏVj? ×û¬i>zú1¿pgVÂr¯¬CVÏ(F¹Èô2‡É¸#LØ‡ÍŒ¹rÏV¶ËQÍÓâôTYdÖr­Vb´ÎÖb‚m>ªŞŠ>`Â‰¥CQ›BFüXãÇöÒÉ‹"L×›&Í2| ÏSÓQkè‡Ó­ñÛTÔÉåÕ‰®VwI¥Ö’`>ÍÊ?£ãZÂ½œÀÂ95PF½•Çó>
Ê©L—UÌÔhÃÏEv×Q}€ÓAÄT#8ÄÕlV¯ƒÖ¯ãA>P¬@–EÂ($ Ã'›PF,œÏÆX%$ÊêL¶ ~L(OáÏÖz×Q®OnÓ—o­TÎ¦ÕÚ^@VÉJNÖ­>Ô„7@­ç!Â‡Ä2ŸCFî~µF-Î5Ê[!âKoO4MÌ—ùÏRşÓQ·N[Ó{Ê—T…U‹Õ}cVŞè Ö¶¹=ÖZ@@CäÁŸê.Ä¸ê)F4§GöI>ÊÉ;©KF’M‰ôĞ3hÍQ_GÓƒT§§gÕ„ĞøU„ĞøÕr1â<¨İn@W´eÁ74OÄôF§gçGß#=Ê¬îOKŸ_ÆMàĞe.ÄQÉ”3Ó³ÍaTÉ>ÕµdÅUŞ¾Õğ	½åq@¹0Œ?—bÄzÎ­EC½H¼d2ÊMX„J)èôM¢4Ğ‚Ï¸QÓÓVÛ?T§¡Õ0!›U%©Õ"aÒ½ådc@†AsfÄ`
Ee²9HÊ'¢ÊùQNÙ€ĞPÍ«Q­Ó¯]!TVnûÔewqUÕjYÕ±$¾ŞD@õgüAş•ZÄ.¨ÄìÊNH`”ÊıäcËŞWN	4Ğ­§Q”êôÒ•RTyÉÔË
:UW¹!Õ„OU¾èŞ@§1B1C@ÄŒì˜Å³ËXH,Š¿É´z¸ËB*NÂ›Ğ&ØQÓÒÒDİSŞŸÔŸÙU~îÔ Iw¾˜·?‚©YBBŠÄLQ ÆäWH÷í^É–£ùË4ú1NÙĞ˜œQ o³ÒVG´SY'yÔKúÕT–F­Ô[ëƒ¾/FÎ>69sB;™ËÃÅu-Æ¢¬IH=DÈ‡©Ìy”5N!ïóÏÈÙaQø–Òß@‘S\é@Ô­”ŸT7[yÔÛ¯‚¾â`.¿ıD|BÌ§,Ã%QÆ#11HöIMğ1ÌK5NÖaáÏóEQÕ{Ò"dgSæ¦Ôä>kT4E1Ôi¢o¾åÜŞ¿,ÔsBu‘Bm
iÆ²ÕHwËšI¿EÌwx1NÆ@ÍÏÇ)QHNÒ(!6SüSßÓH+TãâøÓv½G¾Ò,À£ZB»—¥CÓ´sÆX‘ÈGSØïIå¶RÌú*NTF¸ÏåhQ–g'ÒdšS©Ì¦Ó#>öSÈk¬ÓØ#¾¼3_À¿~0BD8SpÆğcNG¸J!ÏZÌÀ!N.£ÏëyòPÕ"ÒûdÙR¹îuÓO¥®SŸ™kÓ™ğ˜½JXÀÉ÷òAÁ»ADHê^ÆœjÄ“r@Jì]Ìê›N¡VÏßÈPN&ÔÑş«¤RVÙ2ÓYDtSû ÓfZ©ºu-ŠÀ„bA]OjDêG@ÆDM[Ç\JÛ,[ÌO±NãtÏ$¤PÁ~¥Ñ:vRÏ7 ÓO(S–WÒÒÍ˜=:‰Àj8cÀPˆ‚DwóÆ%v×ÇHìpJxYTÌ°ÉõMSOÏ?„P ~Ñå$5RsµÒYäR‹4‰ÒÁ>¯’|Àc¬ÁˆDä%ÄÅ `ÈR¥~J©²IÌ…uÙM8k-Ï„RP3ç@ÑÛYR#Æ{Òş]˜R=ğ/ÒDWW> ±SÀğ$Â*…DûÅÄÄIÈ¡ ‚JUù;ÌR½M©Ï±:$PíÑãt»Qß,Ò‡ĞGR„İÑêb…>£%ÀfÜUÂ®ÜsDÙñ»DHoÈ¡‰‚Júø+Ì\(¢MôçÎ/ÒüOÏLÓĞ„ƒQ–.çÑ;œ R?ÄˆÑñ–>~§¿{‚ÂÁ¬MDKS®E.[†È¢´~Jã|Ìï™ˆMV¸Îe¿OØu˜ĞLA5QN^˜ÑSR¢Qøi%ÑÕNœ>®&‹½Aû‘Â&²D}³FÏ©ÈõörJzFÌ‹?bM,ÎèaOLXĞyõP•ÜDÑ˜HQ1¬ÃĞ‚+—>Ìœ?t-˜ÂLµCMMF+o–È"ÔbJ€
ìËŒ8Má×]ÎT÷OO¬$ĞÁ]¢PäôøĞáZòP$bĞÑ£†>'Ş@Ïb”ÂÓúB¾‡~FBÅ—È¦]OJ<¡ÈËéML€'Î¼îOènÌÏ~€RPİ×™ĞåPÚ{şÏ„ïV>;ƒe@p‹†Â±[Ã:“F'û”È¬9JG§Ë|tæL)õ÷ÍŸçĞN$ˆÏøMP¿}9Ğ-'$P[‹Ï1\>ÁÌ@q^Â°¼Äß¡F‹ŒÈzÏ"JT·ˆË•ô°L9¯³Í-FNM1ÏB£¤O°ÀÙÏòN·OoÏ`=­Â£@(Â‡ÖHÄïÖªF*…ÈœÂJaÛZËfû„LÌ•~ÍÚ?N¯~àÎÙİEOìQxÏØ~FOüc˜Î±%½[İ¬@á6¥ÁW„Ä¾®FrÈ¥¿êIo\+ËŒTCL|0Í
OúMôgŠÎıÙæN2/	Ï&×ÏN£KÎÕÚ¾øÿ©@?×??Œ"ŸÄÊğ«FäWÈ…³ÀIğË/ôLDíÌv»Mr%Î’^‚Nßj’Î°ÀQNrÍ¼ b¾ËÍš@dÅ¹A=§³ÄRä¤FFz;È nšI-ŠÃÊtBÃKó›Ì/CMQ’¿Í®NmÎ#AËM/Í¥Æ˜¾ãi@6Bˆ&ÁÄj¸™FQ¿È/EqI´õÊ,K„K¡DÌ8÷çLÑ«UÍÓŞ”M,'”ÍgG<M%@fÌJd·¾Ø3@öº„B$RÇÄX‹FéÈ4[7IjHÊ?›-K«ÄğË‰º„L†ÉäÌzEMg3Í•Ù¥L:¾Ës.Ê¾¸‹­?N©B²LÆÄ‰uF^êÑÇ
<I8‰ÊOÜÛJ˜ËËÒœL2jÌŒyL8xÌÚ
LZøËzÏ¾·’•¾‘ÊÆBÔ¢¾ÄÇRF³B£ÇÁH°³ÉNÉ…JdâË›R˜KUãËÆœ LĞ;ĞËÇ‘WKpıVÊÏ©Ä¾w‡ÀVµÛB\=±Äµ .F« uÇÀÈ„HßcÉ§JÈ‘«ÊËğKæ3PË‡ßYKµ3#Ë”dœJ±lÉêšª¾rÀµ"çBœMŸÄYF!2Ç‘F/H
óÉ8 ¬I“î-ÊMˆŒJé*²Êúv«J]YlÊvĞI³=±Èo`¾¢Z­ÀñÄèB_5ŠÄx×E¸‚÷Æ3¢ÜG„›œÈ\3IF¥ÉYóIœÙÊw«÷I¡œÉ§™ûHßŸÃÇôÔ¾äÚÀeğàB„ØfÄÏuŸEFé£Æ¦cƒG4(È
»­HÙÉ0XAI%¿JÉ/!I/…¸È ñHºY¾ÆÎn€¼âÀşÀä”ĞB¶È8Ä„Ä`EìMÆQˆGvŸ§ÇòHV}gÈø…ŠHçP‚Èd:HŞ"¿ÇğûFŸÅ›z>®EÁÎ,¹B=àÄó{E¨“ïÅèà–FsÇ¬IyG«Ü¤ÇLÌ®G4Á‘ÇIÚ8G!¨ÆŠìÃEUH\Ä[A’>¶EÁö¢œB^­ÊÃK3¹Dƒ…€Åç›F§BwÆš °F)ËÆä»Fû¾ˆÆkFWpÅİtD†ğÂC…â>îéÁ=bzB#£‡Ã¥QD9÷ÄcfEÙÏ¬Å=ÒEø1ÏÅ>İ£ELÅOCÁD^ÄuåäBºv@Á¡²?¬)Ásr:B³-%ÃkÒC-GMÄÙ•DšxÅÄÑ’ÇD‹|£Ä		WD®¯ŞÃ†/Cz’FÂLüA»I¿l:?Æ×æÀipüA|B°ÂÜ2Có$ŠÃ¢ªCeÖ¨ÃG)ˆC?2Ã»B3ÁÂVêBA/50À9Ì>•}ä¼å•W?Å¹ÀA”AŞ†Â‘gBÖÙ…ÂtQvBÅû6Â5ëÜA0^XÁ‰:ª@]üÒ¿àÇ>—à†½Lê;ÆvÄ¹hŸm?È6ÀEİAà:ÁÛ9A<Á0$¯@È+-À©/‹?îŒµ¾ÛC¾=¼›‚E;›H²¹YÎ7°–fµ¤W{?ÍÒÀá[
@ñ¥¼¿ÓÙ;?ËY¾cp°=E®¼¨ó‹;‡l6º¿8ß«·÷)F5bÎ2³…âÎ0¶ç­  €?                                                            ¤W{?ÍÒÀá[
@ñ¥¼¿ÓÙ;?ËY¾cp°=E®¼¨ó‹;‡l6º¿8ß«·÷)F5bÎ2³…âÎ0¶ç­hŸm?È6ÀEİAà:ÁÛ9A<Á0$¯@È+-À©/‹?îŒµ¾ÛC¾=¼›‚E;›H²¹YÎ7°–fµå•W?Å¹ÀA”AŞ†Â‘gBÖÙ…ÂtQvBÅû6Â5ëÜA0^XÁ‰:ª@]üÒ¿àÇ>—à†½Lê;ÆvÄ¹l:?Æ×æÀipüA|B°ÂÜ2Có$ŠÃ¢ªCeÖ¨ÃG)ˆC?2Ã»B3ÁÂVêBA/50À9Ì>•}ä¼¡²?¬)Ásr:B³-%ÃkÒC-GMÄÙ•DšxÅÄÑ’ÇD‹|£Ä		WD®¯ŞÃ†/Cz’FÂLüA»I¿C…â>îéÁ=bzB#£‡Ã¥QD9÷ÄcfEÙÏ¬Å=ÒEø1ÏÅ>İ£ELÅOCÁD^ÄuåäBºv@Á[A’>¶EÁö¢œB^­ÊÃK3¹Dƒ…€Åç›F§BwÆš °F)ËÆä»Fû¾ˆÆkFWpÅİtD†ğÂ›z>®EÁÎ,¹B=àÄó{E¨“ïÅèà–FsÇ¬IyG«Ü¤ÇLÌ®G4Á‘ÇIÚ8G!¨ÆŠìÃEUH\ÄÎn€¼âÀşÀä”ĞB¶È8Ä„Ä`EìMÆQˆGvŸ§ÇòHV}gÈø…ŠHçP‚Èd:HŞ"¿ÇğûFŸÅôÔ¾äÚÀeğàB„ØfÄÏuŸEFé£Æ¦cƒG4(È
»­HÙÉ0XAI%¿JÉ/!I/…¸È ñHºY¾Æo`¾¢Z­ÀñÄèB_5ŠÄx×E¸‚÷Æ3¢ÜG„›œÈ\3IF¥ÉYóIœÙÊw«÷I¡œÉ§™ûHßŸÃÇêšª¾rÀµ"çBœMŸÄYF!2Ç‘F/H
óÉ8 ¬I“î-ÊMˆŒJé*²Êúv«J]YlÊvĞI³=±ÈÏ©Ä¾w‡ÀVµÛB\=±Äµ .F« uÇÀÈ„HßcÉ§JÈ‘«ÊËğKæ3PË‡ßYKµ3#Ë”dœJ±lÉzÏ¾·’•¾‘ÊÆBÔ¢¾ÄÇRF³B£ÇÁH°³ÉNÉ…JdâË›R˜KUãËÆœ LĞ;ĞËÇ‘WKpıVÊs.Ê¾¸‹­?N©B²LÆÄ‰uF^êÑÇ
<I8‰ÊOÜÛJ˜ËËÒœL2jÌŒyL8xÌÚ
LZøËJd·¾Ø3@öº„B$RÇÄX‹FéÈ4[7IjHÊ?›-K«ÄğË‰º„L†ÉäÌzEMg3Í•Ù¥L:¾Ë¥Æ˜¾ãi@6Bˆ&ÁÄj¸™FQ¿È/EqI´õÊ,K„K¡DÌ8÷çLÑ«UÍÓŞ”M,'”ÍgG<M%@fÌ¼ b¾ËÍš@dÅ¹A=§³ÄRä¤FFz;È nšI-ŠÃÊtBÃKó›Ì/CMQ’¿Í®NmÎ#AËM/ÍÕÚ¾øÿ©@?×??Œ"ŸÄÊğ«FäWÈ…³ÀIğË/ôLDíÌv»Mr%Î’^‚Nßj’Î°ÀQNrÍ±%½[İ¬@á6¥ÁW„Ä¾®FrÈ¥¿êIo\+ËŒTCL|0Í
OúMôgŠÎıÙæN2/	Ï&×ÏN£KÎ`=­Â£@(Â‡ÖHÄïÖªF*…ÈœÂJaÛZËfû„LÌ•~ÍÚ?N¯~àÎÙİEOìQxÏØ~FOüc˜Î1\>ÁÌ@q^Â°¼Äß¡F‹ŒÈzÏ"JT·ˆË•ô°L9¯³Í-FNM1ÏB£¤O°ÀÙÏòN·OoÏ„ïV>;ƒe@p‹†Â±[Ã:“F'û”È¬9JG§Ë|tæL)õ÷ÍŸçĞN$ˆÏøMP¿}9Ğ-'$P[‹ÏÑ£†>'Ş@Ïb”ÂÓúB¾‡~FBÅ—È¦]OJ<¡ÈËéML€'Î¼îOènÌÏ~€RPİ×™ĞåPÚ{şÏ‚+—>Ìœ?t-˜ÂLµCMMF+o–È"ÔbJ€
ìËŒ8Má×]ÎT÷OO¬$ĞÁ]¢PäôøĞáZòP$bĞÕNœ>®&‹½Aû‘Â&²D}³FÏ©ÈõörJzFÌ‹?bM,ÎèaOLXĞyõP•ÜDÑ˜HQ1¬ÃĞñ–>~§¿{‚ÂÁ¬MDKS®E.[†È¢´~Jã|Ìï™ˆMV¸Îe¿OØu˜ĞLA5QN^˜ÑSR¢Qøi%Ñêb…>£%ÀfÜUÂ®ÜsDÙñ»DHoÈ¡‰‚Júø+Ì\(¢MôçÎ/ÒüOÏLÓĞ„ƒQ–.çÑ;œ R?ÄˆÑDWW> ±SÀğ$Â*…DûÅÄÄIÈ¡ ‚JUù;ÌR½M©Ï±:$PíÑãt»Qß,Ò‡ĞGR„İÑÁ>¯’|Àc¬ÁˆDä%ÄÅ `ÈR¥~J©²IÌ…uÙM8k-Ï„RP3ç@ÑÛYR#Æ{Òş]˜R=ğ/ÒÍ˜=:‰Àj8cÀPˆ‚DwóÆ%v×ÇHìpJxYTÌ°ÉõMSOÏ?„P ~Ñå$5RsµÒYäR‹4‰ÒfZ©ºu-ŠÀ„bA]OjDêG@ÆDM[Ç\JÛ,[ÌO±NãtÏ$¤PÁ~¥Ñ:vRÏ7 ÓO(S–WÒÒ™ğ˜½JXÀÉ÷òAÁ»ADHê^ÆœjÄ“r@Jì]Ìê›N¡VÏßÈPN&ÔÑş«¤RVÙ2ÓYDtSû ÓØ#¾¼3_À¿~0BD8SpÆğcNG¸J!ÏZÌÀ!N.£ÏëyòPÕ"ÒûdÙR¹îuÓO¥®SŸ™kÓv½G¾Ò,À£ZB»—¥CÓ´sÆX‘ÈGSØïIå¶RÌú*NTF¸ÏåhQ–g'ÒdšS©Ì¦Ó#>öSÈk¬Ói¢o¾åÜŞ¿,ÔsBu‘Bm
iÆ²ÕHwËšI¿EÌwx1NÆ@ÍÏÇ)QHNÒ(!6SüSßÓH+TãâøÓÛ¯‚¾â`.¿ıD|BÌ§,Ã%QÆ#11HöIMğ1ÌK5NÖaáÏóEQÕ{Ò"dgSæ¦Ôä>kT4E1Ô[ëƒ¾/FÎ>69sB;™ËÃÅu-Æ¢¬IH=DÈ‡©Ìy”5N!ïóÏÈÙaQø–Òß@‘S\é@Ô­”ŸT7[yÔ Iw¾˜·?‚©YBBŠÄLQ ÆäWH÷í^É–£ùË4ú1NÙĞ˜œQ o³ÒVG´SY'yÔKúÕT–F­Ô„OU¾èŞ@§1B1C@ÄŒì˜Å³ËXH,Š¿É´z¸ËB*NÂ›Ğ&ØQÓÒÒDİSŞŸÔŸÙU~îÔ±$¾ŞD@õgüAş•ZÄ.¨ÄìÊNH`”ÊıäcËŞWN	4Ğ­§Q”êôÒ•RTyÉÔË
:UW¹!Õ"aÒ½ådc@†AsfÄ`
Ee²9HÊ'¢ÊùQNÙ€ĞPÍ«Q­Ó¯]!TVnûÔewqUÕjYÕğ	½åq@¹0Œ?—bÄzÎ­EC½H¼d2ÊMX„J)èôM¢4Ğ‚Ï¸QÓÓVÛ?T§¡Õ0!›U%©Õr1â<¨İn@W´eÁ74OÄôF§gçGß#=Ê¬îOKŸ_ÆMàĞe.ÄQÉ”3Ó³ÍaTÉ>ÕµdÅUŞ¾Õ¶¹=ÖZ@@CäÁŸê.Ä¸ê)F4§GöI>ÊÉ;©KF’M‰ôĞ3hÍQ_GÓƒT§§gÕ„ĞøU„ĞøÕ­>Ô„7@­ç!Â‡Ä2ŸCFî~µF-Î5Ê[!âKoO4MÌ—ùÏRşÓQ·N[Ó{Ê—T…U‹Õ}cVŞè Ö¯ãA>P¬@–EÂ($ Ã'›PF,œÏÆX%$ÊêL¶ ~L(OáÏÖz×Q®OnÓ—o­TÎ¦ÕÚ^@VÉJNÖ’`>ÍÊ?£ãZÂ½œÀÂ95PF½•Çó>
Ê©L—UÌÔhÃÏEv×Q}€ÓAÄT#8ÄÕlV¯ƒÖb‚m>ªŞŠ>`Â‰¥CQ›BFüXãÇöÒÉ‹"L×›&Í2| ÏSÓQkè‡Ó­ñÛTÔÉåÕ‰®VwI¥Öû¬i>zú1¿pgVÂr¯¬CVÏ(F¹Èô2‡É¸#LØ‡ÍŒ¹rÏV¶ËQÍÓâôTYdÖr­Vb´ÎÖT
U>¾…Ì¿Ç_=ÂµhDn–FF€,ÈÈÕÈ¹®LH@¶ÍM+Ï¦¿Qv§“Ó#+UgÖ¶´ÏVj? ×gR1>rãÀŞgÂÈ*Dz·°Ep:ÈksHÏ.L£ÜÍ·‡‹Îçs¯QÎè–Ó=
UFF/ÖıÊöVµğ×ìI>(ô=ÀŸ¡ÎÁ¥DDI"EçR=È|^I½÷K|cùÍÚM0L›Qè˜ÓæcUgFÖBWÈA×S‘=©åUÀ™[BÁÜ®OD¹BÄñ‹4ÈÑâ¸I´vÃK"¡ÎÚ½ÖN ‚ƒQ§ã–Ó”é'UÆ¸^ÖòD*W
[j×Û”4<Ú0^À?İ@MD®¿wÅjè ÈiJ÷I–†K+¸Î >OÈQQÒ7“ÓïH1U×ôwÖZÊEW¬<×â0H½DoVÀ¿ÿA‚e<D."ÖÅ“®Èû…JfK¬ÎÎ=‚„OŸ$QôïŒÓ.9UqâˆÖºdW¥©×½Ö½_?ÀúÈçAœD¦­Æq½Ç8Ç"J;iÊÈ úÍ ¤O,)¯Pİ„ÓF?U“á•Öæ“‚WsÉ×Ö«¾)ÒÀŞB¤~îCse,ÆL^QÇL˜(JJMËXİÍº+¾O~(¹O:ïpÓ¯ACU¸½¢Öğr”Wi‘í×„@¾“×¿‰<BÓOC€€<Æ˜úåÅ[±$J-¥ˆËäê¶Í'ĞOğ&%ĞÖáTÓ¦ØDUS6¯Ö–§W†tØW¾T¿ÒqMB(BÚ
@ÆƒÄGgXJ=QÁË³sˆÍ7ºÙOl|ÏĞ|G4ÓAÌCUp»Ö+á»W_µ"ØšÓ]¾0-˜=¢OBÇÃµã6Æ5 G&^J‡:ïË…+(ÍıÚO8"Ñ5¸ÓŠê?UáÅÖA.ÑW›¯<Ø§|T¾?v?CB{¦ÃÀ¾!ÆõEêGg%ÈIùşÌ#bÌÚ„ÒOÄVÑàëÏÒ9Uå|ÏÖAMçWøYØ&İ;¾·ã?¸ã(BV.şÃ—Æ&UHIe‚IôÌp.cL¶æÁO…ÈÑ¢wÒ//UŒ×ÖêşW;DyØŞ¾-Ú@'ğBÊ!ÄT0´Å‡&HglÖH‚Ì\&MüX©Où“ÑT¿”Ñ)H"U$ÃİÖû†
XòØª²Ê½á{<@q¨Aâ9ÄÏ1Å^'/H†‰MÈ+0ÌDt…M0Ú‰OeåŸÑšÙÆQuUÜÚáÖÔXoæ Ø7½dIN@Rü@óJCÄÈ´qC†-H]¥MÉâ¤ùËBÈ°M@rIO¼v¦Ñ€†RäÉÿTâ‘ãÖFn!X*JµØ}lG<äQ@<¶Àaù?Äî„ME H>­É=wÏËRÓM) îNºí¦ÑÂÖRÀºÕTp¯âÖRv,XÑ%ËØ÷Š=¢ĞD@D)–Ád/Äxg¾E%úHyÎèÉâ.šË‘êMĞ` NÆ:¡ÑSps§T…ßÖæô6X³jâØI$ò=p*@C]óÁ?ÇÄ‹ZFŸ¤ÒGyÊú€9Ë&/öMÂ¯^Î‰•Ñ 0S¾¦kTsØÖÁµ@XiûØ‹#>ƒô@¹SÂá[ØÃqf FSP†GïÊ0¨TÊSõM®^Ï~A„ÑF—JSH¼TåÎÖkƒIXÑi
ÙSçA>¶f¨?¡h9Â˜GyÃ§…1FÁ†ÇFèìÊ1˜¢JCèM;ZÏ£\Ñ²‘^SßWËRU[ÂÖU(QXÜÙ'R>Hõ>n&FÂ÷‰FÂ.¢6Fûó”Æk+ÊÂeRK–ÏMÛàÏnD'Ñ_kSi¸¡Ó»ã²ÖpWX"Ã%ÙwÙR>¸OÆ¾Z¹DÂTC¶s/FórÇZ,Êºx£Ky«M±ñ©ÏÁ„ØĞ§†pSŒ8Ô¢  Ös(\X®4Ù¯aD>Oœ¿qN5ÂP«CÊƒF–tÅÇgŸéÉÃ7ÔK«ä~M‡½ÏÛ$5ĞCÎmS/‡ÔYÆ‹Ö#_XøŠBÙ=À'>H:û¿*Â»şCDHşE…,Èì®É7¸øK=õMÇdÇÏÒi™OÑ=cSéëºÔ­6iÖg6`Xp1QÙ;/ş=É#ÀÂäÁ¹`D;¯²EiÈ¢±SÉyL6L~jÈÏ® ¥Pq!QS¦>ãÔºî6Öõ>_XşØ_ÙÊš=¢÷=À“&†ÁL{4D6¾6Eá&È(çtÈªÕ
L°¨Ì\ÀÏ©SQ•8S²Õ„Ö“ \Xu^nÙF²<ÍSJÀH@xÀúì<Dp`Â5+(ÈÁ¸HòDL[V+Í~Í®Ï7
DQÂS¬2Õ!Ã“ÕWÇVX|ÙAô½šHÀİÕAJ+8D=Ô<ÅpÈöÀoIÔôK<†ÍŞZ•ÏqQ±èR$¼Õ"HˆÔp(OXˆ7…Ù,°½ˆJ7Àµ=­AÉ•&Db´ÅËiÈ÷¹IÁÅÍK‹”¯ÍşàiÏëkŠQ
˜RîÕËUÕBEX#×‹Ùx`¾©\À¹óBàn	DßäıÅ?²àÇÔnğI³Â›KÏ‹ÏÍ`)Ï K–Q¦RİÕ!ê¿U®9Xi’Ù“¶,¾ Şà¿Ïä#BŠÅC½ÆÈ%šÇVüJ•àAKväÍD–ÎŞ›QAÛ+Ñ :ÕøÜVŠÒ*Xßî—Ù;lE¾<ë}¿â:B[8UCí…,ÆgˆÇ¯J.¼‚J;íÍµb4MÀçšQ™ŸXÒ¿.Õ#HVRyXÙBÙ£¿O¾=¬ ¾oåBB*à†A?P2ÆŠ½³EŞJ•C…ÊÑgéÍ@éÁNµp“QP¿ÒbïÕ“÷vVõ;XÒ¢ÙùJ¾>0?4Î=B¡Q4Ãİ,Æû±>Gù7Jm‹BËK0ÙÍÕ1OLÇ…QouÓÕ ïÔV´—èWº(¦ÙDw7¾¬¥½?¡++BL¶Ã ÆÖ!­Gñ Jxƒ›Ëöq½ÍšzOîùdQ†&ÓˆÈÔ#Š¡VÆ½WE©Ù°¨¾+´
@ˆUB1ÊÄQhûÅ¦ïGæ4ĞI²ÌËí¥—ÍŒ›OŸ