'use strict';

const fs = require('fs');
const sysPath = require('path');
const { promisify } = require('util');
const isBinaryPath = require('is-binary-path');
const {
  isWindows,
  isLinux,
  EMPTY_FN,
  EMPTY_STR,
  KEY_LISTENERS,
  KEY_ERR,
  KEY_RAW,
  HANDLER_KEYS,
  EV_CHANGE,
  EV_ADD,
  EV_ADD_DIR,
  EV_ERROR,
  STR_DATA,
  STR_END,
  BRACE_START,
  STAR
} = require('./constants');

const THROTTLE_MODE_WATCH = 'watch';

const open = promisify(fs.open);
const stat = promisify(fs.stat);
const lstat = promisify(fs.lstat);
const close = promisify(fs.close);
const fsrealpath = promisify(fs.realpath);

const statMethods = { lstat, stat };

// TODO: emit errors properly. Example: EMFILE on Macos.
const foreach = (val, fn) => {
  if (val instanceof Set) {
    val.forEach(fn);
  } else {
    fn(val);
  }
};

const addAndConvert = (main, prop, item) => {
  let container = main[prop];
  if (!(container instanceof Set)) {
    main[prop] = container = new Set([container]);
  }
  container.add(item);
};

const clearItem = cont => key => {
  const set = cont[key];
  if (set instanceof Set) {
    set.clear();
  } else {
    delete cont[key];
  }
};

const delFromSet = (main, prop, item) => {
  const container = main[prop];
  if (container instanceof Set) {
    container.delete(item);
  } else if (container === item) {
    delete main[prop];
  }
};

const isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;

/**
 * @typedef {String} Path
 */

// fs_watch helpers

// object to hold per-process fs_watch instances
// (may be shared across chokidar FSWatcher instances)

/**
 * @typedef {Object} FsWatchContainer
 * @property {Set} listeners
 * @property {Set} errHandlers
 * @property {Set} rawEmitters
 * @property {fs.FSWatcher=} watcher
 * @property {Boolean=} watcherUnusable
 */

/**
 * @type {Map<String,FsWatchContainer>}
 */
const FsWatchInstances = new Map();

/**
 * Instantiates the fs_watch interface
 * @param {String} path to be watched
 * @param {Object} options to be passed to fs_watch
 * @param {Function} listener main event handler
 * @param {Function} errHandler emits info about errors
 * @param {Function} emitRaw emits raw event data
 * @returns {fs.FSWatcher} new fsevents instance
 */
function createFsWatchInstance(path, options, listener, errHandler, emitRaw) {
  const handleEvent = (rawEvent, evPath) => {
    listener(path);
    emitRaw(rawEvent, evPath, {watchedPath: path});

    // emit based on events occurring for files from a directory's watcher in
    // case the file's watcher misses it (and rely on throttling to de-dupe)
    if (evPath && path !== evPath) {
      fsWatchBroadcast(
        sysPath.resolve(path, evPath), KEY_LISTENERS, sysPath.join(path, evPath)
      );
    }
  };
  try {
    return fs.watch(path, options, handleEvent);
  } catch (error) {
    errHandler(error);
  }
}

/**
 * Helper for passing fs_watch event data to a collection of listeners
 * @param {Path} fullPath absolute path bound to fs_watch instance
 * @param {String} type listener type
 * @param {*=} val1 arguments to be passed to listeners
 * @param {*=} val2
 * @param {*=} val3
 */
const fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {
  const cont = FsWatchInstances.get(fullPath);
  if (!cont) return;
  foreach(cont[type], (listener) => {
    listener(val1, val2, val3);
  });
};

/**
 * Instantiates the fs_watch interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path
 * @param {String} fullPath absolute path
 * @param {Object} options to be passed to fs_watch
 * @param {Object} handlers container for event listener functions
 */
const setFsWatchListener = (path, fullPath, options, handlers) => {
  const {listener, errHandler, rawEmitter} = handlers;
  let cont = FsWatchInstances.get(fullPath);

  /** @type {fs.FSWatcher=} */
  let watcher;
  if (!options.persistent) {
    watcher = createFsWatchInstance(
      path, options, listener, errHandler, rawEmitter
    );
    return watcher.close.bind(watcher);
  }
  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_ERR, errHandler);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    watcher = createFsWatchInstance(
      path,
      options,
      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),
      errHandler, // no need to use broadcast here
      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)
    );
    if (!watcher) return;
    watcher.on(EV_ERROR, async (error) => {
      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);
      cont.watcherUnusable = true; // documented since Node 10.4.1
      // Workaround for https://github.com/joyent/node/issues/4337
      if (isWindows && error.code === 'EPERM') {
        try {
          const fd = await open(path, 'r');
          await close(fd);
          broadcastErr(error);
        } catch (err) {}
      } else {
        broadcastErr(error);
      }
    });
    cont = {
      listeners: listener,
      errHandlers: errHandler,
      rawEmitters: rawEmitter,
      watcher
    };
    FsWatchInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // removes this instance's listeners and closes the underlying fs_watch
  // instance if there are no more listeners left
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_ERR, errHandler);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      // Check to protect against issue gh-730.
      // if (cont.watcherUnusable) {
      cont.watcher.close();
      // }
      FsWatchInstances.delete(fullPath);
      HANDLER_KEYS.forEach(clearItem(cont));
      cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

// fs_watchFile helpers

// object to hold per-process fs_watchFile instances
// (may be shared across chokidar FSWatcher instances)
const FsWatchFileInstances = new Map();

/**
 * Instantiates the fs_watchFile interface or binds listeners
 * to an existing one covering the same file system entry
 * @param {String} path to be watched
 * @param {String} fullPath absolute path
 * @param {Object} options options to be passed to fs_watchFile
 * @param {Object} handlers container for event listener functions
 * @returns {Function} closer
 */
const setFsWatchFileListener = (path, fullPath, options, handlers) => {
  const {listener, rawEmitter} = handlers;
  let cont = FsWatchFileInstances.get(fullPath);

  /* eslint-disable no-unused-vars, prefer-destructuring */
  let listeners = new Set();
  let rawEmitters = new Set();

  const copts = cont && cont.options;
  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {
    // "Upgrade" the watcher to persistence or a quicker interval.
    // This creates some unlikely edge case issues if the user mixes
    // settings in a very weird way, but solving for those cases
    // doesn't seem worthwhile for the added complexity.
    listeners = cont.listeners;
    rawEmitters = cont.rawEmitters;
    fs.unwatchFile(fullPath);
    cont = undefined;
  }

  /* eslint-enable no-unused-vars, prefer-destructuring */

  if (cont) {
    addAndConvert(cont, KEY_LISTENERS, listener);
    addAndConvert(cont, KEY_RAW, rawEmitter);
  } else {
    // TODO
    // listeners.add(listener);
    // rawEmitters.add(rawEmitter);
    cont = {
      listeners: listener,
      rawEmitters: rawEmitter,
      options,
      watcher: fs.watchFile(fullPath, options, (curr, prev) => {
        foreach(cont.rawEmitters, (rawEmitter) => {
          rawEmitter(EV_CHANGE, fullPath, {curr, prev});
        });
        const currmtime = curr.mtimeMs;
        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {
          foreach(cont.listeners, (listener) => listener(path, curr));
        }
      })
    };
    FsWatchFileInstances.set(fullPath, cont);
  }
  // const index = cont.listeners.indexOf(listener);

  // Removes this instance's listeners and closes the underlying fs_watchFile
  // instance if there are no more listeners left.
  return () => {
    delFromSet(cont, KEY_LISTENERS, listener);
    delFromSet(cont, KEY_RAW, rawEmitter);
    if (isEmptySet(cont.listeners)) {
      FsWatchFileInstances.delete(fullPath);
      fs.unwatchFile(fullPath);
      cont.options = cont.watcher = undefined;
      Object.freeze(cont);
    }
  };
};

/**
 * @mixin
 */
class NodeFsHandler {

/**
 * @param {import("../index").FSWatcher} fsW
 */
constructor(fsW) {
  this.fsw = fsW;
  this._boundHandleError = (error) => fsW._handleError(error);
}

/**
 * Watch file for changes with fs_watchFile or fs_watch.
 * @param {String} path to file or dir
 * @param {Function} listener on fs change
 * @returns {Function} closer for the watcher instance
 */
_watchWithNodeFs(path, listener) {
  const opts = this.fsw.options;
  const directory = sysPath.dirname(path);
  const basename = sysPath.basename(path);
  const parent = this.fsw._getWatchedDir(directory);
  parent.add(basename);
  const absolutePath = sysPath.resolve(path);
  const options = {persistent: opts.persistent};
  if (!listener) listener = EMPTY_FN;

  let closer;
  if (opts.usePolling) {
    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?
      opts.binaryInterval : opts.interval;
    closer = setFsWatchFileListener(path, absolutePath, options, {
      listener,
      rawEmitter: this.fsw._emitRaw
    });
  } else {
    closer = setFsWatchListener(path, absolutePath, options, {
      listener,
      errHandler: this._boundHandleError,
      rawEmitter: this.fsw._emitRaw
    });
  }
  return closer;
}

/**
 * Watch a file and emit add event if warranted.
 * @param {Path} file Path
 * @param {fs.Stats} stats result of fs_stat
 * @param {Boolean} initialAdd was the file added at watch instantiation?
 * @returns {Function} closer for the watcher instance
 */
_handleFile(file, stats, initialAdd) {
  if (this.fsw.closed) {
    return;
  }
  const dirname = sysPath.dirname(file);
  const basename = sysPath.basename(file);
  const parent = this.fsw._getWatchedDir(dirname);
  // stats is always present
  let prevStats = stats;

  // if the file is already being watched, do nothing
  if (parent.has(basename)) return;

  const listener = async (path, newStats) => {
    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;
    if (!newStats || newStats.mtimeMs === 0) {
      try {
        const newStats = await stat(file);
        if (this.fsw.closed) return;
        // Check that change event was not fired because of changed only accessTime.
        const at = newStats.atimeMs;
        const mt = newStats.mtimeMs;
        if (!at || at <= mt || mt !== prevStats.mtimeMs) {
          this.fsw._emit(EV_CHANGE, file, newStats);
        }
        if (isLinux && prevStats.ino !== newStats.ino) {
          this.fsw._closeFile(path)
          prevStats = newStats;
          this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));
        } else {
          prevStats = newStats;
        }
      } catch (error) {
        // Fix issues where mtime is null but file is still present
        this.fsw._remove(dirname, basename);
      }
      // add is about to be emitted if file not already tracked in parent
    } else if (parent.has(basename)) {
      // Check that change event was not fired because of changed only accessTime.
      const at = newStats.atimeMs;
      const mt = newStats.mtimeMs;
      if (!at || at <= mt || mt !== prevStats.mtimeMs) {
        this.fsw._emit(EV_CHANGE, file, newStats);
      }
      prevStats = newStats;
    }
  }
  // kick off the watcher
  const closer = this._watchWithNodeFs(file, listener);

  // emit an add event if we're supposed to
  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {
    if (!this.fsw._throttle(EV_ADD, file, 0)) return;
    this.fsw._emit(EV_ADD, file, stats);
  }

  return closer;
}

/**
 * Handle symlinks encountered while reading a dir.
 * @param {Object} entry returned by readdirp
 * @param {String} directory path of dir being read
 * @param {String} path of this item
 * @param {String} item basename of this item
 * @returns {Promise<Boolean>} true if no more processing is needed for this entry.
 */
async _handleSymlink(entry, directory, path, item) {
  if (this.fsw.closed) {
    return;
  }
  const full = entry.fullPath;
  const dir = this.fsw._getWatchedDir(directory);

  if (!this.fsw.options.followSymlinks) {
    // watch symlink directly (don't follow) and detect changes
    this.fsw._incrReadyCount();

    let linkPath;
    try {
      linkPath = await fsrealpath(path);
    } catch (e) {
      this.fsw._emitReady();
      return true;
    }

    if (this.fsw.closed) return;
    if (dir.has(item)) {
      if (this.fsw._symlinkPaths.get(full) !== linkPath) {
        this.fsw._symlinkPaths.set(full, linkPath);
        this.fsw._emit(EV_CHANGE, path, entry.stats);
      }
    } else {
      dir.add(item);
      this.fsw._symlinkPaths.set(full, linkPath);
      this.fsw._emit(EV_ADD, path, entry.stats);
    }
    this.fsw._emitReady();
    return true;
  }

  // don't follow the same symlink more than once
  if (this.fsw._symlinkPaths.has(full)) {
    return true;
  }

  this.fsw._symlinkPaths.set(full, true);
}

_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {
  // Normalize the directory name on Windows
  directory = sysPath.join(directory, EMPTY_STR);

  if (!wh.hasGlob) {
    throttler = this.fsw._throttle('readdir', directory, 1000);
    if (!throttler) return;
  }

  const previous = this.fsw._getWatchedDir(wh.path);
  const current = new Set();

  let stream = this.fsw._readdirp(directory, {
    fileFilter: entry => wh.filterPath(entry),
    directoryFilter: entry => wh.filterDir(entry),
    depth: 0
  }).on(STR_DATA, async (entry) => {
    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    const item = entry.path;
    let path = sysPath.join(directory, item);
    current.add(item);

    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path, item)) {
      return;
    }

    if (this.fsw.closed) {
      stream = undefined;
      return;
    }
    // Files that present in current directory snapshot
    // but absent in previous are added to watch list and
    // emit `add` event.
    if (item === target || !target && !previous.has(item)) {
      this.fsw._incrReadyCount();

      // ensure relativeness of path is preserved in case of watcher reuse
      path = sysPath.join(dir, sysPath.relative(dir, path));

      this._addToNodeFs(path, initialAdd, wh, depth + 1);
    }
  }).on(EV_ERROR, this._boundHandleError);

  return new Promise(resolve =>
    stream.once(STR_END, () => {
      if (this.fsw.closed) {
        stream = undefined;
        return;
      }
      const wasThrottled = throttler ? throttler.clear() : false;

      resolve();

      // Files that absent in current directory snapshot
      // but present in previous emit `remove` event
      // and are removed from @watched[directory].
      previous.getChildren().filter((item) => {
        return item !== directory &&
          !current.has(item) &&
          // in case of intersecting globs;
          // a path may have been filtered out of this readdir, but
          // shouldn't be removed because it matches a different glob
          (!wh.hasGlob || wh.filterPath({
            fullPath: sysPath.resolve(directory, item)
          }));
      }).forEach((item) => {
        this.fsw._remove(directory, item);
      });

      stream = undefined;

      // one more time for any missed in case changes came in extremely quickly
      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);
    })
  );
}

/**
 * Read directory to add / remove files from `@watched` list and re-read it on change.
 * @param {String} dir fs path
 * @param {fs.Stats} stats
 * @param {Boolean} initialAdd
 * @param {Number} depth relative to user-supplied path
 * @param {String} target child path targeted for watch
 * @param {Object} wh Common watch helpers for this path
 * @param {String} realpath
 * @returns {Promise<Function>} closer for the watcher instance.
 */
async _handleDir(dir, stats, initialAdd, depth, target‹òL‹ùH‹jH+*HÁıH…í„õ  3ÛDc3öI‹>H9t(†  H‹D;H‹ğH…ÉuH‹D;8H‹ˆh  H…É„ß   ‹A‰A…ÀuH‹A‹ÔH‹ ÿ}©# I‹>I‹èN[ÜÿL‹ĞI‹H‹LH‹ñH…ÒuH‹D8H‹h  H‰T$xH…ÒtDbEŠÌLD$xH”$ˆ   I‹ÊèôûÿL‹D;H‹H…ÒtDbI‹ğI‰ğH…ÉtƒiuH‹A‹ÔH‹ ÿù¨# H‹Œ$ˆ   H…ÉtƒiuH‹A‹ÔH‹ ÿ×¨# H‹L$xH…ÉtƒiuH‹A‹ÔH‹ ÿ·¨# IôI‹>H;t(‚íşÿÿI‹èzZÜÿL‹ĞI‹H‹L H…ÉuH‹D8H‹ˆh  H‰Œ$€   H…ÉtDaEŠÌL„$€   HT$ I‹Êè!ûÿH‹H…ÒtDbH‹L; H‰T; H…ÉtƒiuH‹A‹ÔH‹ ÿ)¨# H‹L$ H…ÉtƒiuH‹A‹ÔH‹ ÿ
¨# H‹Œ$€   H…ÉtƒiuH‹A‹ÔH‹ ÿç§# HƒÃ@I+ì…şÿÿHƒÄ0A_A^A\_^][ÃH‰\$L‰D$H‰T$UVWATAUAVAWH‹ìHƒìPI‹øL‹êL‹ñE3äD‰eĞH‹
H‹AƒÏÿA‹×H‹@Xÿ€§# „À…k  I‹F H…ÀuI‹F8H‹€h  H‰EX¾   H…ÀtpH‹EXL‹ÇI‹ÕH…Àt*HMèè“õİÿ‰uĞL‹ÀHUXHMàè¸ÿİÿ¿   H‹H‹]HëHMØèiõİÿH‹H‹ÙL‰ ¿   H…ÉtqM‹F I‰N M…ÀtExuI‹ ‹ÖI‹ÈH‹ ÿ×¦# @öÇtƒç÷H…ÛtD{uH‹‹ÖH‹ËH‹ ÿ²¦# @öÇt!ƒçûH‹MØH…ÉtDyuH‹‹ÖH‹ ÿŒ¦# @öÇt!ƒçıH‹MàH…ÉtDyuH‹‹ÖH‹ ÿe¦# @„ştH‹MèH…ÉtDyuH‹‹ÖH‹ ÿB¦# H‹MXH…ÉtDyuH‹‹ÖH‹ ÿ$¦# I‹M H…É„¯  Dyé–  M‹E A‹H‹ÁÁè	¾   @"ÆL=±Á4 MEıI‹H…À„ç  ~9xT…×  A‹üL‹H@E9a~&I‹ÔMcQM‹	I‹‹HÁé@"ÎuEşHÖIƒÁI;Ò|äM…ÀtAƒhuI‹ I‹È‹ÖH‹ ÿ…¥# 2ÀH‹œ$   HƒÄPA_A^A]A\_^]ÃI‹^8¹ˆ   èY" H‰EXD‹ÏLƒp  I‹×H‹Èè¨^ßÿL‹ÀÇEĞ   H‰EØI‹H‹@@‹ÏH‹ HÈH‹‹AÁè@"ÆuHÉÁ4 H‹ÂÁ4 H…É„Æ  I‹ ƒÊÿI‹ÈH‹@Xÿî¤# „À…§  M‹üI‹V(H…ÒtI‹N0H‹D‹@8H‹D9 tLşHƒÀL;úrïL‹úI‹FN9$øtJøë
I‹F8Hh  H‹ H‰EXH…ÀtpH‹EXL‹EPHUØH…Àt9HMğèÍòİÿÇEĞ  L‹ÀHUXHMàfff„     èãüİÿ¿0  H‹H‹]HëHMèè”òİÿH‹H‹ÙL‰ ¿À  I‹FH…ÉtqN‹øJ‰øM…ÀtAƒhuI‹ ‹ÖI‹ÈH‹ ÿı£# @„ÿy º÷H…ÛtƒkuH‹‹ÖH‹ËH‹ ÿØ£# @öÇ@t!ƒç¿H‹MèH…ÉtƒiuH‹‹ÖH‹ ÿ²£# @öÇ t!ƒçßH‹MàH…ÉtƒiuH‹‹ÖH‹ ÿ‹£# @öÇtH‹MğH…ÉtƒiuH‹‹ÖH‹ ÿg£# H‹MXH…ÉtƒiuH‹‹ÖH‹ ÿI£# H‹MØé¡  L‹EØM…ÀtAƒhuI‹ ‹ÖI‹ÈH‹ ÿ£# I‹M H…É„‹ıÿÿƒi…ıÿÿH‹énıÿÿH‹}PÁé@"ÎH¥¿4 IEİH‹H…Ò„;ıÿÿI‹N(H…ÉtI‹F0D‹B8H‹D9tLæHƒÂL;árïL‹áI‹FJƒ<à tJàë
I‹F8Hh  H‹ H‰EXH…ÀtpH‹EXH…Àt&L‹ÇHUXHMğèûİÿH‹8Hƒ  A¿   H‹ÇH‹]HëH‹H‹ØH…ÀtpA¿   H‹}HI‹VH…ÀtpJ‹âJ‰âH…ÉtƒiuH‹‹ÖH‹ ÿ¢# Aºç
s!Aº÷
H…ÛtƒkuH‹‹ÖH‹ËH‹ ÿï¡# Aºç	s!Aº÷	H…ÿtƒouH‹‹ÖH‹ÏH‹ ÿÇ¡# AºçsH‹MğH…ÉtƒiuH‹‹ÖH‹ ÿ£¡# H‹MXH…ÉtƒiuH‹‹ÖH‹ ÿ…¡# I‹M H…ÉtƒiuH‹‹ÖH‹ ÿg¡# @ŠÆéÜûÿÿÌL‰D$USVWATAUAVAWH‹ìHƒìXM‹ğL‹úH‹ñH‹RH‰Q(HƒÁè:  L‰~0I‹‹AÁèA½   A"ÅL%õ¼4 MEæM‹$M…ÀuH…É„C  ƒi…9  A‹Õé%  I‹ º   I‹ÈH‹@@ÿĞ # „Àu(I‹$H‰EHH…ÀtDhLEHI‹×H‹Îè  „À…í   I‹$‹HTƒùu?H‹@@H‹ H‹ H‰EHH…ÀtDhLEHI‹×H‹Îèÿÿÿ„ÀuI‹éfÿÿÿH‹Îè>	  é¢   ƒù9…¾   H‹@@H‹8¹p   è;" H‰EHLOL‹Çº   H‹Èè‰ŞÿH‹ØH‰EPH‰EHH…ÀtDhLEHI‹×H‹Îè¨şÿÿ„Àu"H…Ûtƒku‡H‹A‹ÕH‹ËH‹ ÿãŸ# épÿÿÿH‹Îè¶  H…ÛtƒkuH‹A‹ÕH‹ËH‹ ÿ¸Ÿ# I‹H…ÉtƒiuH‹A‹ÕH‹ ÿšŸ# AŠÅéà  ƒùtAñƒø‡ÿÿÿ‰I‹$ƒxTuÇ   ëHƒeP ƒxTu
Ç   L‰mPE3íA¹x  H@¸4 I‹$H‹H@H‹J‹è‹AÁè	$H‹êº4 HEÙH‰]ØH…ÛtÿCH‹ûH…Û„:  ƒ{T…0  ƒeH H‰]àÿCH‰UèH‹N8èÈPÜÿH‹øH‹N8è¼PÜÿLˆ¨  LEHHUàH‹ÏèuI L‹ûƒ}H „¿   H‹N8èPÜÿA±LEàHUĞH‹ÈèÈ„ûÿH‹H…ÒtÿBH‹MàH‰UàH…ÉtƒiuH‹º   H‹ ÿq# Hb·4 H‰EèH‹MĞH…ÉtƒiuH‹º   H‹ ÿF# H‹Mà‹AÁè	$H‹=ó¹4 HEùH…ÿtÿGH‹ËH‹ßH‰]ØL‹ÿH…ÉtƒiuH‹º   H‹ ÿş# I‹ÿH‹MàH…ÉtƒiuH‹º   H‹ ÿÚ# A¹x  H…ÿtfƒ{Tu`3ÿH‹C@LcxM…ÿŠ   A¸p  L;mPMEÁLF8H‹C@H‹ H‹øH‰E`H…Àtÿ@HU`H‹Îè¹õÿÿ„À„„   HÿÇI;ÿA¹x  |µë=A¸p  L;mPMEÁLF8I‹$H‹H@H‹J‹èH‰EÈH…Àtÿ@HUÈH‹Îèhõÿÿ„Àt9H…ÛtƒkuH‹º   H‹ËH‹ ÿ# IÿÅIƒıŒ«ıÿÿA½   é>ıÿÿëH…ÿtƒkuH‹º   H‹ËH‹ ÿÔœ# I‹H…Étƒiuº   H‹H‹ ÿ´œ# 2ÀHƒÄXA_A^A]A\_^[]ÃH‰\$L‰D$UVWATAUAVAWH‹ìHƒì0I‹ğL‹úL‹áM‹A‹AÁèA½   A"ÅHI¸4 IEÀL‹0M…ö„ú  E‹^TAƒûueI‹F@H‹8AMoè3ÿ! H‰EğL‹ÏLGAUH‹Èè…ŞÿH‰EXHƒeğ LEXI‹×I‹ÌèhÿÿÿŠØH‹H…ÉtƒiuH‹H‹A‹Õÿé›# ŠÃé«  AƒûuDI‹F@H‹8AK^èÈş! H‰EğL‹ÏLGº   H‹Èè˜„ŞÿH‰EXHƒeğ LEXI‹×I‹ÌèüşÿÿŠØë’L‹y·4 L‹R¸4 Aƒû