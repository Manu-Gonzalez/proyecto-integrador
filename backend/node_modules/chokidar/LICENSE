pected wff NameNode",void 0!==d),i.Pledge.resolve(d)}cellRefNode(e,t,n){return i.Pledge.resolve((0,s.cellRefTerm)(e,t,n))}fieldRefNode(e,t,n){(0,i.assertTrue)("calc.runtime.compile: expected wff FieldRef",t.field.kind===r.NodeKind.Ident);const o=t.field.whole;return this.lazyVisitFormulaNode(e).bind((e=>this.toFieldRefTerm(e,o,n)))}toFieldRefTerm(e,t,n){const i=r.WorksheetFuncId.FIELDVALUE;return(0,s.appTerm)((0,s.worksheetFunctionIdToName)(i),(0,r.getWorksheetFuncType)(i),!1,void 0,[e,(0,r.stringOper)(t)],n)}noopTerm(e,t){return this.context.locals.emitStepInfo?(0,s.noopTerm)(e,t):e}structRefNode(e,t,n){return i.Pledge.resolve((0,s.structRefTerm)((0,r.structRefNode)(e,t,n),n))}missingNode(e,t){return(0,i.assertFalse)("calc.runtime.compile: unexpected missing node")}badSequenceNode(e,t,n){return(0,i.assertFalse)("calc.runtime.compile: unexpected bad node")}badCharsNode(e,t,n){return(0,i.assertFalse)("calc.runtime.compile: unexpected bad node")}operatorNode(e,t){return i.Pledge.resolve((0,r.operatorNode)(e,t))}wsfNode(e,t,n){return i.Pledge.resolve((0,r.wsfNode)(e,t,n))}}const g={[r.OperatorId.At]:r.Workshee