import { isMovable, isTaskQueue, isTransferable, kFieldCount, kQueueOptions, kRequestCountField, kResponseCountField, kTransferable, kValue, markMovable } from "./common-Qw-RoVFD.js";
import { MessageChannel, MessagePort, Worker, receiveMessageOnPort } from "node:worker_threads";
import { EventEmitterAsyncResource, once } from "node:events";
import { AsyncResource } from "node:async_hooks";
import { URL, fileURLToPath } from "node:url";
import { join } from "node:path";
import { inspect, types } from "node:util";
import assert from "node:assert";
import { performance } from "node:perf_hooks";
import { readFileSync } from "node:fs";
import os from "node:os";
import childProcess, { fork } from "node:child_process";

//#region src/physicalCpuCount.ts
function exec(command) {
	const output = childProcess.execSync(command, {
		encoding: "utf8",
		stdio: [
			null,
			null,
			null
		]
	});
	return output;
}
let amount;
try {
	const platform = os.platform();
	if (platform === "linux") {
		const output1 = exec("cat /proc/cpuinfo | grep \"physical id\" | sort |uniq | wc -l");
		const output2 = exec("cat /proc/cpuinfo | grep \"core id\" | sort | uniq | wc -l");
		const physicalCpuAmount = parseInt(output1.trim(), 10);
		const physicalCoreAmount = parseInt(output2.trim(), 10);
		amount = physicalCpuAmount * physicalCoreAmount;
	} else if (platform === "darwin") {
		const output = exec("sysctl -n hw.physicalcpu_max");
		amount = parseInt(output.trim(), 10);
	} else if (platform === "win32") throw new Error();
	else {
		const cores = os.cpus().filter(function(cpu, index) {
			const hasHyperthreading = cpu.model.includes("Intel");
			const isOdd = index % 2 === 1;
			return !hasHyperthreading || isOdd;
		});
		amount = cores.length;
	}
} catch {
	amount = os.cpus().length;
}
if (amount === 0) amount = os.cpus().length;

//#endregion
//#region src/runtime/thread-worker.ts
var ThreadWorker = class {
	name = "ThreadWorker";
	runtime = "worker_threads";
	initialize(options) {
		this.thread = new Worker(fileURLToPath(import.meta.url + "/../entry/worker.js"), options);
		this.threadId = this.thread.threadId;
	}
	async terminate() {
		const output = await this.thread.terminate();
		this.channel?.onClose?.();
		return output;
	}
	postMessage(message, transferListItem) {
		return this.thread.postMessage(message, transferListItem);
	}
	on(event, callback) {
		return this.thread.on(event, callback);
	}
	once(event, callback) {
		return this.thread.once(event, callback);
	}
	emit(event, ...data) {
		return this.thread.emit(event, ...data);
	}
	ref() {
		return this.thread.ref();
	}
	unref() {
		return this.thread.unref();
	}
	setChannel(channel) {
		if (channel.onMessage) throw new Error("{ runtime: 'worker_threads' } doesn't support channel.onMessage. Use transferListItem for listening to messages instead.");
		if (channel.postMessage) throw new Error("{ runtime: 'worker_threads' } doesn't support channel.postMessage. Use transferListItem for sending to messages instead.");
		if (this.channel && this.channel !== channel) this.channel.onClose?.();
		this.channel = channel;
	}
};

//#endregion
//#region src/runtime/process-worker.ts
const __tinypool_worker_message__ = true;
const SIGKILL_TIMEOUT = 1e3;
var ProcessWorker = class {
	name = "ProcessWorker";
	runtime = "child_process";
	isTerminating = false;
	initialize(options) {
		this.process = fork(fileURLToPath(import.meta.url + "/../entry/process.js"), options.argv, {
			...options,
			stdio: "pipe",
			env: {
				...options.env,
				TINYPOOL_WORKER_ID: options.workerData[0].workerId.toString()
			}
		});
		process.stdout.setMaxListeners(1 + process.stdout.getMaxListeners());
		process.stderr.setMaxListeners(1 + process.stderr.getMaxListeners());
		this.process.stdout?.pipe(process.stdout);
		this.process.stderr?.pipe(process.stderr);
		this.threadId = this.process.pid;
		this.process.on("exit", this.onUnexpectedExit);
		this.waitForExit = new Promise((r) => this.process.on("exit", r));
	}
	onUnexpectedExit = () => {
		this.process.emit("error", new Error("Worker exited unexpectedly"));
	};
	async terminate() {
		this.isTerminating = true;
		this.process.off("exit", this.onUnexpectedExit);
		const sigkillTimeout = setTimeout(() => this.process.kill("SIGKILL"), SIGKILL_TIMEOUT);
		this.process.kill();
		await this.waitForExit;
		this.process.stdout?.unpipe(process.stdout);
		this.process.stderr?.unpipe(process.stderr);
		this.port?.close();
		this.channel?.onClose?.();
		clearTimeout(sigkillTimeout);
	}
	setChannel(channel) {
		if (this.channel && this.channel !== channel) this.channel.onClose?.();
		this.channel = channel;
		this.channel.onMessage?.((message) => {
			this.send(message);
		});
	}
	send(message) {
		if (!this.isTerminating) this.process.send(message);
	}
	postMessage(message, transferListItem) {
		transferListItem?.forEach((item) => {
			if (item instanceof MessagePort) {
				this.port = item;
				this.port.start();
			}
		});
		if (this.port) this.port.on("message", (message$1) => this.send({
			...message$1,
			source: "port",
			__tinypool_worker_message__
		}));
		return this.send({
			...message,
			source: "pool",
			__tinypool_worker_message__
		});
	}
	on(event, callback) {
		return this.process.on(event, (data) => {
			if (event === "error") return callback(data);
			if (!data || !data.__tinypool_worker_message__) return this.channel?.postMessage?.(data);
			if (data.source === "pool") callback(data);
			else if (data.source === "port") this.port.postMessage(data);
		});
	}
	once(event, callback) {
		return this.process.once(event, callback);
	}
	emit(event, ...data) {
		return this.process.emit(event, ...data);
	}
	ref() {
		return this.process.ref();
	}
	unref() {
		this.port?.unref();
		this.process.channel?.unref?.();
		if (hasUnref(this.process.stdout)) this.process.stdout.unref();
		if (hasUnref(this.process.stderr)) this.process.stderr.unref();
		return this.process.unref();
	}
};
function hasUnref(stream) {
	return stream != null && "unref" in stream && typeof stream.unref === "function";
}

//#endregion
//#region src/index.ts
const cpuCount = amount;
function onabort(abortSignal, listener) {
	if ("addEventListener" in abortSignal) abortSignal.addEventListener("abort", listener, { once: true });
	else abortSignal.once("abort", listener);
}
var AbortError = class extends Error {
	constructor() {
		super("The task has been aborted");
	}
	get name() {
		return "AbortError";
	}
};
var CancelError = class extends Error {
	constructor() {
		super("The task has been cancelled");
	}
	get name() {
		return "CancelError";
	}
};
var ArrayTaskQueue = class {
	tasks = [];
	get size() {
		return this.tasks.length;
	}
	shift() {
		return this.tasks.shift();
	}
	push(task) {
		this.tasks.push(task);
	}
	remove(task) {
		const index = this.tasks.indexOf(task);
		assert.notStrictEqual(index, -1);
		this.tasks.splice(index, 1);
	}
	cancel() {
		while (this.tasks.length > 0) {
			const task = this.tasks.pop();
			task?.cancel();
		}
	}
};
const kDefaultOptions = {
	filename: null,
	name: "default",
	runtime: "worker_threads",
	minThreads: Math.max(cpuCount / 2, 1),
	maxThreads: cpuCount,
	idleTimeout: 0,
	maxQueue: Infinity,
	concurrentTasksPerWorker: 1,
	useAtomics: true,
	taskQueue: new ArrayTaskQueue(),
	trackUnmanagedFds: true
};
const kDefaultRunOptions = {
	transferList: void 0,
	filename: null,
	signal: null,
	name: null
};
var DirectlyTransferable = class {
	#value;
	constructor(value) {
		this.#value = value;
	}
	get [kTransferable]() {
		return this.#value;
	}
	get [kValue]() {
		return this.#value;
	}
};
var ArrayBufferViewTransferable = class {
	#view;
	constructor(view) {
		this.#view = view;
	}
	get [kTransferable]() {
		return this.#view.buffer;
	}
	get [kValue]() {
		return this.#view;
	}
};
let taskIdCounter = 0;
function maybeFileURLToPath(filename) {
	return filename.startsWith("file:") ? fileURLToPath(new URL(filename)) : filename;
}
var TaskInfo = class extends AsyncResource {
	abortListener = null;
	workerInfo = null;
	constructor(task, transferList, filename, name, callback, abortSignal, triggerAsyncId, channel) {
		super("Tinypool.Task", {
			requireManualDestroy: true,
			triggerAsyncId
		});
		this.callback = callback;
		this.task = task;
		this.transferList = transferList;
		this.cancel = () => this.callback(new CancelError(), null);
		this.channel = channel;
		if (isMovable(task)) {
			/* istanbul ignore if */
			if (this.transferList == null) this.transferList = [];
			this.transferList = this.transferList.concat(task[kTransferable]);
			this.task = task[kValue];
		}
		this.filename = filename;
		this.name = name;
		this.taskId = taskIdCounter++;
		this.abortSignal = abortSignal;
		this.created = performance.now();
		this.started = 0;
	}
	releaseTask() {
		const ret = this.task;
		this.task = null;
		return ret;
	}
	done(err, result) {
		this.emitDestroy();
		this.runInAsyncScope(this.callback, null, err, result);
		if (this.abortSignal && this.abortListener) if ("removeEventListener" in this.abortSignal && this.abortListener) this.abortSignal.removeEventListener("abort", this.abortListener);
		else this.abortSignal.off("abort", this.abortListener);
	}
	get [kQueueOptions]() {
		return kQueueOptions in this.task ? this.task[kQueueOptions] : null;
	}
};
var AsynchronouslyCreatedResource = class {
	onreadyListeners = [];
	markAsReady() {
		const listeners = this.onreadyListeners;
		assert(listeners !== null);
		this.onreadyListeners = null;
		for (const listener of listeners) listener();
	}
	isReady() {
		return this.onreadyListeners === null;
	}
	onReady(fn) {
		if (this.onreadyListeners === null) {
			fn();
			return;
		}
		this.onreadyListeners.push(fn);
	}
};
var AsynchronouslyCreatedResourcePool = class {
	pendingItems = new Set();
	readyItems = new Set();
	constructor(maximumUsage) {
		this.maximumUsage = maximumUsage;
		this.onAvailableListeners = [];
	}
	add(item) {
		this.pendingItems.add(item);
		item.onReady(() => {
			/* istanbul ignore else */
			if (this.pendingItems.has(item)) {
				this.pendingItems.delete(item);
				this.readyItems.add(item);
				this.maybeAvailable(item);
			}
		});
	}
	delete(item) {
		this.pendingItems.delete(item);
		this.readyItems.delete(item);
	}
	findAvailable() {
		let minUsage = this.maximumUsage;
		let candidate = null;
		for (const item of this.readyItems) {
			const usage = item.currentUsage();
			if (usage === 0) return item;
			if (usage < minUsage) {
				candidate = item;
				minUsage = usage;
			}
		}
		return candidate;
	}
	*[Symbol.iterator]() {
		yield* this.pendingItems;
		yield* this.readyItems;
	}
	get size() {
		return this.pendingItems.size + this.readyItems.size;
	}
	maybeAvailable(item) {
		/* istanbul ignore else */
		if (item.currentUsage() < this.maximumUsage) for (const listener of this.onAvailableListeners) listener(item);
	}
	onAvailable(fn) {
		this.onAvailableListeners.push(fn);
	}
};
const Errors = {
	ThreadTermination: () => new Error("Terminating worker thread"),
	FilenameNotProvided: () => new Error("filename must be provided to run() or in options object"),
	TaskQueueAtLimit: () => new Error("Task queue is at limit"),
	NoTaskQueueAvailable: () => new Error("No task queue available and all Workers are busy")
};
var WorkerInfo = class extends AsynchronouslyCreatedResource {
	idleTimeout = null;
	lastSeenResponseCount = 0;
	constructor(worker, port, workerId, freeWorkerId, onMessage, filename, teardown) {
		super();
		this.worker = worker;
		this.workerId = workerId;
		this.freeWorkerId = freeWorkerId;
		this.teardown = teardown;
		this.filename = filename;
		this.port = port;
		this.port.on("message", (message) => this._handleResponse(message));
		this.onMessage = onMessage;
		this.taskInfos = new Map();
		this.sharedBuffer = new Int32Array(new SharedArrayBuffer(kFieldCount * Int32Array.BYTES_PER_ELEMENT));
	}
	async destroy(timeout) {
		let resolve;
		let reject;
		const ret = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});
		if (this.teardown && this.filename) {
			const { teardown, filename } = this;
			await new Promise((resolve$1, reject$1) => {
				this.postTask(new TaskInfo({}, [], filename, teardown, (error, result) => error ? reject$1(error) : resolve$1(result), null, 1, void 0));
			});
		}
		const timer = timeout ? setTimeout(() => reject(new Error("Failed to terminate worker")), timeout) : null;
		this.worker.terminate().then(() => {
			if (timer !== null) clearTimeout(timer);
			this.port.close();
			this.clearIdleTimeout();
			for (const taskInfo of this.taskInfos.values()) taskInfo.done(Errors.ThreadTermination());
			this.taskInfos.clear();
			resolve();
		});
		return ret;
	}
	clearIdleTimeout() {
		if (this.idleTimeout !== null) {
			clearTimeout(this.idleTimeout);
			this.idleTimeout = null;
		}
	}
	ref() {
		this.port.ref();
		return this;
	}
	unref() {
		this.port.unref();
		return this;
	}
	_handleResponse(message) {
		this.usedMemory = message.usedMemory;
		this.onMessage(message);
		if (this.taskInfos.size === 0) this.unref();
	}
	postTask(taskInfo) {
		assert(!this.taskInfos.has(taskInfo.taskId));
		const message = {
			task: taskInfo.releaseTask(),
			taskId: taskInfo.taskId,
			filename: taskInfo.filename,
			name: taskInfo.name
		};
		try {
			if (taskInfo.channel) this.worker.setChannel?.(taskInfo.channel);
			this.port.postMessage(message, taskInfo.transferList);
		} catch (err) {
			taskInfo.done(err);
			return;
		}
		taskInfo.workerInfo = this;
		this.taskInfos.set(taskInfo.taskId, taskInfo);
		this.ref();
		this.clearIdleTimeout();
		Atomics.add(this.sharedBuffer, kRequestCountField, 1);
		Atomics.notify(this.sharedBuffer, kRequestCountField, 1);
	}
	processPendingMessages() {
		const actualResponseCount = Atomics.load(this.sharedBuffer, kResponseCountField);
		if (actualResponseCount !== this.lastSeenResponseCount) {
			this.lastSeenResponseCount = actualResponseCount;
			let entry;
			while ((entry = receiveMessageOnPort(this.port)) !== void 0) this._handleResponse(entry.message);
		}
	}
	isRunningAbortableTask() {
		if (this.taskInfos.size !== 1) return false;
		const [first] = this.taskInfos;
		const [, task] = first || [];
		return task?.abortSignal !== null;
	}
	currentUsage() {
		if (this.isRunningAbortableTask()) return Infinity;
		return this.taskInfos.size;
	}
};
var ThreadPool = class {
	skipQueue = [];
	completed = 0;
	start = performance.now();
	inProcessPendingMessages = false;
	startingUp = false;
	workerFailsDuringBootstrap = false;
	constructor(publicInterface, options) {
		this.publicInterface = publicInterface;
		this.taskQueue = options.taskQueue || new ArrayTaskQueue();
		const filename = options.filename ? maybeFileURLToPath(options.filename) : null;
		this.options = {
			...kDefaultOptions,
			...options,
			filename,
			maxQueue: 0
		};
		if (options.maxThreads !== void 0 && this.options.minThreads >= options.maxThreads) this.options.minThreads = options.maxThreads;
		if (options.minThreads !== void 0 && this.options.maxThreads <= options.minThreads) this.options.maxThreads = options.minThreads;
		if (options.maxQueue === "auto") this.options.maxQueue = this.options.maxThreads ** 2;
		else this.options.maxQueue = options.maxQueue ?? kDefaultOptions.maxQueue;
		this.workerIds = new Map(new Array(this.options.maxThreads).fill(0).map((_, i) => [i + 1, true]));
		this.workers = new AsynchronouslyCreatedResourcePool(this.options.concurrentTasksPerWorker);
		this.workers.onAvailable((w) => this._onWorkerAvailable(w));
		this.startingUp = true;
		this._ensureMinimumWorkers();
		this.startingUp = false;
	}
	_ensureEnoughWorkersForTaskQueue() {
		while (this.workers.size < this.taskQueue.size && this.workers.size < this.options.maxThreads) this._addNewWorker();
	}
	_ensureMaximumWorkers() {
		while (this.workers.size < this.options.maxThreads) this._addNewWorker();
	}
	_ensureMinimumWorkers() {
		while (this.workers.size < this.options.minThreads) this._addNewWorker();
	}
	_addNewWorker() {
		const workerIds = this.workerIds;
		let workerId;
		workerIds.forEach((isIdAvailable, _workerId$1) => {
			if (isIdAvailable && !workerId) {
				workerId = _workerId$1;
				workerIds.set(_workerId$1, false);
			}
		});
		const tinypoolPrivateData = { workerId };
		const worker = this.options.runtime === "child_process" ? new ProcessWorker() : new ThreadWorker();
		worker.initialize({
			env: this.options.env,
			argv: this.options.argv,
			execArgv: this.options.execArgv,
			resourceLimits: this.options.resourceLimits,
			workerData: [tinypoolPrivateData, this.options.workerData],
			trackUnmanagedFds: this.options.trackUnmanagedFds
		});
		const onMessage = (message$1) => {
			const { taskId, result } = message$1;
			const taskInfo = workerInfo.taskInfos.get(taskId);
			workerInfo.taskInfos.delete(taskId);
			if (!this.shouldRecycleWorker(taskInfo)) this.workers.maybeAvailable(workerInfo);
			/* istanbul ignore if */
			if (taskInfo === void 0) {
				const err = new Error(`Unexpected message from Worker: ${inspect(message$1)}`);
				this.publicInterface.emit("error", err);
			} else taskInfo.done(message$1.error, result);
			this._processPendingMessages();
		};
		const { port1, port2 } = new MessageChannel();
		const workerInfo = new WorkerInfo(worker, port1, workerId, () => workerIds.set(workerId, true), onMessage, this.options.filename, this.options.teardown);
		if (this.startingUp) workerInfo.markAsReady();
		const message = {
			filename: this.options.filename,
			name: this.options.name,
			port: port2,
			sharedBuffer: workerInfo.sharedBuffer,
			useAtomics: this.options.useAtomics
		};
		worker.postMessage(message, [port2]);
		worker.on("message", (message$1) => {
			if (message$1.ready === true) {
				port1.start();
				if (workerInfo.currentUsage() === 0) workerInfo.unref();
				if (!workerInfo.isReady()) workerInfo.markAsReady();
				return;
			}
			worker.emit("error", new Error(`Unexpected message on Worker: ${inspect(message$1)}`));
		});
		worker.on("error", (err) => {
			worker.ref = () => {};
			const taskInfos = [...workerInfo.taskInfos.values()];
			workerInfo.taskInfos.clear();
			this._removeWorker(workerInfo);
			if (workerInfo.isReady() && !this.workerFailsDuringBootstrap) this._ensureMinimumWorkers();
			else this.workerFailsDuringBootstrap = true;
			if (taskInfos.length > 0) for (const taskInfo of taskInfos) taskInfo.done(err, null);
			else this.publicInterface.emit("error", err);
		});
		worker.unref();
		port1.on("close", () => {
			worker.ref();
		});
		this.workers.add(workerInfo);
	}
	_processPendingMessages() {
		if (this.inProcessPendingMessages || !this.options.useAtomics) return;
		this.inProcessPendingMessages = true;
		try {
			for (const workerInfo of this.workers) workerInfo.processPendingMessages();
		} finally {
			this.inProcessPendingMessages = false;
		}
	}
	_removeWorker(workerInfo) {
		workerInfo.freeWorkerId();
		this.workers.delete(workerInfo);
		return workerInfo.destroy(this.options.terminateTimeout);
	}
	_onWorkerAvailable(workerInfo) {
		while ((this.taskQueue.size > 0 || this.skipQueue.length > 0) && workerInfo.currentUsage() < this.options.concurrentTasksPerWorker) {
			const taskInfo = this.skipQueue.shift() || this.taskQueue.shift();
			if (taskInfo.abortSignal && workerInfo.taskInfos.size > 0) {
				this.skipQueue.push(taskInfo);
				break;
			}
			const now = performance.now();
			taskInfo.started = now;
			workerInfo.postTask(taskInfo);
			this._maybeDrain();
			return;
		}
		if (workerInfo.taskInfos.size === 0 && this.workers.size > this.options.minThreads) workerInfo.idleTimeout = setTimeout(() => {
			assert.strictEqual(workerInfo.taskInfos.size, 0);
			if (this.workers.size > this.options.minThreads) this._removeWorker(workerInfo);
		}, this.options.idleTimeout).unref();
	}
	runTask(task, options) {
		let { filename, name } = options;
		const { transferList = [], signal = null, channel } = options;
		if (filename == null) filename = this.options.filename;
		if (name == null) name = this.options.name;
		if (typeof filename !== "string") return Promise.reject(Errors.FilenameNotProvided());
		filename = maybeFileURLToPath(filename);
		let resolve;
		let reject;
		const ret = new Promise((res, rej) => {
			resolve = res;
			reject = rej;
		});
		const taskInfo = new TaskInfo(task, transferList, filename, name, (err, result) => {
			this.completed++;
			if (err !== null) reject(err);
			if (this.shouldRecycleWorker(taskInfo)) this._p  H;Ê•ÂH‹@ ÿÔ‰! L‰­¨  H‹   H…Ét!H‹H•È   H;Ê•ÂH‹@ ÿ§‰! L‰­   H‹M¨H…ÉtH‹HT$pH;Ê•ÂH‹@ ÿ‰! L‰m¨HĞ  èÛÇşÿH(  èÏÇşÿH‹P  H…Ét!H‹H•  H;Ê•ÂH‹@ ÿ=‰! L‰­P  H‹MèH…ÉtH‹HU°H;Ê•ÂH‹@ ÿ‰! L‰mèH‹   H…Ét!H‹H•h  H;Ê•ÂH‹@ ÿìˆ! L‰­   H‹M(H…ÉtH‹HUğH;Ê•ÂH‹@ ÿÅˆ! L‰m(H‹  H…Ét!H‹H•Ğ  H;Ê•ÂH‹@ ÿ›ˆ! L‰­  H‹ğ  H…Ét!H‹H•¸  H;Ê•ÂH‹@ ÿnˆ! L‰­ğ  H‹MhH…ÉtH‹HU0H;Ê•ÂH‹@ ÿGˆ! L‰mhH€  è£ÆşÿHx  èûÆşÿfE‰l$º   fA‰T$IL$è˜İ I‹ÄH‹   H3ÌèÆé H‹œ$€  HÄ0  A_A^A]A\_^]ÃH‰\$WHƒì HYH»   H‹O8H…ÉtH‹H;Ï•ÂH‹@ ÿ§‡! Hƒg8 H‹ËH‹\$0HƒÄ _ép  ÌH‰\$WHƒì HYH»   H‹O8H…ÉtH‹H;Ï•ÂH‹@ ÿ[‡! Hƒg8 H‹ËH‹\$0HƒÄ _é$  ÌH‰\$WHƒì HYH»   H‹O8H…ÉtH‹H;Ï•ÂH‹@ ÿ‡! Hƒg8 H‹ËH‹\$0HƒÄ _éĞ   ÌL‹ÜI‰[I‰sI‰KWHƒì H‹ñH‹H‰HyI‰{HZH‹ÓH‹Ïè ÅÿÿH¸  H“¸  è9ûÿH‹ƒ  H‰‡  H‹ƒ  H‰‡  H   H“   èÚÃşÿH‹ƒ°  H‰‡°  H¸  H“¸  èéûÿH  H“  @ fff„     èÇûÿH‹ÆH‹\$8H‹t$@HƒÄ _ÃH‰\$WHƒì H¹È  H‹ÙH‹O8H…ÉtH‹H;Ï•ÂH‹@ ÿğ…! Hƒg8 H‹   èKÄşÿH»È  H‹O8H…ÉtH‹H;Ï•ÂH‹@ ÿ¼…! Hƒg8 H‹   èÄşÿHKH‹\$0HƒÄ _éhÄşÿÌH‰\$WHƒì H‹ÙHÁ   èçÃşÿH»È  H‹O8H…ÉtH‹H;Ï•ÂH‹@ ÿX…! Hƒg8 H‹   è³ÃşÿHKH‹\$0HƒÄ _éÄşÿÌH‰\$H‰t$UWAVH¬$ şÿÿHìà  H‹4o/ H3ÄH‰…Ğ  H‹òH‹ÙH‰T$ H˜\" H‰EH‰MHEH‰EH¿r˜  ‰}ÀHEÈH‰D$ E3öL‰u HUÈHMH‹a\" ÿ³„! H‰E D‹ÇHUÀH°   èdÄúÿH‹øH¢" H‰D$0H‰\$8HD$0H‰D$h»¢˜  ‰\$pHD$xH‰D$ L‰u°HT$xHL$0H‹f" ÿP„! H‰E°D‹ÃHT$pHMPèÄúÿH‹ØÇ…  x˜  H…  H‰D$ H‹×H  è§ûÿH‹ÓHp  è˜ûÿÇv˜  H‹…  H‰FH^H‰\$ H•  H‹ËèoûÿHKXH•p  è_ûÿH  èßtÿÿH‹˜   H…ÉtH‹HU`H;Ê•ÂH‹@ ÿœƒ! L‰µ˜   H‹M°H…ÉtH‹HT$xH;Ê•ÂH‹@ ÿtƒ! L‰u°H‹L$hH…ÉtH‹HT$0H;Ê•ÂH‹@ ÿNƒ! L‰t$hH‹ø   H…Ét!H‹H•À   H;Ê•ÂH‹@ ÿ#ƒ! L‰µø   H‹M H…ÉtH‹HUÈH;Ê•ÂH‹@ ÿü‚! L‰u H‹MHH…ÉtH‹HUH;Ê•ÂH‹@ ÿØ‚! fD‰v¸   f‰F¸   f‰Flf‰Ftf‰Ff‰FH‹ÆH‹Ğ  H3Ìèkä Lœ$à  I‹[ I‹s0I‹ãA^_]ÃHƒÁéŸsÿÿH‹ÄH‰XH‰pH‰x UAVAWH¨ÈşÿÿHì   H‹{l/ H3ÄH‰…  H‹òH‹ÙH‰T$ H/T" H‰EH‰MHEH‰EH¿r˜  ‰}ÀHEÈH‰D$ E3ÿL‰} HUÈHMH‹øS" ÿú! H‰E D‹ÇHUÀH°   è«ÁúÿH‹øHW" H‰D$0H‰\$8HD$0H‰D$hA¾ª˜  D‰t$pHD$xH‰D$ L‰}°HT$xHL$0H‹ÛV" ÿ•! H‰E°E‹ÆHT$pHMPèHÁúÿH‹ØD‰6LvL‰t$ H‹×I‹ÎèúûÿINXH‹ÓèîûÿH‹˜   H…ÉtH‹HU`H;Ê•ÂH‹@ ÿ7! L‰½˜   H‹M°H…ÉtH‹HT$xH;Ê•ÂH‹@ ÿ! L‰}°H‹L$hH…ÉtH‹HT$0H;Ê•ÂH‹@ ÿé€! L‰|$hH‹ø   H…Ét!H‹H•À   H;Ê•ÂH‹@ ÿ¾€! L‰½ø   H‹M H…ÉtH‹HUÈH;Ê•ÂH‹@ ÿ—€! L‰} H‹MHH…ÉtH‹HUH;Ê•ÂH‹@ ÿs€! fD‰~¸   f‰Fdf‰FlfA‰FfA‰FH‹ÆH‹  H3Ìèâ Lœ$   I‹[ I‹s0I‹{8I‹ãA_A^]ÃH‰\$UVWATAUAVAWH¬$PÜÿÿ¸°$  èNğ H+àH‹$j/ H3ÄH‰… #  H‰T$`H‹ÙH‰T$ H•à  èñ©şÿH‰D$8H=z" H‰…p  H‰x  H…p  H‰…¨  ¿B˜  ‰½p  H…x  H‰D$ 3öH‰µ°  H•x  Hp  H‹ìy" ÿv! H‰…°  H@R" H‰…0  H‰8  H…0  H‰…h  ‰½   H…(  H‰D$ H‰µ`  H•(  H0  H‹öQ" ÿ! H‰…`  ‰½à
  L…p  H•   Hè
  èíD DGQH•à
  H€  è†W H‰D$0H•   H‹ËèŞ¨şÿH‰D$@H:u" H‰…ğ  H‰ø  H…ğ  H‰…(  ¿K˜  ‰½Ğ  H…Ø  H‰D$ H‰µ  H•Ø  Hğ  H‹ët" ÿe~! H‰…  D‹ÇH•Ğ  H€
  è¾úÿH‰D$HHü€" H‰…°  H‰¸  H…°  H‰…è  ¿U˜  ‰½€  H…ˆ  H‰D$ H‰µÀ  H•ˆ  H°  H‹­€" ÿç}! H‰…À  D‹ÇH•€  H 
  è’½úÿH‰D$PHvX" H‰…p  H‰x  H…p  H‰…¨  ‰½0  H…8  H‰D$ H‰µp  H•8  Hp  H‹,X" ÿn}! H‰…p  D‹ÇH•0  HÀ	  è½úÿH‰D$XH}b" H‰…0  H‰8  H…0  H‰…h  ‰½à  H…è  H‰D$ H‰µ   H•è  H0  H‹3b" ÿõ|! H‰…   D‹ÇH•à  H`	  è ¼úÿH‰D$ HT\" H‰…ğ   H‰ø   H…ğ   H‰…(  ‰½  H…˜  H‰D$(H‰µĞ  H•˜  Hğ   H‹
\" ÿ||! H‰…Ğ  D‹ÇH•  H 	  è'¼úÿL‹èHı‹" H‰…°   H‰¸   H…°   H‰…è   ¿G˜  ‰½@  H…H  H‰D$(H‰µ€  H•H  H°   H‹®‹" ÿ |! H‰…€  D‹ÇH•@  H   è«»úÿL‹àH„" H‰EpH‰]xHEpH‰…¨   ‰½ğ  H…ø  H‰D$(H‰µ0  H•ø  HMpH‹C„" ÿ•{! H‰…0  D‹ÇH•ğ  H@  è@»úÿL‹øH–H" H‰E0H‰]8HE0H‰Eh¿F˜  ‰½   H…¨  H‰D$(H‰µà  H•¨  HM0H‹VH" ÿ({! H‰…à  D‹ÇH•   Hà  èÓºúÿL‹ğHÙw" H‰EğH‰]øHEğH‰E(¿˜  ‰½P  H…X  H‰D$(H‰µ  H•X  HMğH‹™w" ÿ»z! H‰…  D‹ÇH•P  H€  èfºúÿH‹ğHN" H‰E°H‰]¸HE°H‰Eè‰½   H…  H‰D$(Hƒ¥@   H•  HM°H‹ØM" ÿRz! H‰…@  D‹ÇH•   H   èı¹úÿH‹øHŒ" H‰D$pH‰\$xHD$pH‰E¨»T˜  ‰°  H…¸  H‰D$(Hƒ¥ğ   H•¸  HL$pH‹¾‹" ÿày! H‰…ğ  D‹ÃH•°  HÀ  è‹¹úÿH‹ØÇ…0  Ÿ˜  H…8  H‰D$(H‹T$8H8  è¸ÿÿH‹L$0H‹H‰…ğ  H‹AH‰…ø  HQH   èÓ¶şÿH‹L$0H‹    H‰…  H‹T$@H˜  è3¸ÿÿH‹T$HHP  €    èÇûÿH‹T$PH¨  è¶ûÿH‹T$XH   è¥ûÿH‹T$ HX  è”ûÿI‹ÕH°  è…ûÿI‹ÔH  èvûÿI‹×H`  ègûÿI‹ÖH¸  èXûÿH‹ÖH  èIûÿH‹×Hh  è:ûÿH‹ÓHÀ  è+ûÿH‹\$`ÇO˜  HKH•0  è  H8  èx  H‹  3ÿH…Ét!H‹H•Ğ  H;Ê•ÂH‹@ ÿHx! H‰½  H‹ğ  H…Ét!H‹H•¸  H;Ê•ÂH‹@ ÿx! H‰½ğ  H‹M¨H…ÉtH‹HT$pH;Ê•ÂH‹@ ÿów! H‰}¨H‹h  H…Ét!H‹H•0  H;Ê•ÂH‹@ ÿÉw! H‰½h  H‹@  H…Ét!H‹H•  H;Ê•ÂH‹@ ÿœw! H‰½@  H‹MèH…ÉtH‹HU°H;Ê•ÂH‹@ ÿuw! H‰}èH‹È  H…Ét!H‹H•  H;Ê•ÂH‹@ ÿKw! H‰½È  H‹  H…Ét!H‹H•X  H;Ê•ÂH‹@ ÿw! H‰½  H‹M(H…ÉtH‹HUğH;Ê•ÂH‹@ ÿ÷v! H‰}(H‹(  H…Ét!H‹H•ğ  H;Ê•ÂH‹@ ÿÍv! H‰½(  H‹à  H…Ét!H‹H•¨  H;Ê•ÂH‹@ ÿ v! H‰½à  H‹MhH…ÉtH‹HU0H;Ê•ÂH‹@ ÿyv! H‰}hH‹ˆ  H…Ét!H‹H•P  H;Ê•ÂH‹@ ÿOv! H‰½ˆ  H‹0  H…Ét!H‹H•ø  H;Ê•ÂH‹@ ÿ"v! H‰½0  H‹¨   H…ÉtH‹HUpH;Ê•ÂH‹@ ÿøu! H‰½¨   H‹è  H…Ét!H‹H•°  H;Ê•ÂH‹@ ÿËu! H‰½è  H‹€  H…Ét!H‹H•H  H;Ê•ÂH‹@ ÿu! H‰½€  H‹è   H…Ét!H‹H•°   H;Ê•ÂH‹@ ÿqu! H‰½è   H‹H	  H…Ét!H‹H•	  H;Ê•ÂH‹@ ÿDu! H‰½H	  H‹Ğ  H…Ét!H‹H•˜  H;Ê•ÂH‹@ ÿu! H‰½Ğ  H‹(  H…Ét!H‹H•ğ   H;Ê•ÂH‹@ ÿêt! H‰½(  H‹¨	  H…Ét!H‹H•p	  H;Ê•ÂH‹@ ÿ½t! H‰½¨	  H‹   H…Ét!H‹H•è  H;Ê•ÂH‹@ ÿt! H‰½   H‹h  H…Ét!H‹H•0  H;Ê•ÂH‹@ ÿct! H‰½h  H‹
  H…Ét!H‹H•Ğ	  H;Ê•ÂH‹@ ÿ6t! H‰½
  H‹p  H…Ét!H‹H•8  H;Ê•ÂH‹@ ÿ	t! H‰½p  H‹¨  H…Ét!H‹H•p  H;Ê•ÂH‹@ ÿÜs! H‰½¨  H‹h
  H…Ét!H‹H•0
  H;Ê•ÂH‹@ ÿ¯s! H‰½h
  H‹À  H…Ét!H‹H•ˆ  H;Ê•ÂH‹@ ÿ‚s! H‰½À  H‹è  H…Ét!H‹H•°  H;Ê•ÂH‹@ ÿUs! H‰½è  H‹È
  H…Ét!H‹H•
  H;Ê•ÂH‹@ ÿ(s! H‰½È
  H‹  H…Ét!H‹H•Ø  H;Ê•ÂH‹@ ÿûr! H‰½  H‹(  H…Ét!H‹H•ğ  H;Ê•ÂH‹@ ÿÎr! H‰½(  H@  è'±şÿH8  è±şÿH  è±şÿHè
  è±şÿ@ fff„     H‹`  H…Ét!H‹H•(  H;Ê•ÂH‹@ ÿbr! H‰½`  H‹h  H…Ét!H‹H•0  H;Ê•ÂH‹@ ÿ5r! H‰½h  H‹°  H…Ét!H‹H•x  H;Ê•ÂH‹@ ÿr! H‰½°  H‹¨  H…Ét!H‹H•p  H;Ê•ÂH‹@ ÿÛq! H‰½¨  H #  è4°ş