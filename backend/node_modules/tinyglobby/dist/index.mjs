import nativeFs from "fs";
import path, { posix } from "path";
import { fileURLToPath } from "url";
import { fdir } from "fdir";
import picomatch from "picomatch";

//#region src/utils.ts
const isReadonlyArray = Array.isArray;
const isWin = process.platform === "win32";
const ONLY_PARENT_DIRECTORIES = /^(\/?\.\.)+$/;
function getPartialMatcher(patterns, options = {}) {
	const patternsCount = patterns.length;
	const patternsParts = Array(patternsCount);
	const matchers = Array(patternsCount);
	const globstarEnabled = !options.noglobstar;
	for (let i = 0; i < patternsCount; i++) {
		const parts = splitPattern(patterns[i]);
		patternsParts[i] = parts;
		const partsCount = parts.length;
		const partMatchers = Array(partsCount);
		for (let j = 0; j < partsCount; j++) partMatchers[j] = picomatch(parts[j], options);
		matchers[i] = partMatchers;
	}
	return (input) => {
		const inputParts = input.split("/");
		if (inputParts[0] === ".." && ONLY_PARENT_DIRECTORIES.test(input)) return true;
		for (let i = 0; i < patterns.length; i++) {
			const patternParts = patternsParts[i];
			const matcher = matchers[i];
			const inputPatternCount = inputParts.length;
			const minParts = Math.min(inputPatternCount, patternParts.length);
			let j = 0;
			while (j < minParts) {
				const part = patternParts[j];
				if (part.includes("/")) return true;
				const match = matcher[j](inputParts[j]);
				if (!match) break;
				if (globstarEnabled && part === "**") return true;
				j++;
			}
			if (j === inputPatternCount) return true;
		}
		return false;
	};
}
/* node:coverage ignore next 2 */
const WIN32_ROOT_DIR = /^[A-Z]:\/$/i;
const isRoot = isWin ? (p) => WIN32_ROOT_DIR.test(p) : (p) => p === "/";
function buildFormat(cwd, root, absolute) {
	if (cwd === root || root.startsWith(`${cwd}/`)) {
		if (absolute) {
			const start = isRoot(cwd) ? cwd.length : cwd.length + 1;
			return (p, isDir) => p.slice(start, isDir ? -1 : void 0) || ".";
		}
		const prefix = root.slice(cwd.length + 1);
		if (prefix) return (p, isDir) => {
			if (p === ".") return prefix;
			const result = `${prefix}/${p}`;
			return isDir ? result.slice(0, -1) : result;
		};
		return (p, isDir) => isDir && p !== "." ? p.slice(0, -1) : p;
	}
	if (absolute) return (p) => posix.relative(cwd, p) || ".";
	return (p) => posix.relative(cwd, `${root}/${p}`) || ".";
}
function buildRelative(cwd, root) {
	if (root.startsWith(`${cwd}/`)) {
		const prefix = root.slice(cwd.length + 1);
		return (p) => `${prefix}/${p}`;
	}
	return (p) => {
		const result = posix.relative(cwd, `${root}/${p}`);
		if (p.endsWith("/") && result !== "") return `${result}/`;
		return result || ".";
	};
}
const splitPatternOptions = { parts: true };
function splitPattern(path$1) {
	var _result$parts;
	const result = picomatch.scan(path$1, splitPatternOptions);
	return ((_result$parts = result.parts) === null || _result$parts === void 0 ? void 0 : _result$parts.length) ? result.parts : [path$1];
}
const ESCAPED_WIN32_BACKSLASHES = /\\(?![()[\]{}!+@])/g;
function convertPosixPathToPattern(path$1) {
	return escapePosixPath(path$1);
}
function convertWin32PathToPattern(path$1) {
	return escapeWin32Path(path$1).replace(ESCAPED_WIN32_BACKSLASHES, "/");
}
/**
* Converts a path to a pattern depending on the platform.
* Identical to {@link escapePath} on POSIX systems.
* @see {@link https://superchupu.dev/tinyglobby/documentation#convertPathToPattern}
*/
/* node:coverage ignore next 3 */
const convertPathToPattern = isWin ? convertWin32PathToPattern : convertPosixPathToPattern;
const POSIX_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}*?|]|^!|[!+@](?=\()|\\(?![()[\]{}!*+?@|]))/g;
const WIN32_UNESCAPED_GLOB_SYMBOLS = /(?<!\\)([()[\]{}]|^!|[!+@](?=\())/g;
const escapePosixPath = (path$1) => path$1.replace(POSIX_UNESCAPED_GLOB_SYMBOLS, "\\$&");
const escapeWin32Path = (path$1) => path$1.replace(WIN32_UNESCAPED_GLOB_SYMBOLS, "\\$&");
/**
* Escapes a path's special characters depending on the platform.
* @see {@link https://superchupu.dev/tinyglobby/documentation#escapePath}
*/
/* node:coverage ignore next */
const escapePath = isWin ? escapeWin32Path : escapePosixPath;
/**
* Checks if a pattern has dynamic parts.
*
* Has a few minor differences with [`fast-glob`](https://github.com/mrmlnc/fast-glob) for better accuracy:
*
* - Doesn't necessarily return `false` on patterns that include `\`.
* - Returns `true` if the pattern includes parentheses, regardless of them representing one single pattern or not.
* - Returns `true` for unfinished glob extensions i.e. `(h`, `+(h`.
* - Returns `true` for unfinished brace expansions as long as they include `,` or `..`.
*
* @see {@link https://superchupu.dev/tinyglobby/documentation#isDynamicPattern}
*/
function isDynamicPattern(pattern, options) {
	if ((options === null || options === void 0 ? void 0 : options.caseSensitiveMatch) === false) return true;
	const scan = picomatch.scan(pattern);
	return scan.isGlob || scan.negated;
}
function log(...tasks) {
	console.log(`[tinyglobby ${(/* @__PURE__ */ new Date()).toLocaleTimeString("es")}]`, ...tasks);
}

//#endregion
//#region src/index.ts
const PARENT_DIRECTORY = /^(\/?\.\.)+/;
const ESCAPING_BACKSLASHES = /\\(?=[()[\]{}!*+?@|])/g;
const BACKSLASHES = /\\/g;
function normalizePattern(pattern, expandDirectories, cwd, props, isIgnore) {
	let result = pattern;
	if (pattern.endsWith("/")) result = pattern.slice(0, -1);
	if (!result.endsWith("*") && expandDirectories) result += "/**";
	const escapedCwd = escapePath(cwd);
	if (path.isAbsolute(result.replace(ESCAPING_BACKSLASHES, ""))) result = posix.relative(escapedCwd, result);
	else result = posix.normalize(result);
	const parentDirectoryMatch = PARENT_DIRECTORY.exec(result);
	const parts = splitPattern(result);
	if (parentDirectoryMatch === null || parentDirectoryMatch === void 0 ? void 0 : parentDirectoryMatch[0]) {
		const n = (parentDirectoryMatch[0].length + 1) / 3;
		let i = 0;
		const cwdParts = escapedCwd.split("/");
		while (i < n && parts[i + n] === cwdParts[cwdParts.length + i - n]) {
			result = result.slice(0, (n - i - 1) * 3) + result.slice((n - i) * 3 + parts[i + n].length + 1) || ".";
			i++;
		}
		const potentialRoot = posix.join(cwd, parentDirectoryMatch[0].slice(i * 3));
		if (!potentialRoot.startsWith(".") && props.root.length > potentialRoot.length) {
			props.root = potentialRoot;
			props.depthOffset = -n + i;
		}
	}
	if (!isIgnore && props.depthOffset >= 0) {
		var _props$commonPath;
		(_props$commonPath = props.commonPath) !== null && _props$commonPath !== void 0 || (props.commonPath = parts);
		const newCommonPath = [];
		const length = Math.min(props.commonPath.length, parts.length);
		for (let i = 0; i < length; i++) {
			const part = parts[i];
			if (part === "**" && !parts[i + 1]) {
				newCommonPath.pop();
				break;
			}
			if (part !== props.commonPath[i] || isDynamicPattern(part) || i === parts.length - 1) break;
			newCommonPath.push(part);
		}
		props.depthOffset = newCommonPath.length;
		props.commonPath = newCommonPath;
		props.root = newCommonPath.length > 0 ? posix.join(cwd, ...newCommonPath) : cwd;
	}
	return result;
}
function processPatterns({ patterns = ["**/*"], ignore = [], expandDirectories = true }, cwd, props) {
	if (typeof patterns === "string") patterns = [patterns];
	if (typeof ignore === "string") ignore = [ignore];
	const matchPatterns = [];
	const ignorePatterns = [];
	for (const pattern of ignore) {
		if (!pattern) continue;
		if (pattern[0] !== "!" || pattern[1] === "(") ignorePatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, true));
	}
	for (const pattern of patterns) {
		if (!pattern) continue;
		if (pattern[0] !== "!" || pattern[1] === "(") matchPatterns.push(normalizePattern(pattern, expandDirectories, cwd, props, false));
		else if (pattern[1] !== "!" || pattern[2] === "(") ignorePatterns.push(normalizePattern(pattern.slice(1), expandDirectories, cwd, props, true));
	}
	return {
		match: matchPatterns,
		ignore: ignorePatterns
	};
}
function formatPaths(paths, relative) {
	for (let i = paths.length - 1; i >= 0; i--) {
		const path$1 = paths[i];
		paths[i] = relative(path$1);
	}
	return paths;
}
function normalizeCwd(cwd) {
	if (!cwd) returtAƒnuI‹‹ÖI‹ÎH‹ ÿÎ	 H‹…è   H‹L‹Ğ   IƒÁH‹…ø   ‹ ‰EˆH…   H‰D$ LEˆHU€HMhèØBÕÿH‹ĞH‹Ëè¥¨ H‹]pH…Ût9ƒÈÿğÁCƒøu,H‹H‹ËH‹ ÿ`	 ƒÈÿğÁCƒøuH‹H‹ËH‹@ÿC	 Š\$PL‹u€DîHşH;|$xŒuıÿÿL‹­Ø   WÀóD$`„Û…  M…ö…  D9t$p„ü   DŠÎLE˜I‹ÔHL$Xè> ×ÿH‹L$XH…É„Ÿ   I‹$H‹H‹€0  ÿÆ L90t5H‹\$XH‹H‹¸@  I‹$H‹H‹‚0  ÿ E3ÀH‹ĞH‹ËH‹ÇÿŒ I‹$H‹H‹€8  ÿx Hƒ8 t2H‹\$XH‹H‹¸P  I‹$H‹H‹‚8  ÿO H‹ĞH‹ËH‹Çÿ@ H‹L$XI‹GH‹ÙH…ÉtqH‹L$XH‰D$hH‰\$`H…Ét/ƒiu)H‹‹ÖH‹ ÿ ëI‹GH‰D$hI‹H…ÛtsH‰\$`M…ö@•ÇM…öu@D!t$XH‹…   H‰D$(LL$XL‹…è   HT$`H‹ø   èëÍÿÿ‹D$XH‹ğ   	H‹\$`H‹Ã@„ÿIEÆI‰E H…ÀtpH…ÛtƒkuH‹‹ÖH‹ËH‹ ÿk H‹MèH…ÉtƒiuH‹‹ÖH‹ ÿM HM˜èÏÔÿM…ötAƒnuI‹I‹Î‹ÖH‹ ÿ& I‹H…É„  ƒi…û  H‹‹ÖH‹ ÿ éè  ‹ÁÁè@"Æ„  D‰D$XL‰E°L‰E¸L‰EÀL‰} H…   H‰E(L‰u0H‰]8HD$XH‰E@H‹…ø   H‰EHH…  H‰EPH…  H‰EXH‹ğ   H‰]`H‹R8HƒÂ HƒL$ ÿLE HM°è*-  ‹D$X	…Àt5I‹H‹X¹p   èWi H‰D$`L‹ËLE°º·   H‹Èè¦í×ÿ¿
   H‹ÈëI‹H‹D$`I‰M H…Étqş@öÇt H…ÀtƒhuH‹L‹‹ÖH‹ÈI‹Àÿü HM°è~ÔÿéÈşÿÿÁé@"Î„Æ  H‹Z8H‹[H…ÛtsH‰]°H…ÛtsL%¶- L‰e¸H…ÛtƒkuH‹‹ÖH‹ËH‹ ÿ E3ÀH‹…   I‹H…ÉtqD‰E H‰MH…ÉtqH‰E@ˆuH…ÉtƒiuH‹‹ÖH‹ ÿX E3ÀD‰D$XH‹…  H‹  H‰\$`H…ÛtsL‰d$hH‰D$@H‰L$8HE H‰D$0H‹…ø   H‰D$(HD$XH‰D$ L‹è   LD$`HT$xI‹ÎèÂ÷ÿÿ‹L$XH‹…ğ   	…Ét+¹p   èÏg H‰D$`LD$xº±   H‹Èè0ë×ÿ¿   H‹ÈëI‹H‹D$`I‰M H…Étqş@öÇt H…ÀtƒhuH‹L‹‹ÖH‹ÈI‹Àÿw H‹L$xH…ÉtƒiuH‹‹ÖH‹ ÿX H‹MH…ÉtƒiuH‹‹ÖH‹ ÿ: H…Û„ıÿÿƒk…ıÿÿH‹H‹ËéêüÿÿI‰U M‰I‹ÅHÄˆ  A_A^A]A\_^[]ÃÇD$X €H" HL$Xè°q ÌH‰\$H‰T$UVWHl$¹Hì   H‹úH‹Ùƒe I‹ H‰¾   H…ÀtpH›- H‰B‰uH‹AH‹H‹	H‹	H…Étqƒe H‰M'H…ÉtqH‰U/@ˆu7H…ÉtƒiuH‹‹ÖH‹ ÿV H‹C8H‹H‹C0H‹L‹C(L‹S H‹H‰EH…ÀtpH‹GH‰EH‰L$@H‰T$8HEH‰D$0L‰D$(L‰T$ L‹KLEHUgH‹KèÊõÿÿH‹MgH…ÉtƒiuH‹‹ÖH‹ ÿÙ L‹C@H‹C ‹A	H‹M'H…ÉtƒiuH‹‹ÖH‹ ÿ¯ H‹ÇH‹œ$À   HÄ   _^]ÃH‰\$H‰L$UVWATAUAVAWH‹ìHƒì`M‹ñM‹øL‹êL‹E‹SA‹ÂÁè$uA‹ÂÁè$uAÁêA€â„u  ƒeH I‹XH…ÛtğÿCI‹XL‹I‹0H‰uğH‰]øL‰]àM…ÛtAÿCH‹BH‰EèHÁ^  L‹ehI‹D$ I‹T$H‰D$0H‰T$(Hƒd$  LMHLEğHUàèL:üÿƒÏÿ„À„    ‹EH…À„	  A	H‹H‹H0I‹$H‹H…Àtÿ@H‹
H‰H…ÉtyuH‹º   H‹ ÿŒ I‹D$H…ÛtğÿCH‹uğH‰0H‹pH‰XH…öt5‹ÇğÁFÇu*H‹H‹ÎH‹ ÿP ‹ÇğÁFÇuH‹H‹ÎH‹@ÿ5 AƒH‹MàH…ÉtyuH‹º   H‹ ÿ H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿò  ‹ÇğÁCÇuH‹H‹ËH‹@ÿ×  °H‹œ$°   HƒÄ`A_A^A]A\_^]ÃƒÏÿH‹MàH…ÉtyuH‹WH‹ ÿ  H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿ}  ‹ÇğÁCÇuH‹H‹ËH‹Bÿb  L‰d$(M‹ÎM‹ÇI‹ÕH‹M@èû.  éoÿÿÿÌH‰\$H‰L$UVWATAUAVAWH‹ìHƒì`M‹ñM‹øL‹êL‹E‹SA‹ÂÁè$uA‹ÂÁè$uAÁêA€â„u  ƒeH I‹XH…ÛtğÿCI‹XL‹I‹0H‰uğH‰]øL‰]àM…ÛtAÿCH‹BH‰EèHÁ¨i  L‹ehI‹D$ I‹T$H‰D$0H‰T$(Hƒd$  LMHLEğHUàèà)üÿƒÏÿ„À„    ‹EH…À„	  A	H‹H‹H0I‹$H‹H…Àtÿ@H‹
H‰H…ÉtyuH‹º   H‹ ÿ8ÿ I‹D$H…ÛtğÿCH‹uğH‰0H‹pH‰XH…öt5‹ÇğÁFÇu*H‹H‹ÎH‹ ÿüş ‹ÇğÁFÇuH‹H‹ÎH‹@ÿáş AƒH‹MàH…ÉtyuH‹º   H‹ ÿ¾ş H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿş ‹ÇğÁCÇuH‹H‹ËH‹@ÿƒş °H‹œ$°   HƒÄ`A_A^A]A\_^]ÃƒÏÿH‹MàH…ÉtyuH‹WH‹ ÿIş H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿ)ş ‹ÇğÁCÇuH‹H‹ËH‹Bÿş L‰d$(M‹ÎM‹ÇI‹ÕH‹M@è/  éoÿÿÿÌH‰\$H‰t$UWATAVAWH‹ìHƒì`M‹ñL‹E‹SA‹ÂÁèA¼   A"ÄuA‹ÂÁèA"ÄuAÁêE"Ô„m  ƒe8 I‹XH…ÛtğDcI‹XL‹I‹0H‰uğH‰]øL‰]àM…ÛtEcH‹BH‰EèHƒÁL‹}XI‹G I‹WH‰D$0H‰T$(Hƒd$  LM8LEğHUàèB'  ƒÏÿ„À„   ‹E8…À„  A	H‹H‹H0I‹H‹H…ÀtD`H‹
H‰H…ÉtyuH‹A‹ÔH‹ ÿìü I‹GH…Ût	ğDcH‹uğH‰0H‹pH‰XH…öt5‹ÇğÁFÇu*H‹H‹ÎH‹ ÿ°ü ‹ÇğÁFÇuH‹H‹ÎH‹@ÿ•ü E	&H‹MàH…ÉtyuH‹A‹ÔH‹ ÿuü H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿUü ‹ÏğÁKÏuH‹H‹AH‹Ëÿ:ü AŠÄL\$`I‹[0I‹s@I‹ãA_A^A\_]ÃƒÏÿH‹MàH…ÉtyuH‹A‹ÔH‹ ÿşû H…Ût¾‹ÇğÁCÇu³H‹H‹ËH‹ ÿŞû ‹ÇğÁCÇu™H‹H‹@ë‡ÌH‰\$H‰L$UVWATAUAVAWH‹ìHƒì`M‹ñM‹øL‹êL‹E‹SA‹ÂÁè$uA‹ÂÁè$uAÁêA€â„~  ƒeH I‹XH…ÛtğÿCI‹XL‹I‹0H‰uğH‰]øL‰]àM…ÛtAÿCH‹BH‰EèHÁø  L‹ehI‹D$ I‹T$LAH‰D$8H‰T$0Hƒd$( L‰D$ LMHLEğHUàèoÕÿƒÏÿ„À„    ‹EH…À„	  A	H‹H‹H0I‹$H‹H…Àtÿ@H‹
H‰H…ÉtyuH‹º   H‹ ÿ³ú I‹D$H…ÛtğÿCH‹uğH‰0H‹pH‰XH…öt5‹ÇğÁFÇu*H‹H‹ÎH‹ ÿwú ‹ÇğÁFÇuH‹H‹ÎH‹@ÿ\ú AƒH‹MàH…ÉtyuH‹º   H‹ ÿ9ú H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿú ‹ÇğÁCÇuH‹H‹ËH‹@ÿşù °H‹œ$°   HƒÄ`A_A^A]A\_^]ÃƒÏÿH‹MàH…ÉtyuH‹WH‹ ÿÄù H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿ¤ù ‹ÇğÁCÇuH‹H‹ËH‹Bÿ‰ù L‰d$(M‹ÎM‹ÇI‹ÕH‹M@èÖ,  éoÿÿÿÌH‰\$H‰L$UVWATAUAVAWH‹ìHƒì`M‹ñM‹øL‹êL‹E‹SA‹ÂÁè$uA‹ÂÁè$uAÁêA€â„u  ƒeH I‹XH…ÛtğÿCI‹XL‹I‹0H‰uğH‰]øL‰]àM…ÛtAÿCH‹BH‰EèHÁF  L‹ehI‹D$ I‹T$H‰D$0H‰T$(Hƒd$  LMHLEğHUàè 1üÿƒÏÿ„À„    ‹EH…À„	  A	H‹H‹H0I‹$H‹H…Àtÿ@H‹
H‰H…ÉtyuH‹º   H‹ ÿ`ø I‹D$H…ÛtğÿCH‹uğH‰0H‹pH‰XH…öt5‹ÇğÁFÇu*H‹H‹ÎH‹ ÿ$ø ‹ÇğÁFÇuH‹H‹ÎH‹@ÿ	ø AƒH‹MàH…ÉtyuH‹º   H‹ ÿæ÷ H…Ût5‹ÇğÁCÇu*H‹H‹ËH‹ ÿÆ÷ ‹ÇğÁCÇuH‹H‹ËH‹@ÿ«÷ °H‹œ$°   HƒÄ`A_A^A]