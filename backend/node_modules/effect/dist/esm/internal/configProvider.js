import * as Arr from "../Array.js";
import * as Context from "../Context.js";
import * as Either from "../Either.js";
import { dual, pipe } from "../Function.js";
import * as HashMap from "../HashMap.js";
import * as HashSet from "../HashSet.js";
import * as number from "../Number.js";
import * as Option from "../Option.js";
import { pipeArguments } from "../Pipeable.js";
import * as Predicate from "../Predicate.js";
import * as regexp from "../RegExp.js";
import * as configError from "./configError.js";
import * as pathPatch from "./configProvider/pathPatch.js";
import * as core from "./core.js";
import * as OpCodes from "./opCodes/config.js";
import * as StringUtils from "./string-utils.js";
const concat = (l, r) => [...l, ...r];
/** @internal */
const ConfigProviderSymbolKey = "effect/ConfigProvider";
/** @internal */
export const ConfigProviderTypeId = /*#__PURE__*/Symbol.for(ConfigProviderSymbolKey);
/** @internal */
export const configProviderTag = /*#__PURE__*/Context.GenericTag("effect/ConfigProvider");
/** @internal */
const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
/** @internal */
export const FlatConfigProviderTypeId = /*#__PURE__*/Symbol.for(FlatConfigProviderSymbolKey);
/** @internal */
export const make = options => ({
  [ConfigProviderTypeId]: ConfigProviderTypeId,
  pipe() {
    return pipeArguments(this, arguments);
  },
  ...options
});
/** @internal */
export const makeFlat = options => ({
  [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
  patch: options.patch,
  load: (path, config, split = true) => options.load(path, config, split),
  enumerateChildren: options.enumerateChildren
});
/** @internal */
export const fromFlat = flat => make({
  load: config => core.flatMap(fromFlatLoop(flat, Arr.empty(), config, false), chunk => Option.match(Arr.head(chunk), {
    onNone: () => core.fail(configError.MissingData(Arr.empty(), `Expected a single value having structure: ${config}`)),
    onSome: core.succeed
  })),
  flattened: flat
});
/** @internal */
export const fromEnv = options => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({}, {
    pathDelim: "_",
    seqDelim: ","
  }, options);
  const makePathString = path => pipe(path, Arr.join(pathDelim));
  const unmakePathString = pathString => pathString.split(pathDelim);
  const getEnv = () => typeof process !== "undefined" && "env" in process && typeof process.env === "object" ? process.env : {};
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const current = getEnv();
    const valueOpt = pathString in current ? Option.some(current[pathString]) : Option.none();
    return pipe(valueOpt, core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the process context`)), core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = path => core.sync(() => {
    const current = getEnv();
    const keys = Object.keys(current);
    const keyPaths = keys.map(value => unmakePathString(value.toUpperCase()));
    const filteredKeyPaths = keyPaths.filter(keyPath => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, Arr.unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));
    return HashSet.fromIterable(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: pathPatch.empty
  }));
};
/** @internal */
export const fromMap = (map, config) => {
  const {
    pathDelim,
    seqDelim
  } = Object.assign({
    seqDelim: ",",
    pathDelim: "."
  }, config);
  const makePathString = path => pipe(path, Arr.join(pathDelim));
  const unmakePathString = pathString => pathString.split(pathDelim);
  const mapWithIndexSplit = splitIndexInKeys(map, str => unmakePathString(str), makePathString);
  const load = (path, primitive, split = true) => {
    const pathString = makePathString(path);
    const valueOpt = mapWithIndexSplit.has(pathString) ? Option.some(mapWithIndexSplit.get(pathString)) : Option.none();
    return pipe(valueOpt, core.mapError(() => configError.MissingData(path, `Expected ${pathString} to exist in the provided map`)), core.flatMap(value => parsePrimitive(value, path, primitive, seqDelim, split)));
  };
  const enumerateChildren = path => core.sync(() => {
    const keyPaths = Arr.fromIterable(mapWithIndexSplit.keys()).map(unmakePathString);
    const filteredKeyPaths = keyPaths.filter(keyPath => {
      for (let i = 0; i < path.length; i++) {
        const pathComponent = pipe(path, Arr.unsafeGet(i));
        const currentElement = keyPath[i];
        if (currentElement === undefined || pathComponent !== currentElement) {
          return false;
        }
      }
      return true;
    }).flatMap(keyPath => keyPath.slice(path.length, path.length + 1));
    return HashSet.fromIterable(filteredKeyPaths);
  });
  return fromFlat(makeFlat({
    load,
    enumerateChildren,
    patch: pathPatch.empty
  }));
};
const extend = (leftDef, rightDef, left, right) => {
  const leftPad = Arr.unfold(left.length, index => index >= right.length ? Option.none() : Option.some([leftDef(index), index + 1]));
  const rightPad = Arr.unfold(right.length, index => index >= left.length ? Option.none() : Option.some([rightDef(index), index + 1]));
  const leftExtension = concat(left, leftPad);
  const rightExtension = concat(right, rightPad);
  return [leftExtension, rightExtension];
};
const appendConfigPath = (path, config) => {
  let op = config;
  if (op._tag === "Nested") {
    const out = path.slice();
    while (op._tag === "Nested") {
      out.push(op.name);
      op = op.config;
    }
    return out;
  }
  return path;
};
const fromFlatLoop = (flat, prefix, config, split) => {
  const op = config;
  switch (op._tag) {
    case OpCodes.OP_CONSTANT:
      {
        return core.succeed(Arr.of(op.value));
      }
    case OpCodes.OP_DESCRIBED:
      {
        return core.suspend(() => fromFlatLoop(flat, prefix, op.config, split));
      }
    case OpCodes.OP_FAIL:
      {
        return core.fail(configError.MissingData(prefix, op.message));
      }
    case OpCodes.OP_FALLBACK:
      {
        return pipe(core.suspend(() => fromFlatLoop(flat, prefix, op.first, split)), core.catchAll(error1 => {
          if (op.condition(error1)) {
            return pipe(fromFlatLoop(flat, prefix, op.second, split), core.catchAll(error2 => core.fail(configError.Or(error1, error2))));
          }
          return core.fail(error1);
        }));
      }
    case OpCodes.OP_LAZY:
      {
        return core.suspend(() => fromFlatLoop(flat, prefix, op.config(), split));
      }
    case OpCodes.OP_MAP_OR_FAIL:
      {
        return core.suspend(() => pipe(fromFlatLoop(flat, prefix, op.original, split), core.flatMap(core.forEachSequential(a => pipe(op.mapOrFail(a), core.mapError(configError.prefixed(appendConfigPath(prefix, op.original))))))));
      }
    case OpCodes.OP_NESTED:
      {
        return core.suspend(() => fromFlatLoop(flat, concat(prefix, Arr.of(op.name)), op.config, split));
      }
    case OpCodes.OP_PRIMITIVE:
      {
        return pipe(pathPatch.patch(prefix, flat.patch), core.flatMap(prefix => pipe(flat.load(prefix, op, split), core.flatMap(values => {
          if (values.length === 0) {
            const name = pipe(Arr.last(prefix), Option.getOrElse(() => "<n/a>"));
            return core.fail(configError.MissingData([], `Expected ${op.description} with name ${name}`));
          }
          return core.succeed(values);
        }))));
      }
    case OpCodes.OP_SEQUENCE:
      {
        return pipe(pathPatch.patch(prefix, flat.patch), core.flatMap(patchedPrefix => pipe(flat.enumerateChildren(patchedPrefix), core.flatMap(indicesFrom), core.flatMap(indices => {
          if (indices.length === 0) {
            return core.suspend(() => core.map(fromFlatLoop(flat, prefix, op.config, true), Arr.of));
          }
          return pipe(core.forEachSequential(indices, index => fromFlatLoop(flat, Arr.append(prefix, `[${index}]`), op.config, true)), core.map(chunkChunk => {
            const flattened = Arr.flatten(chunkChunk);
            if (flattened.length === 0) {
              return Arr.of(Arr.empty());
            }
            return Arr.of(flattened);
          }));
        }))));
      }
    case OpCodes.OP_HASHMAP:
      {
        return core.suspend(() => pipe(pathPatch.patch(prefix, flat.patch), core.flatMap(prefix => pipe(flat.enumerateChildren(prefix), core.flatMap(keys => {
          return pipe(keys, core.forEachSequential(key => fromFlatLoop(flat, concat(prefix, Arr.of(key)), op.valueConfig, split)), core.map(matrix => {
            if (matrix.length === 0) {
              return Arr.of(HashMap.empty());
            }
            return pipe(transpose(matrix), Arr.map(values => HashMap.fromIterable(Arr.zip(Arr.fromIterable(keys), values))));
          }));
        })))));
      }
    case OpCodes.OP_ZIP_WITH:
      {
        return core.suspend(() => pipe(fromFlatLoop(flat, prefix, op.left, split), core.either, core.flatMap(left => pipe(fromFlatLoop(flat, prefix, op.right, split), core.either, core.flatMap(right => {
          if (Either.isLeft(left) && Either.isLeft(right)) {
            return core.fail(configError.And(left.left, right.left));
          }
          if (Either.isLeft(left) && Either.isRight(right)) {
            return core.fail(left.left);
          }
          if (Either.isRight(left) && Either.isLeft(right)) {
            return core.fail(right.left);
          }
          if (Either.isRight(left) && Either.isRight(right)) {
            const path = pipe(prefix, Arr.join("."));
            const fail = fromFlatLoopFail(prefix, path);
            const [lefts, rights] = extend(fail, fail, pipe(left.right, Arr.map(Either.right)), pipe(right.right, Arr.map(Either.right)));
            return pipe(lefts, Arr.zip(rights), core.forEachSequential(([left, right]) => pipe(core.zip(left, right), core.map(([left, right]) => op.zip(left, right)))));
          }
          throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
        })))));
      }
  }
};
const fromFlatLoopFail = (prefix, path) => index => Either.left(configError.MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
/** @internal */
export const mapInputPath = /*#__PURE__*/dual(2, (self, f) => fromFlat(mapInputPathFlat(self.flattened, f)));
const mapInputPathFlat = (self, f) => makeFlat({
  load: (path, config, split = true) => self.load(path, config, split),
  enumerateChildren: path => self.enumerateChildren(path),
  patch: pathPatch.mapName(self.patch, f)
});
/** @internal */
export const nested = /*#__PURE__*/dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config) => self.flattened.load(path, config, true),
  enumerateChildren: path => self.flattened.enumerateChildren(path),
  patch: pathPatch.nested(self.flattened.patch, name)
})));
/** @internal */
export const unnested = /*#__PURE__*/dual(2, (self, name) => fromFlat(makeFlat({
  load: (path, config) => self.flattened.load(path, config, true),
  enumerateChildren: path => self.flattened.enumerateChildren(path),
  patch: pathPatch.unnested(self.flattened.patch, name)
})));
/** @internal */
export const orElse = /*#__PURE__*/dual(2, (self, that) => fromFlat(orElseFlat(self.flattened, () => that().flattened)));
const orElseFlat = (self, that) => makeFlat({
  load: (path, config, split) => pipe(pathPatch.patch(path, self.patch), core.flatMap(patch => self.load(patch, config, split)), core.catchAll(error1 => pipe(core.sync(that), core.flatMap(that => pipe(pathPatch.patch(path, that.patch), core.flatMap(patch => that.load(patch, config, split)), core.catchAll(error2 => core.fail(configError.Or(error1, error2)))))))),
  enumerateChildren: path => pipe(pathPatch.patch(path, self.patch), core.flatMap(patch => self.enumerateChildren(patch)), core.either, core.flatMap(left => pipe(core.syncVW}X+EHEQVPH7MSV+I_^[ UESVuى]E;t0WC;tV(;u]SQH{_EM^[ U9 uj hI0P,G]USVW3}Mګ?   Muh%e\E PE0Se Me G_^[ SVW3ۋCSh   t*h   Nj Q.^F^twp_^[USVWu؋SuEP͔pt*G#PV%   OFFA3@3_^[ UQEVu9Du9uA@D
9u ^] USVjXPj2#  SV(t-UMjXufEEuu] E2   E ^[ UjhWd    P   3ŉESVWPEd    ]O3PTXEh<P- }    MuЍ\x\   jGЉuP\ǅ\P`:ǅ`jGE   P\ǅ\HPM
`EPEǅ\4P\PQQNU 	  MV`KM؉3ssx֍D臹g PP  D/  PPPM誇Pt-Nt;Tu鋕X+׃NËMd    Y_^[M3 US]VWG++;uhhXO@+E+;w
4
;uBu*;uE؋ȉEзW]QS9UtU)   EWQMP   VuS   E_^[ UVu;t*SW+3ۉ^D>F\>;u_[Q֋^] UURPEM;EuVu& f    ^   MPM~   E UVtVQ}V+*MMEFEF^] 5UVW};t"   GFGF3GG_^] Vt"VQ	V+L3FF^Ë;Au%UQQM<   u  Mt蠲 UQQM      Mt|Ujh}Pd    PVW3PEd    d,   a<;G@~+hR,=Yuj :h,Yvd;G@~,W,=Yu+l hLWb,YY& f t
AhNDYƋMd    Y_^Ujh_d    P SVW3PEd    Ee p3u3ۉ}؋Ή]cu EM;t3P;t誴}WMW]܋}؍MEqV E3҉@ @EVuP<H@P@tʰVDuY VM=MPMt蠰;uhXj2h+  h"uԅtQ׋莃+ދ΃<JMd    Y_^[Ujhd    P   3ŉESVWPEd    ]EhP }    jG4E   P ǅ P$Dǅ$jGE   P ǅ HP`ǅ`jGE   P ǅ PMM$P`EPEǅ P PQQ] lM"`$  MuЍ w    !uG4jP ǅ P`9ǅ`jGE   P ǅ HP$`ǅ$P$ǅ P PQQI   $I`>1     PVSu蓪      jG4E   PǅP`hǅ`jGE   PǅHP$5M QP ǅ$PMǅ 3q`EP$ǅP5PEPPQQ\Bg M$4`)PPOd   U  RP$QMQPtZPR PR P   toMQPPtUL  s(t+Ru7L  U(tj 7T[ 3P QPM~t:;"M~Md    Y_^[M3 UuQ<4] USVjXPj
#  SV(t*UMjXufEEu]E
    E识^[ UVuWuu+7/Puu  _E^] UVuWuu+7/PuuO	  _E^] UQEVuWE;tP莮MsEQ׋~_^ Ad k VNL]}N4U}NM}N^D}Ujhd    PD  3ŉESVWPEd    uEh3ۉP^ 9]   jXPE`G4ǅPP萋ǅ`jGE   PǅHPM`EjGE   PǅP0M`PEǅPǅ@8PPQQ] kMc`X  MuЍÀ   !uG4jPǅPM舊EjGE   PǅHP`XEǅ`P`ǅ0PPQQI `M  !PVu 9   jG4E   PǅPMEjGE   PǅHP`萉MQPǅ`P ǅ3IlEǅ P`ǅ8P PPQQ[B4g 0Cz`M~PPOdX ^  0  RP4x uPRPR4PHHtyty0yQHQPtcPRPR PtrHQPPtU  P"t+Ru7  2"tj 7I[ 3P QPHxt;MxMd    Y_^[M3 UQVuuuC   EFhFd<k^Y] UVuuu   FdXk^] Ujhҁd    P(3ŉESVWPEd    MEuMЍOPO  VO4}OL  39GtF9GDtAUЍM'  POMw+   ǋMd    Y_^[M3 PhI PUjhd    P  3ŉESVWPEd    jj j  SPxY5SPh֍OSQP֍OSQP֍PPOLE!$ǅPjj
#  	I dMd    Y_^[M3UjhZd    P83ŉESVPEd    e z tDRMj[PtM؃vu-ƋMd    Y^[M3hM- 3C붍MuUQQe Ee VWMPhMt F Ex u.x΋Wu@ЄuMoEًMW61F Ex u!x΋Wu@ЄuэM3E2_^ UVW};t(GFGF3GG_^] k(UQQSVF+=us@WPE =ȉEgMu+ϋ誥VQW9UtUo  VCQMP_  uuW  _^[ US]MEVuWy  A+;   +U+;vPEg<ȉE` ΉE+MQuMȋ  u;u
UQMRQuM   EUQ΍P   uMuu	  tǋ+MQ;s8+W[   