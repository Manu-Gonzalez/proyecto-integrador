"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zero = exports.weeks = exports.unsafeToNanos = exports.unsafeFormatIso = exports.unsafeDivide = exports.toWeeks = exports.toSeconds = exports.toNanos = exports.toMinutes = exports.toMillis = exports.toHrTime = exports.toHours = exports.toDays = exports.times = exports.sum = exports.subtract = exports.seconds = exports.parts = exports.nanos = exports.minutes = exports.min = exports.millis = exports.micros = exports.max = exports.matchWith = exports.match = exports.lessThanOrEqualTo = exports.lessThan = exports.isZero = exports.isFinite = exports.isDuration = exports.infinity = exports.hours = exports.greaterThanOrEqualTo = exports.greaterThan = exports.fromIso = exports.formatIso = exports.format = exports.equals = exports.divide = exports.decodeUnknown = exports.decode = exports.days = exports.clamp = exports.between = exports.Order = exports.Equivalence = void 0;
var Equal = _interopRequireWildcard(require("./Equal.js"));
var _Function = require("./Function.js");
var Hash = _interopRequireWildcard(require("./Hash.js"));
var _Inspectable = require("./Inspectable.js");
var Option = _interopRequireWildcard(require("./Option.js"));
var order = _interopRequireWildcard(require("./Order.js"));
var _Pipeable = require("./Pipeable.js");
var _Predicate = require("./Predicate.js");
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 2.0.0
 */

const TypeId = /*#__PURE__*/Symbol.for("effect/Duration");
const bigint0 = /*#__PURE__*/BigInt(0);
const bigint24 = /*#__PURE__*/BigInt(24);
const bigint60 = /*#__PURE__*/BigInt(60);
const bigint1e3 = /*#__PURE__*/BigInt(1_000);
const bigint1e6 = /*#__PURE__*/BigInt(1_000_000);
const bigint1e9 = /*#__PURE__*/BigInt(1_000_000_000);
const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
/**
 * @since 2.0.0
 */
const decode = input => {
  if (isDuration(input)) {
    return input;
  } else if ((0, _Predicate.isNumber)(input)) {
    return millis(input);
  } else if ((0, _Predicate.isBigInt)(input)) {
    return nanos(input);
  } else if (Array.isArray(input) && input.length === 2 && input.every(_Predicate.isNumber)) {
    if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
      return zero;
    }
    if (input[0] === Infinity || input[1] === Infinity) {
      return infinity;
    }
    return nanos(BigInt(Math.round(input[0] * 1_000_000_000)) + BigInt(Math.round(input[1])));
  } else if ((0, _Predicate.isString)(input)) {
    const match = DURATION_REGEX.exec(input);
    if (match) {
      const [_, valueStr, unit] = match;
      const value = Number(valueStr);
      switch (unit) {
        case "nano":
        case "nanos":
          return nanos(BigInt(valueStr));
        case "micro":
        case "micros":
          return micros(BigInt(valueStr));
        case "milli":
        case "millis":
          return millis(value);
        case "second":
        case "seconds":
          return seconds(value);
        case "minute":
        case "minutes":
          return minutes(value);
        case "hour":
        case "hours":
          return hours(value);
        case "day":
        case "days":
          return days(value);
        case "week":
        case "weeks":
          return weeks(value);
      }
    }
  }
  throw new Error("Invalid DurationInput");
};
/**
 * @since 2.5.0
 */
exports.decode = decode;
const decodeUnknown = exports.decodeUnknown = /*#__PURE__*/Option.liftThrowable(decode);
const zeroValue = {
  _tag: "Millis",
  millis: 0
};
const infinityValue = {
  _tag: "Infinity"
};
const DurationProto = {
  [TypeId]: TypeId,
  [Hash.symbol]() {
    return Hash.cached(this, Hash.structure(this.value));
  },
  [Equal.symbol](that) {
    return isDuration(that) && equals(this, that);
  },
  toString() {
    return `Duration(${format(this)})`;
  },
  toJSON() {
    switch (this.value._tag) {
      case "Millis":
        return {
          _id: "Duration",
          _tag: "Millis",
          millis: this.value.millis
        };
      case "Nanos":
        return {
          _id: "Duration",
          _tag: "Nanos",
          hrtime: toHrTime(this)
        };
      case "Infinity":
        return {
          _id: "Duration",
          _tag: "Infinity"
        };
    }
  },
  [_Inspectable.NodeInspectSymbol]() {
    return this.toJSON();
  },
  pipe() {
    return (0, _Pipeable.pipeArguments)(this, arguments);
  }
};
const make = input => {
  const duration = Object.create(DurationProto);
  if ((0, _Predicate.isNumber)(input)) {
    if (isNaN(input) || input <= 0) {
      duration.value = zeroValue;
    } else if (!Number.isFinite(input)) {
      duration.value = infinityValue;
    } else if (!Number.isInteger(input)) {
      duration.value = {
        _tag: "Nanos",
        nanos: BigInt(Math.round(input * 1_000_000))
      };
    } else {
      duration.value = {
        _tag: "Millis",
        millis: input
      };
    }
  } else if (input <= bigint0) {
    duration.value = zeroValue;
  } else {
    duration.value = {
      _tag: "Nanos",
      nanos: input
    };
  }
  return duration;
};
/**
 * @since 2.0.0
 * @category guards
 */
const isDuration = u => (0, _Predicate.hasProperty)(u, TypeId);
/**
 * @since 2.0.0
 * @category guards
 */
exports.isDuration = isDuration;
const isFinite = self => self.value._tag !== "Infinity";
/**
 * @since 3.5.0
 * @category guards
 */
exports.isFinite = isFinite;
const isZero = self => {
  switch (self.value._tag) {
    case "Millis":
      {
        return self.value.millis === 0;
      }
    case "Nanos":
      {
        return self.value.nanos === bigint0;
      }
    case "Infinity":
      {
        return false;
      }
  }
};
/**
 * @since 2.0.0
 * @category constructors
 */
exports.isZero = isZero;
const zero = exports.zero = /*#__PURE__*/make(0);
/**
 * @since 2.0.0
 * @category constructors
 */
const infinity = exports.infinity = /*#__PURE__*/make(Infinity);
/**
 * @since 2.0.0
 * @category constructors
 */
const nanos = nanos => make(nanos);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.nanos = nanos;
const micros = micros => make(micros * bigint1e3);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.micros = micros;
const millis = millis => make(millis);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.millis = millis;
const seconds = seconds => make(seconds * 1000);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.seconds = seconds;
const minutes = minutes => make(minutes * 60_000);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.minutes = minutes;
const hours = hours => make(hours * 3_600_000);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.hours = hours;
const days = days => make(days * 86_400_000);
/**
 * @since 2.0.0
 * @category constructors
 */
exports.days = days;
const weeks = weeks => make(weeks * 604_800_000);
/**
 * @since 2.0.0
 * @category getters
 */
exports.weeks = weeks;
const toMillis = self => match(self, {
  onMillis: millis => millis,
  onNanos: nanos => Number(nanos) / 1_000_000
});
/**
 * @since 2.0.0
 * @category getters
 */
exports.toMillis = toMillis;
const toSeconds = self => match(self, {
  onMillis: millis => millis / 1_000,
  onNanos: nanos => Number(nanos) / 1_000_000_000
});
/**
 * @since 3.8.0
 * @category getters
 */
exports.toSeconds = toSeconds;
const toMinutes = self => match(self, {
  onMillis: millis => millis / 60_000,
  onNanos: nanos => Number(nanos) / 60_000_000_000
});
/**
 * @since 3.8.0
 * @category getters
 */
exports.toMinutes = toMinutes;
const toHours = self => match(self, {
  onMillis: millis => millis / 3_600_000,
  onNanos: nanos => Number(nanos) / 3_600_000_000_000
});
/**
 * @since 3.8.0
 * @category getters
 */
exports.toHours = toHours;
const toDays = self => match(self, {
  onMillis: millis => millis / 86_400_000,
  onNanos: nanos => Number(nanos) / 86_400_000_000_000
});
/**
 * @since 3.8.0
 * @category getters
 */
exports.toDays = toDays;
const toWeeks = self => match(self, {
  onMillis: millis => millis / 604_800_000,
  onNanos: nanos => Number(nanos) / 604_800_000_000_000
});
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, returns `Option.none()`
 *
 * @since 2.0.0
 * @category getters
 */
exports.toWeeks = toWeeks;
const toNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return Option.none();
    case "Nanos":
      return Option.some(_self.value.nanos);
    case "Millis":
      return Option.some(BigInt(Math.round(_self.value.millis * 1_000_000)));
  }
};
/**
 * Get the duration in nanoseconds as a bigint.
 *
 * If the duration is infinite, it throws an error.
 *
 * @since 2.0.0
 * @category getters
 */
exports.toNanos = toNanos;
const unsafeToNanos = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      throw new Error("Cannot convert infinite duration to nanos");
    case "Nanos":
      return _self.value.nanos;
    case "Millis":
      return BigInt(Math.round(_self.value.millis * 1_000_000));
  }
};
/**
 * @since 2.0.0
 * @category getters
 */
exports.unsafeToNanos = unsafeToNanos;
const toHrTime = self => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Infinity":
      return [Infinity, 0];
    case "Nanos":
      return [Number(_self.value.nanos / bigint1e9), Number(_self.value.nanos % bigint1e9)];
    case "Millis":
      return [Math.floor(_self.value.millis / 1000), Math.round(_self.value.millis % 1000 * 1_000_000)];
  }
};
/**
 * @since 2.0.0
 * @category pattern matching
 */
exports.toHrTime = toHrTime;
const match = exports.match = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => {
  const _self = decode(self);
  switch (_self.value._tag) {
    case "Nanos":
      return options.onNanos(_self.value.nanos);
    case "Infinity":
      return options.onMillis(Infinity);
    case "Millis":
      return options.onMillis(_self.value.millis);
  }
});
/**
 * @since 2.0.0
 * @category pattern matching
 */
const matchWith = exports.matchWith = /*#__PURE__*/(0, _Function.dual)(3, (self, that, options) => {
  const _self = decode(self);
  const _that = decode(that);
  if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
    return options.onMillis(toMillis(_self), toMillis(_that));
  } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
    const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1_000_000));
    const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1_000_000));
    return options.onNanos(selfNanos, thatNanos);
  }
  return options.onMillis(_self.value.millis, _that.value.millis);
});
/**
 * @category instances
 * @since 2.0.0
 */
const Order = exports.Order = /*#__PURE__*/order.make((self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that ? -1 : self > that ? 1 : 0,
  onNanos: (self, that) => self < that ? -1 : self > that ? 1 : 0
}));
/**
 * Checks if a `Duration` is between a `minimum` and `maximum` value.
 *
 * @category predicates
 * @since 2.0.0
 */
const between = exports.between = /*#__PURE__*/order.between(/*#__PURE__*/order.mapInput(Order, decode));
/**
 * @category instances
 * @since 2.0.0
 */
const Equivalence = (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self === that,
  onNanos: (self, that) => self === that
});
exports.Equivalence = Equivalence;
const _min = /*#__PURE__*/order.min(Order);
/**
 * @since 2.0.0
 */
const min = exports.min = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => _min(decode(self), decode(that)));
const _max = /*#__PURE__*/order.max(Order);
/**
 * @since 2.0.0
 * @category order
 */
const max = exports.max = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => _max(decode(self), decode(that)));
const _clamp = /*#__PURE__*/order.clamp(Order);
/**
 * @since 2.0.0
 * @category order
 */
const clamp = exports.clamp = /*#__PURE__*/(0, _Function.dual)(2, (self, options) => _clamp(decode(self), {
  minimum: decode(options.minimum),
  maximum: decode(options.maximum)
}));
/**
 * @since 2.4.19
 * @category math
 */
const divide = exports.divide = /*#__PURE__*/(0, _Function.dual)(2, (self, by) => match(self, {
  onMillis: millis => {
    if (by === 0 || isNaN(by) || !Number.isFinite(by)) {
      return Option.none();
    }
    return Option.some(make(millis / by));
  },
  onNanos: nanos => {
    if (isNaN(by) || by <= 0 || !Number.isFinite(by)) {
      return Option.none();
    }
    try {
      return Option.some(make(nanos / BigInt(by)));
    } catch {
      return Option.none();
    }
  }
}));
/**
 * @since 2.4.19
 * @category math
 */
const unsafeDivide = exports.unsafeDivide = /*#__PURE__*/(0, _Function.dual)(2, (self, by) => match(self, {
  onMillis: millis => make(millis / by),
  onNanos: nanos => {
    if (isNaN(by) || by < 0 || Object.is(by, -0)) {
      return zero;
    } else if (Object.is(by, 0) || !Number.isFinite(by)) {
      return infinity;
    }
    return make(nanos / BigInt(by));
  }
}));
/**
 * @since 2.0.0
 * @category math
 */
const times = exports.times = /*#__PURE__*/(0, _Function.dual)(2, (self, times) => match(self, {
  onMillis: millis => make(millis * times),
  onNanos: nanos => make(nanos * BigInt(times))
}));
/**
 * @since 2.0.0
 * @category math
 */
const subtract = exports.subtract = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => make(self - that),
  onNanos: (self, that) => make(self - that)
}));
/**
 * @since 2.0.0
 * @category math
 */
const sum = exports.sum = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => make(self + that),
  onNanos: (self, that) => make(self + that)
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const lessThan = exports.lessThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self < that,
  onNanos: (self, that) => self < that
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const lessThanOrEqualTo = exports.lessThanOrEqualTo = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self <= that,
  onNanos: (self, that) => self <= that
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const greaterThan = exports.greaterThan = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self > that,
  onNanos: (self, that) => self > that
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const greaterThanOrEqualTo = exports.greaterThanOrEqualTo = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => matchWith(self, that, {
  onMillis: (self, that) => self >= that,
  onNanos: (self, that) => self >= that
}));
/**
 * @since 2.0.0
 * @category predicates
 */
const equals = exports.equals = /*#__PURE__*/(0, _Function.dual)(2, (self, that) => Equivalence(decode(self), decode(that)));
/**
 * Converts a `Duration` to its parts.
 *
 * @since 3.8.0
 * @category conversions
 */
const parts = self => {
  const duration = decode(self);
  if (duration.value._tag === "Infinity") {
    return {
      days: Infinity,
      hours: Infinity,
      minutes: Infinity,
      seconds: Infinity,
      millis: Infinity,
      nanos: Infinity
    };
  }
  const nanos = unsafeToNanos(duration);
  const ms = nanos / bigint1e6;
  const sec = ms / bigint1e3;
  const min = sec / bigint60;
  const hr = min / bigint60;
  const days = hr / bigint24;
  return {
    days: Number(days),
    hours: Number(hr % er AddHandler RaiseEvent GetAnimationBaseValue get_HasAnimatedProperties BeginAnimation ApplyAnimationClock remove_MouseEnter add_StylusUp add_StylusButtonUp add_PreviewMouseRightButtonDown add_PreviewMouseRightButtonUp add_GotKeyboardFocus DependencyProperty AddToEventRouteCore EnsureEventHandlersStore OnMouseLeave OnStylusSystemGesture OnPreviewTouchDown OnIsMouseCaptureWithinChanged PredictFocus OnManipulationStarting OnRender EvaluateAnimatedValueCore System.Windows.Media.Composition.DUCE.IResource.GetHandle System.Windows.Media.Composition.DUCE.IResource.Get3DHandle System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel AddRefOnChannelCore ReleaseOnChannelCore System.Windows.Media.Composition.DUCE.IResource.RemoveChildFromParent System.Windows.Media.Composition.DUCE.IResource.GetChannelCount System.Windows.Media.Composition.DUCE.IResource.GetChannel GetContentBounds RenderContent RenderClose CalculateSubgraphBoundsInnerSpace FreeContent System.Windows.Media.Composition.DUCE.IResource.ReleaseOnChannel AddRefOnChannelForCyclicBrush ReleaseOnChannelForCyclicBrush PrecomputeContent RenderRecursive GetHitTestBounds HitTestPointInternal HitTestCore get_InternalVisual2DOr3DChildrenCount InternalGet2DOr3DVisualChild GetDrawing FireOnVisualParentChanged OnDpiChanged ContentsChanged OnPreviewMouseDown OnMouseDown OnPreviewMouseUp OnMouseUp OnPreviewMouseLeftButtonDown OnMouseLeftButtonDown OnPreviewMouseLeftButtonUp OnMouseLeftButtonUp OnPreviewMouseRightButtonDown OnMouseRightButtonDown OnPreviewMouseRightButtonUp OnMouseRightButtonUp OnPreviewMouseMove OnMouseMove OnPreviewMouseWheel OnMouseWheel OnMouseEnter OnGotMouseCapture OnLostMouseCapture OnQueryCursor OnPreviewStylusDown OnStylusDown OnPreviewStylusUp OnStylusUp OnPreviewStylusMove OnStylusMove OnPreviewStylusInAirMove OnStylusInAirMove OnStylusEnter OnStylusLeave OnPreviewStylusInRange OnStylusInRange OnPreviewStylusOutOfRange OnStylusOutOfRange OnPreviewStylusSystemGesture OnGotStylusCapture OnLostStylusCapture OnStylusButtonDown OnStylusButtonUp OnPreviewStylusButtonDown OnPreviewStylusButtonUp OnPreviewKeyDown OnPreviewKeyUp OnKeyUp OnPreviewGotKeyboardFocus OnGotKeyboardFocus OnPreviewLostKeyboardFocus OnLostKeyboardFocus OnPreviewTextInput OnPreviewQueryContinueDrag OnQueryContinueDrag OnPreviewGiveFeedback OnGiveFeedback OnPreviewDragEnter OnDragEnter OnPreviewDragOver OnDragOver OnPreviewDragLeave OnDragLeave OnPreviewDrop OnDrop OnTouchDown OnPreviewTouchMove OnTouchMove OnPreviewTouchUp OnTouchUp OnGotTouchCapture OnLostTouchCapture OnTouchEnter OnTouchLeave OnIsMouseDirectlyOverChanged OnIsMouseCapturedChanged OnIsStylusDirectlyOverChanged OnIsStylusCapturedChanged OnIsStylusCaptureWithinChanged OnIsKeyboardFocusedChanged OnChildDesiredSizeChanged BlockReverseInheritance OnAccessKey get_HasEffectiveKeyboardFocus OnLostFocus get_IsEnabledCore OnManipulationStarted OnManipulationDelta OnManipulationInertiaStarting OnManipulationBoundaryFeedback OnManipulationCompleted OnKeyDown OnTextInput OnIsKeyboardFocusWithinChanged OnCreateAutomationPeer set_IsManipulationEnabled SynchronizeForceInheritProperties RaiseIsStylusCaptureWithinChanged IsMouseDirectlyOver_Changed OnTouchMoveThunk OnKeyUpThunk remove_ManipulationStarting get_IsVisible CloneCurrentValue OnVisualChildrenChanged element GetName TransformGroup TransformCollection SkewTransform TranslateTransform MouseButtonEventArgs RoutedEventArgs AutomationPeer System.Windows.Automation.Peers ComputeNativeValues op_Addition FromArgb SetName UIPropertyMetadata MouseEventArgs AddWithoutFiringPublicEvents KeyboardFocusChangedEventArgs Matrix KeyEventArgs DoubleAnimationUsingKeyFrames EasingDoubleKeyFrame DoubleKeyFrameCollection DoubleKeyFrame PointAnimationUsingKeyFrames EasingPointKeyFrame PointKeyFrameCollection PointKeyFrame PointAnimationBase MouseWheelEventArgs FontStretch TextDecoration DrawRectangle get_Segments set_IsClosed get_Figures DrawGeometry Pop Internal_GetItem set_B set_G set_R set_A TransformBounds Nullable`1 DrawingContext ICommand remove_PreviewExecuted CommandManager RegisterClassCommandBinding Size get_B get_G get_R get_A Rect set_StartPoint Point get_FillRule Box get_Color op_Inequality op_Equality WritePostscript Key set_CommandParameter GeneralTransform2DTo3D System.Windows.Media.Media3D set_Command Mouse DependencyObject get_Value VisualTreeHelper GetChildrenCount GetChild TimeSpan get_Children get_Item AnimationClock FontStyle FontCapitals AllSmallCaps SmallCaps AllPetiteCaps PetiteCaps Unicase Titling TextDecorationLocation OverLine Strikethrough Baseline GetPropertyName get_Refresh get_Automatic WindowsXPSP2 WindowsXPSP3 WindowsVista WindowsVistaSP1 WindowsVistaSP2 Windows7 Windows7SP1 Windows8 Windows8Point1 Windows10 Windows10TH2 Windows10RS1 Windows10RS2 Windows10RS3 Windows10RS5 GuidelineSet PushGuidelineSet set_RadiusY set_RadiusX set_Center set_GradientOrigin _size StylusUpEvent GotKeyboardFocusEvent IsStylusCaptureWithinChangedKey DpiLock MouseOverProperty StylusButtonUpEvent ColorAnimat