"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zonedOffsetIso = exports.zonedOffset = exports.zoneUnsafeMakeNamed = exports.zoneToString = exports.zoneMakeOffset = exports.zoneMakeNamedEffect = exports.zoneMakeNamed = exports.zoneMakeLocal = exports.zoneFromString = exports.withDateUtc = exports.withDate = exports.withCurrentZoneOffset = exports.withCurrentZoneNamed = exports.withCurrentZoneLocal = exports.withCurrentZone = exports.unsafeSetZoneNamed = exports.unsafeNow = exports.unsafeMakeZoned = exports.unsafeMake = exports.unsafeIsPast = exports.unsafeIsFuture = exports.unsafeFromDate = exports.toUtc = exports.toPartsUtc = exports.toParts = exports.toEpochMillis = exports.toDateUtc = exports.toDate = exports.subtractDuration = exports.subtract = exports.startOf = exports.setZoneOffset = exports.setZoneNamed = exports.setZoneCurrent = exports.setZone = exports.setPartsUtc = exports.setParts = exports.removeTime = exports.nowInCurrentZone = exports.nowAsDate = exports.now = exports.nearest = exports.mutateUtc = exports.mutate = exports.min = exports.max = exports.match = exports.mapEpochMillis = exports.makeZonedFromString = exports.makeZoned = exports.make = exports.lessThanOrEqualTo = exports.lessThan = exports.layerCurrentZoneOffset = exports.layerCurrentZoneNamed = exports.layerCurrentZoneLocal = exports.layerCurrentZone = exports.isZoned = exports.isUtc = exports.isTimeZoneOffset = exports.isTimeZoneNamed = exports.isTimeZone = exports.isPast = exports.isFuture = exports.isDateTime = exports.greaterThanOrEqualTo = exports.greaterThan = exports.getPartUtc = exports.getPart = exports.formatUtc = exports.formatLocal = exports.formatIsoZoned = exports.formatIsoOffset = exports.formatIsoDateUtc = exports.formatIsoDate = exports.formatIso = exports.formatIntl = exports.format = exports.endOf = exports.distanceDurationEither = exports.distanceDuration = exports.distance = exports.clamp = exports.between = exports.addDuration = exports.add = exports.TypeId = exports.TimeZoneTypeId = exports.Order = exports.Equivalence = exports.CurrentTimeZone = void 0;
var Context = _interopRequireWildcard(require("./Context.js"));
var Effect = _interopRequireWildcard(require("./Effect.js"));
var _Function = require("./Function.js");
var Internal = _interopRequireWildcard(require("./internal/dateTime.js"));
var Layer = _interopRequireWildcard(require("./Layer.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 3.6.0
 * @category type ids
 */
const TypeId = exports.TypeId = Internal.TypeId;
/**
 * @since 3.6.0
 * @category type ids
 */
const TimeZoneTypeId = exports.TimeZoneTypeId = Internal.TimeZoneTypeId;
// =============================================================================
// guards
// =============================================================================
/**
 * @since 3.6.0
 * @category guards
 */
const isDateTime = exports.isDateTime = Internal.isDateTime;
/**
 * @since 3.6.0
 * @category guards
 */
const isTimeZone = exports.isTimeZone = Internal.isTimeZone;
/**
 * @since 3.6.0
 * @category guards
 */
const isTimeZoneOffset = exports.isTimeZoneOffset = Internal.isTimeZoneOffset;
/**
 * @since 3.6.0
 * @category guards
 */
const isTimeZoneNamed = exports.isTimeZoneNamed = Internal.isTimeZoneNamed;
/**
 * @since 3.6.0
 * @category guards
 */
const isUtc = exports.isUtc = Internal.isUtc;
/**
 * @since 3.6.0
 * @category guards
 */
const isZoned = exports.isZoned = Internal.isZoned;
// =============================================================================
// instances
// =============================================================================
/**
 * @since 3.6.0
 * @category instances
 */
const Equivalence = exports.Equivalence = Internal.Equivalence;
/**
 * @since 3.6.0
 * @category instances
 */
const Order = exports.Order = Internal.Order;
/**
 * @since 3.6.0
 */
const clamp = exports.clamp = Internal.clamp;
// =============================================================================
// constructors
// =============================================================================
/**
 * Create a `DateTime` from a `Date`.
 *
 * If the `Date` is invalid, an `IllegalArgumentException` will be thrown.
 *
 * @since 3.6.0
 * @category constructors
 */
const unsafeFromDate = exports.unsafeFromDate = Internal.unsafeFromDate;
/**
 * Create a `DateTime` from one of the following:
 *
 * - A `DateTime`
 * - A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
 * - The `number` of milliseconds since the Unix epoch
 * - An object with the parts of a date
 * - A `string` that can be parsed by `Date.parse`
 *
 * @since 3.6.0
 * @category constructors
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // from Date
 * DateTime.unsafeMake(new Date())
 *
 * // from parts
 * DateTime.unsafeMake({ year: 2024 })
 *
 * // from string
 * DateTime.unsafeMake("2024-01-01")
 * ```
 */
const unsafeMake = exports.unsafeMake = Internal.unsafeMake;
/**
 * Create a `DateTime.Zoned` using `DateTime.unsafeMake` and a time zone.
 *
 * The input is treated as UTC and then the time zone is attached, unless
 * `adjustForTimeZone` is set to `true`. In that case, the input is treated as
 * already in the time zone.
 *
 * When `adjustForTimeZone` is true and ambiguous times occur during DST transitions,
 * the `disambiguation` option controls how to resolve the ambiguity:
 * - `compatible` (default): Choose earlier time for repeated times, later for gaps
 * - `earlier`: Always choose the earlier of two possible times
 * - `later`: Always choose the later of two possible times
 * - `reject`: Throw an error when ambiguous times are encountered
 *
 * @since 3.6.0
 * @category constructors
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * DateTime.unsafeMakeZoned(new Date(), { timeZone: "Europe/London" })
 * ```
 */
const unsafeMakeZoned = exports.unsafeMakeZoned = Internal.unsafeMakeZoned;
/**
 * Create a `DateTime.Zoned` using `DateTime.make` and a time zone.
 *
 * The input is treated as UTC and then the time zone is attached, unless
 * `adjustForTimeZone` is set to `true`. In that case, the input is treated as
 * already in the time zone.
 *
 * When `adjustForTimeZone` is true and ambiguous times occur during DST transitions,
 * the `disambiguation` option controls how to resolve the ambiguity:
 * - `compatible` (default): Choose earlier time for repeated times, later for gaps
 * - `earlier`: Always choose the earlier of two possible times
 * - `later`: Always choose the later of two possible times
 * - `reject`: Throw an error when ambiguous times are encountered
 *
 * If the date time input or time zone is invalid, `None` will be returned.
 *
 * @since 3.6.0
 * @category constructors
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * DateTime.makeZoned(new Date(), { timeZone: "Europe/London" })
 * ```
 */
const makeZoned = exports.makeZoned = Internal.makeZoned;
/**
 * Create a `DateTime` from one of the following:
 *
 * - A `DateTime`
 * - A `Date` instance (invalid dates will throw an `IllegalArgumentException`)
 * - The `number` of milliseconds since the Unix epoch
 * - An object with the parts of a date
 * - A `string` that can be parsed by `Date.parse`
 *
 * If the input is invalid, `None` will be returned.
 *
 * @since 3.6.0
 * @category constructors
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // from Date
 * DateTime.make(new Date())
 *
 * // from parts
 * DateTime.make({ year: 2024 })
 *
 * // from string
 * DateTime.make("2024-01-01")
 * ```
 */
const make = exports.make = Internal.make;
/**
 * Create a `DateTime.Zoned` from a string.
 *
 * It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.
 *
 * @since 3.6.0
 * @category constructors
 */
const makeZonedFromString = exports.makeZonedFromString = Internal.makeZonedFromString;
/**
 * Get the current time using the `Clock` service and convert it to a `DateTime`.
 *
 * @since 3.6.0
 * @category constructors
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   const now = yield* DateTime.now
 * })
 * ```
 */
const now = exports.now = Internal.now;
/**
 * Get the current time using the `Clock` service.
 *
 * @since 3.14.0
 * @category constructors
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   const now = yield* DateTime.nowAsDate
 * })
 * ```
 */
const nowAsDate = exports.nowAsDate = Internal.nowAsDate;
/**
 * Get the current time using `Date.now`.
 *
 * @since 3.6.0
 * @category constructors
 */
const unsafeNow = exports.unsafeNow = Internal.unsafeNow;
// =============================================================================
// time zones
// =============================================================================
/**
 * For a `DateTime` returns a new `DateTime.Utc`.
 *
 * @since 3.13.0
 * @category time zones
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })
 *
 * // set as UTC
 * const utc: DateTime.Utc = DateTime.toUtc(now)
 * ```
 */
const toUtc = exports.toUtc = Internal.toUtc;
/**
 * Set the time zone of a `DateTime`, returning a new `DateTime.Zoned`.
 *
 * @since 3.6.0
 * @category time zones
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   const now = yield* DateTime.now
 *   const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")
 *
 *   // set the time zone
 *   const zoned: DateTime.Zoned = DateTime.setZone(now, zone)
 * })
 * ```
 */
const setZone = exports.setZone = Internal.setZone;
/**
 * Add a fixed offset time zone to a `DateTime`.
 *
 * The offset is in milliseconds.
 *
 * @since 3.6.0
 * @category time zones
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   const now = yield* DateTime.now
 *
 *   // set the offset time zone in milliseconds
 *   const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)
 * })
 * ```
 */
const setZoneOffset = exports.setZoneOffset = Internal.setZoneOffset;
/**
 * Attempt to create a named time zone from a IANA time zone identifier.
 *
 * If the time zone is invalid, an `IllegalArgumentException` will be thrown.
 *
 * @since 3.6.0
 * @category time zones
 */
const zoneUnsafeMakeNamed = exports.zoneUnsafeMakeNamed = Internal.zoneUnsafeMakeNamed;
/**
 * Create a fixed offset time zone.
 *
 * @since 3.6.0
 * @category time zones
 */
const zoneMakeOffset = exports.zoneMakeOffset = Internal.zoneMakeOffset;
/**
 * Create a named time zone from a IANA time zone identifier. If the time zone
 * is invalid, `None` will be returned.
 *
 * @since 3.6.0
 * @category time zones
 */
const zoneMakeNamed = exports.zoneMakeNamed = Internal.zoneMakeNamed;
/**
 * Create a named time zone from a IANA time zone identifier. If the time zone
 * is invalid, it will fail with an `IllegalArgumentException`.
 *
 * @since 3.6.0
 * @category time zones
 */
const zoneMakeNamedEffect = exports.zoneMakeNamedEffect = Internal.zoneMakeNamedEffect;
/**
 * Create a named time zone from the system's local time zone.
 *
 * @since 3.6.0
 * @category time zones
 */
const zoneMakeLocal = exports.zoneMakeLocal = Internal.zoneMakeLocal;
/**
 * Try parse a TimeZone from a string
 *
 * @since 3.6.0
 * @category time zones
 */
const zoneFromString = exports.zoneFromString = Internal.zoneFromString;
/**
 * Format a `TimeZone` as a string.
 *
 * @since 3.6.0
 * @category time zones
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * // Outputs "+03:00"
 ğ£ôİ²¼O'^šlÔåõGş–Œ>'ó †­SÚ”C>/söã1UyMÇ»õÑØc]D~÷y1"?)£üq$pÁ–«k4R™QÀ:øA”õô»À	}/İŸêÀËQ“4®jP²LŸ5@g³¶WÍ¸§’us5L^|×H¤a@°%³²/&¼ûfDß2»ò2*µƒì}7ã\2tø¼Qğ‚7ß)Ó´~òqE€}ÏNıíJMÓjv;…˜Ræt´K«ˆ/(F~zŸíó=fĞ'«‘GÃ¡[ø{Štãåî™9›o“¡o8GùÕÙÄƒK‹ö­&Ç@ã;r˜ö8î‡êŞXf(ğ÷2OğùÃÏŠsÿb”F˜Yoo:¶ejW*à*]Õ®,İP†+@uÂ+¹,zM+†ék­¿©¨×[„e-V¼Œg“F“!·JRêlÛgÌ4äg#umÃ„¶õÇcé`êc)­–N´jæ3jIÏ;¦mÎç5ğfÎt7w:Şò(eÊÌœciå§èƒ#s 2 ”î^Ê:„ô¨‡²KnÒ;¬·Dc¹ÖÏT½¦eWæ;i¤YÄ
éÒİ‡q¤èGH¹¬£0ÀäÈK0¹fj[…ş1¨Å¹çÊßb©•ú~±t%d¶Jd·7µ<uĞè´1#„Î=¦.0>:l7Û%4ÅXÒÅÍf#€ƒ@tO'¦GzG;ğ6,_¡~ÆcC”W¨ÒÊÙ³Ëæss:D¡Y¦¹Œş•èI ±\ĞÆa4SOê”3!X\<ôı;úlIİßœiïkˆd±ëÒvq({‡|`“V©I‹ÖÕ9[,Ö“ñi¾\§i\5‚+€m³{›š~qhScWö’²•ñ1@eîİ÷}_Œñú*Æ‹Fì¹!o Bh-d°KõXrïzÒ§?–¡Oå1b@@±Ùæ–jvÔqq[†.*¥ı{Ú½Õ««L9EÙt«–¤ÇÙd•œà¦|g¶0·gh±R®1.úp(\¦9TÍ¯’³Ôù¥s¢eª|ènÂ¸m¿!İÒVèÄˆSa*Ùİ®ô_¡LÚÍÖÇHû5*ê´tï  eècO]ç\“ÇÑñ0%³hÈ_S?yß‚²u\:¯* ÕJÕ­Ü÷]¾µ‡–vÌ!®]í3ãİë4ç4Öïå˜ŒMÅ-ó¶<ûÆ­Z´Í1£Oh‡Áê;É‹˜~”+¯0K„sEş¬¡ÏûÍdà
öÃè{øÈh:gÊæiK‹~èĞWï«7!”jpÎ¼Ü1¯ŠnÓ ¡aí1v€õ @WêìŞnœó:¼w´CÇW{ St BÙ©ÿùÜìxïvÅÃŠvĞ®Ù'2DÁárõ)R–ó»˜ø¹–µhxP1‘/éğæñô› Îu^û|-ÉeNê,ÆEV”d8ô²YDaûé+Ú¹Û¸²k	Ÿ7=rdV¤Ïlümçœ‡?ğ¼ÊÇ.¥u­¦U™öÉ~-èç¥¼£LûWL¶İV§]…¿á¼T§«òÀ|`¦ô7àÈ”ún# #X#ğë&°åÜIa‹è˜²]e¡QßY+*)­º¿¹'*2iy$rm½™ñ÷œ9¯£QÇ(4Êë°¬µÑØ2®ÆWaqŒ–ãa†´Ù`!xã`6"¼Û9øó>Ú³Ğ®utÛ%ÚY{æìl©Ü€§÷ôÑŒ²‹çO.âù7.Ó¸l·“,~i¦ƒR¥ÍTûğÍ&ŠœŠítº…GÜÅı»»ô~·D±Ì¼Ó:yjÖzæEPŒéİgqûæ¶uWÕµœÇÌêU«ãÉ³ÊyãuŠöÖY±6 şÙ=©3o+(¼÷’Fä*]”¹6¿ÑĞùxØ-cØê¡DWê‰Wä6Ãßİ$9¿Ïˆ€,d|[n„^k¤º›¤Î˜¡óQ}”@¦
£ª*6‰2ôkæ„}£cüæfc—oè‹Î9
,Êûj‹áâ°¸MN€³³ñôù3dû,ŞQ.÷‚éh/Äı›w±ã´ÛˆNï)|v¿cnåºÈŒf¼şü–:@ÛĞâIjK%É¸ätY»Ò½ÉÜ¡o‘|Ã(ûyüàÕ2aGiº”[%y\(w 'hq¿Œ‹º8/[Õ¯ƒÌ=’ÍötÛŸA{ğ¿y!µ8‹Œ…uåf-“}|öÅw0gàó-ä¬³£œŸ´âş¶”œ–¥Ú2­ÂÿÉ#ÜÖB€7é¯âáÆñÛDùlz?·8Ñ¸Xçc´ÈñŸÈ>€j§´ËòÉN|FŒ€¬ªBÿ\’ï®7kä}	ìXJÁ	ú~Ìd7àG¹mù5ø}ƒ¹]¡ı{è«í¶ÛMæ1ü÷ôyyXˆÛÑ:•éëÜ@â~Î+4Ì‚Â¢
ïš0ÿúsç8©¸åö}Â¡æÎ¹õöÍ$e¬*BÃ¦«Â¨ˆŒÓ +§á`v¡é-˜`3ËÛËÏVÈÎ»‡	üŒ«Ñ¬b °¢›?S€É şŒ8w¿|Éqj¹óÙ.~øZÇÙ\¨7ı–vñÚU×³}ôà#—àÊ´'­Şğ  ÿôIDAT(æV®¹_¹<DG•+u³ùÎsG·0pÁò••»Í0Ğ®JíğºõSŠíım#¶æËïÒNpÒ¥ÆoŸ©V4ÊĞ`cqÖû‡İeğî`”é|bDq€\«:İkıa–éOnHï¶!‘}¹å‡6m5€!áğã=œ¾À¡¶>°8od
Š4ï“Ïz<~¤ëöÇŠ60Ä)ğÄ-à<­«¿ûEêvÊoõ0Ët‹·L³rb,‚Öá¯êÒ<²³ãødÂ*ÖóñoÛa>>a{9ÅféøÊı?ËCã8€è*õD‹ğ ûLG¼Î	é ä¬Ewq²FRq¬z¢§å¨_Êëü^rÎƒwĞ³,nÿŠ/¤³rè<05qZùO9Â»¢Fo8!n³S¡?éÂzœF\]åâQàœT/Ù€#¥eyl:n˜?ÒŒÃb°ÿ³SôŞ«ã¡ŸK{„p s4F¦½Ü™Ãf„Òáz |°*ï–ø
ıÂ§R04óÄ 8t@¾­ºû©R/Şc†™%ó÷æÆ­Ã²ù ì7Èp³{ç#:öÈ…2mkAkğhÊ.ÓŞ’xŒQæÕ÷V«=,bú ~Ù ³·+¼Çıò+Ñ¦Ÿœãnib½<j¼ˆëwÓxõÅ4Ş!÷î‘uÍF-ºçMt§z\>mĞ‡È[ô3Uyf6ãòniö8¾ê–Ûå"V3:úÔÁş¬qÚk3wv®8~Œräáv7oÿó¨Ãw›Œ]~Ûf’Ÿ6£§á—uïê¤9ó¹¥İ)Ó‚xº|ˆŞi!.¯
q~Vâ~ƒV‘Åä…@|¥´-ä\­VËø6òÉ-bš`õSà_r–¥íµÀp«ù],>Dî]œ°gL¸‰™µ±ªƒ^İ$=èèßÓïb2³®YÆr¾€YÎ)ÇLSpìÔïôÙâs¡ÃLn–„<­voSÇ.Œ­C¿· útåv@jÚÒïz}ô·’Ê3~fLªÁØàÀ:x¾Œî—Û2“bÔ”‘Œ9vÚ>Äßÿ=gËÏ÷pşˆÇ"Óóëãë#Ò„ç/òñwÿÕLötšàæz•ú«8W»Ë¾ĞˆºQÁ°øãê=Ã%íüp"ßÉ'~}«ìØÀ'ç1C758@D»Ùºm±}¶`Å‰gğgyôÅi^Y‰Oß¹`B,p€çÃãÚà»ö.e>êòü<¯Ó(Q‡b<ã{»n`l!9í
3›EŒëSt“<ZÜ—äåi‹Ê×ÀHÚOOªññ‡õøö·êñüY•÷–RF§	ÒC;¨òZù'P¶ª;Mª§İÊIeõyŠJ˜ì…n))Nğo3ûˆì#u}áĞÀ«0˜Ğ-w”µ¿ùá/:•|}üº_ÜfvÑ{ô•éè ~ÊèÛ ÍxwîbÀLÒ9ÀFGÃ í"¸­Vë‚[NÀ²]0DüŠÜïš1ñ"ºgWqşô¼õ2ÎŸ¼ˆÎÉó8¿â³w–l.µF3Ù€:§½89;‹.¸ªİÑ.ŞL6­¤%Øe ¼_›‘ØÂü7“U.\ğTEñÓ&ÛEi|rÕŠgO›quÑ n•	€a¨ÓhãÌ¶ãÌìXf	VÖÎçœÿ¸èÁfb®ÃÏNàA§§upn™²<]¼µqÚâq“ôVƒeu2«÷ÇYæßv;ß(Åå9õyqç—'Q…ßj‹Ï»`*?×|Åİu
¬t!R>jVßİ¶’•ª(ô.}Ò®¢{€‹ó0é2áqõæÑ`ßûŞ>wè`Í'W;t0xªÏX¦í£áëºUí¬ÙØıYÇûëq¨Óá¼ÿ·wú·ševİOŞÍ4??~V¶§Õ_i¯¢™™³¿QÓu?=ò;¹”ÎãwIÃûŸ–“!Ûl<2ÇÿŸ<ÿ~_=²¶dç±ş©-çñ7Ïãa9?éÚ¯Óa?ıÊªDöşá„pÏT8éoN‰ÍIŠ5‡ÌR€¡áÈ<“†C¢òğqP>¢IpãáÏÇg|—çñºW™XÆ^ çu-ÉğÈÌjÀğ»±£L³u2ıª×u”¿ÚÁ™QYf¶<ëeı^Şã3‚&ôÄ~ü½Há¾C„BC†c½}gš ©!ÜÃãî+%`òÚ&ùê¦ı1mã&÷¼›ä=1½GÃQæÖª™•à×ÃÌx§C^#Ú”úø~W;kÑ gú'TÙ¸C ¹rÀ=_­ûiÅ·”C)VÉÍ¢ÊíbŸiQ^b|·½–ï¶KG§†½„êt® ŠM®Óå·”'s®N5’˜ÒEC›FKûXƒ¢ïÑÉâªCSZ¹Ò½Hç›º^gñÃhïnİ›†Ê3ÀW[¿Pu*hà†+hÇÓíã˜ÃHá Ù åtóúO¶|ê—t zwSÊÛßà’+ ¤Öô‡Á¼.ö4pLƒ]U‘Gh dsE•+hk ²Uø''­0c€RW˜úÇ1×8–ö›gÄË¥eŒ¦Õ¹{ĞÑæ>b¦”7 >¡~¾·B¯Õ+ôS•¾ŞÔQZĞVíß1VärÏ§w¸zÅà€NÛĞí|Ñ§+r“q•ÎZÒôTïï(økWáÜb‚q 
*™åXÛoÕši½ĞLªå|B)™2’Àÿ~Ëµy¢Ó´2uÓ$ âjbSVçs3îeLrå”¢ÑÀÈh8x½áwˆÔ û®ê^–ôËrYŠ#–ßø “‚Kîf1›eéĞ5since 3.6.0
 * @category comparisons
 */
const isFuture = exports.isFuture = Internal.isFuture;
/**
 * @since 3.6.0
 * @category comparisons
 */
const unsafeIsFuture = exports.unsafeIsFuture = Internal.unsafeIsFuture;
/**
 * @since 3.6.0
 * @category comparisons
 */
const isPast = exports.isPast = Internal.isPast;
/**
 * @since 3.6.0
 * @category comparisons
 */
const unsafeIsPast = exports.unsafeIsPast = Internal.unsafeIsPast;
// =============================================================================
// conversions
// =============================================================================
/**
 * Get the UTC `Date` of a `DateTime`.
 *
 * @since 3.6.0
 * @category conversions
 */
const toDateUtc = exports.toDateUtc = Internal.toDateUtc;
/**
 * Convert a `DateTime` to a `Date`, applying the time zone first.
 *
 * @since 3.6.0
 * @category conversions
 */
const toDate = exports.toDate = Internal.toDate;
/**
 * Calculate the time zone offset of a `DateTime.Zoned` in milliseconds.
 *
 * @since 3.6.0
 * @category conversions
 */
const zonedOffset = exports.zonedOffset = Internal.zonedOffset;
/**
 * Calculate the time zone offset of a `DateTime` in milliseconds.
 *
 * The offset is formatted as "Â±HH:MM".
 *
 * @since 3.6.0
 * @category conversions
 */
const zonedOffsetIso = exports.zonedOffsetIso = Internal.zonedOffsetIso;
/**
 * Get the milliseconds since the Unix epoch of a `DateTime`.
 *
 * @since 3.6.0
 * @category conversions
 */
const toEpochMillis = exports.toEpochMillis = Internal.toEpochMillis;
/**
 * Remove the time aspect of a `DateTime`, first adjusting for the time
 * zone. It will return a `DateTime.Utc` only containing the date.
 *
 * @since 3.6.0
 * @category conversions
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // returns "2024-01-01T00:00:00Z"
 * DateTime.unsafeMakeZoned("2024-01-01T05:00:00Z", {
 *   timeZone: "Pacific/Auckland",
 *   adjustForTimeZone: true
 * }).pipe(
 *   DateTime.removeTime,
 *   DateTime.formatIso
 * )
 * ```
 */
const removeTime = exports.removeTime = Internal.removeTime;
// =============================================================================
// parts
// =============================================================================
/**
 * Get the different parts of a `DateTime` as an object.
 *
 * The parts will be time zone adjusted.
 *
 * @since 3.6.0
 * @category parts
 */
const toParts = exports.toParts = Internal.toParts;
/**
 * Get the different parts of a `DateTime` as an object.
 *
 * The parts will be in UTC.
 *
 * @since 3.6.0
 * @category parts
 */
const toPartsUtc = exports.toPartsUtc = Internal.toPartsUtc;
/**
 * Get a part of a `DateTime` as a number.
 *
 * The part will be in the UTC time zone.
 *
 * @since 3.6.0
 * @category parts
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { DateTime } from "effect"
 *
 * const now = DateTime.unsafeMake({ year: 2024 })
 * const year = DateTime.getPartUtc(now, "year")
 * assert.strictEqual(year, 2024)
 * ```
 */
const getPartUtc = exports.getPartUtc = Internal.getPartUtc;
/**
 * Get a part of a `DateTime` as a number.
 *
 * The part will be time zone adjusted.
 *
 * @since 3.6.0
 * @category parts
 * @example
 * ```ts
 * import * as assert from "node:assert"
 * import { DateTime } from "effect"
 *
 * const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })
 * const year = DateTime.getPart(now, "year")
 * assert.strictEqual(year, 2024)
 * ```
 */
const getPart = exports.getPart = Internal.getPart;
/**
 * Set the different parts of a `DateTime` as an object.
 *
 * The Date will be time zone adjusted.
 *
 * @since 3.6.0
 * @category parts
 */
const setParts = exports.setParts = Internal.setParts;
/**
 * Set the different parts of a `DateTime` as an object.
 *
 * @since 3.6.0
 * @category parts
 */
const setPartsUtc = exports.setPartsUtc = Internal.setPartsUtc;
// =============================================================================
// current time zone
// =============================================================================
/**
 * @since 3.11.0
 * @category current time zone
 */
class CurrentTimeZone extends /*#__PURE__*/Context.Tag("effect/DateTime/CurrentTimeZone")() {}
/**
 * Set the time zone of a `DateTime` to the current time zone, which is
 * determined by the `CurrentTimeZone` service.
 *
 * @since 3.6.0
 * @category current time zone
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   const now = yield* DateTime.now
 *
 *   // set the time zone to "Europe/London"
 *   const zoned = yield* DateTime.setZoneCurrent(now)
 * }).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
 * ```
 */
exports.CurrentTimeZone = CurrentTimeZone;
const setZoneCurrent = self => Effect.map(CurrentTimeZone, zone => setZone(self, zone));
/**
 * Provide the `CurrentTimeZone` to an effect.
 *
 * @since 3.6.0
 * @category current time zone
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")
 *
 * Effect.gen(function* () {
 *   const now = yield* DateTime.nowInCurrentZone
 * }).pipe(DateTime.withCurrentZone(zone))
 * ```
 */
exports.setZoneCurrent = setZoneCurrent;
const withCurrentZone = exports.withCurrentZone = /*#__PURE__*/(0, _Function.dual)(2, (effect, zone) => Effect.provideService(effect, CurrentTimeZone, zone));
/**
 * Provide the `CurrentTimeZone` to an effect, using the system's local time
 * zone.
 *
 * @since 3.6.0
 * @category current time zone
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   // will use the system's local time zone
 *   const now = yield* DateTime.nowInCurrentZone
 * }).pipe(DateTime.withCurrentZoneLocal)
 * ```
 */
const withCurrentZoneLocal = effect => Effect.provideServiceEffect(effect, CurrentTimeZone, Effect.sync(zoneMakeLocal));
/**
 * Provide the `CurrentTimeZone` to an effect, using a offset.
 *
 * @since 3.6.0
 * @category current time zone
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   // will use the system's local time zone
 *   const now = yield* DateTime.nowInCurrentZone
 * }).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))
 * ```
 */
exports.withCurrentZoneLocal = withCurrentZoneLocal;
const withCurrentZoneOffset = exports.withCurrentZoneOffset = /*#__PURE__*/(0, _Function.dual)(2, (effect, offset) => Effect.provideService(effect, CurrentTimeZone, zoneMakeOffset(offset)));
/**
 * Provide the `CurrentTimeZone` to an effect using an IANA time zone
 * identifier.
 *
 * If the time zone is invalid, it will fail with an `IllegalArgumentException`.
 *
 * @since 3.6.0
 * @category current time zone
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   // will use the "Europe/London" time zone
 *   const now = yield* DateTime.nowInCurrentZone
 * }).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
 * ```
 */
const withCurrentZoneNamed = exports.withCurrentZoneNamed = /*#__PURE__*/(0, _Function.dual)(2, (effect, zone) => Effect.provideServiceEffect(effect, CurrentTimeZone, zoneMakeNamedEffect(zone)));
/**
 * Get the current time as a `DateTime.Zoned`, using the `CurrentTimeZone`.
 *
 * @since 3.6.0
 * @category current time zone
 * @example
 * ```ts
 * import { DateTime, Effect } from "effect"
 *
 * Effect.gen(function* () {
 *   // will use the "Europe/London" time zone
 *   const now = yield* DateTime.nowInCurrentZone
 * }).pipe(DateTime.withCurrentZoneNamed("Europe/London"))
 * ```
 */
const nowInCurrentZone = exports.nowInCurrentZone = /*#__PURE__*/Effect.flatMap(now, setZoneCurrent);
// =============================================================================
// mapping
// =============================================================================
/**
 * Modify a `DateTime` by applying a function to a cloned `Date` instance.
 *
 * The `Date` will first have the time zone applied if possible, and then be
 * converted back to a `DateTime` within the same time zone.
 *
 * Supports `disambiguation` when the new wall clock time is ambiguous.
 *
 * @since 3.6.0
 * @category mapping
 */
const mutate = exports.mutate = Internal.mutate;
/**
 * Modify a `DateTime` by applying a function to a cloned UTC `Date` instance.
 *
 * @since 3.6.0
 * @category mapping
 */
const mutateUtc = exports.mutateUtc = Internal.mutateUtc;
/**
 * Transform a `DateTime` by applying a function to the number of milliseconds
 * since the Unix epoch.
 *
 * @since 3.6.0
 * @category mapping
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // add 10 milliseconds
 * DateTime.unsafeMake(0).pipe(
 *   DateTime.mapEpochMillis((millis) => millis + 10)
 * )
 * ```
 */
const mapEpochMillis = exports.mapEpochMillis = Internal.mapEpochMillis;
/**
 * Using the time zone adjusted `Date`, apply a function to the `Date` and
 * return the result.
 *
 * @since 3.6.0
 * @category mapping
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // get the time zone adjusted date in milliseconds
 * DateTime.unsafeMakeZoned(0, { timeZone: "Europe/London" }).pipe(
 *   DateTime.withDate((date) => date.getTime())
 * )
 * ```
 */
const withDate = exports.withDate = Internal.withDate;
/**
 * Using the time zone adjusted `Date`, apply a function to the `Date` and
 * return the result.
 *
 * @since 3.6.0
 * @category mapping
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // get the date in milliseconds
 * DateTime.unsafeMake(0).pipe(
 *   DateTime.withDateUtc((date) => date.getTime())
 * )
 * ```
 */
const withDateUtc = exports.withDateUtc = Internal.withDateUtc;
/**
 * @since 3.6.0
 * @category mapping
 */
const match = exports.match = Internal.match;
// =============================================================================
// math
// =============================================================================
/**
 * Add the given `Duration` to a `DateTime`.
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // add 5 minutes
 * DateTime.unsafeMake(0).pipe(
 *   DateTime.addDuration("5 minutes")
 * )
 * ```
 */
const addDuration = exports.addDuration = Internal.addDuration;
/**
 * Subtract the given `Duration` from a `DateTime`.
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // subtract 5 minutes
 * DateTime.unsafeMake(0).pipe(
 *   DateTime.subtractDuration("5 minutes")
 * )
 * ```
 */
const subtractDuration = exports.subtractDuration = Internal.subtractDuration;
/**
 * Add the given `amount` of `unit`'s to a `DateTime`.
 *
 * The time zone is taken into account when adding days, weeks, months, and
 * years.
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // add 5 minutes
 * DateTime.unsafeMake(0).pipe(
 *   DateTime.add({ minutes: 5 })
 * )
 * ```
 */
const add = exports.add = Internal.add;
/**
 * Subtract the given `amount` of `unit`'s from a `DateTime`.
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // subtract 5 minutes
 * DateTime.unsafeMake(0).pipe(
 *   DateTime.subtract({ minutes: 5 })
 * )
 * ```
 */
const subtract = exports.subtract = Internal.subtract;
/**
 * Converts a `DateTime` to the start of the given `part`.
 *
 * If the part is `week`, the `weekStartsOn` option can be used to specify the
 * day of the week that the week starts on. The default is 0 (Sunday).
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // returns "2024-01-01T00:00:00Z"
 * DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
 *   DateTime.startOf("day"),
 *   DateTime.formatIso
 * )
 * ```
 */
const startOf = exports.startOf = Internal.startOf;
/**
 * Converts a `DateTime` to the end of the given `part`.
 *
 * If the part is `week`, the `weekStartsOn` option can be used to specify the
 * day of the week that the week starts on. The default is 0 (Sunday).
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // returns "2024-01-01T23:59:59.999Z"
 * DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
 *   DateTime.endOf("day"),
 *   DateTime.formatIso
 * )
 * ```
 */
const endOf = exports.endOf = Internal.endOf;
/**
 * Converts a `DateTime` to the nearest given `part`.
 *
 * If the part is `week`, the `weekStartsOn` option can be used to specify the
 * day of the week that the week starts on. The default is 0 (Sunday).
 *
 * @since 3.6.0
 * @category math
 * @example
 * ```ts
 * import { DateTime } from "effect"
 *
 * // returns "2024-01-02T00:00:00Z"
 * DateTime.unsafeMake("2024-01-01T12:01:00Z").pipe(
 *   DateTime.nearest("day"),
 *   DateTime.formatIso
 * )
 * ```
 */
const nearest = exports.nearest = Internal.nearest;
// =============================================================================
// formatting
// =============================================================================
/**
 * Format a `DateTime` as a string using the `DateTimeFormat` API.
 *
 * The `timeZone` option is set to the offset of the time zone.
 *
 * Note: On Node versions < 22, fixed "Offset" zones will set the time zone to
 * "UTC" and use the adjusted `Date`.
 *
 * @since 3.6.0
 * @category formatting
 */
const format = exports.format = Internal.format;
/**
 * Format a `DateTime` as a string using the `DateTimeFormat` API.
 *
 * It will use the system's local time zone & locale.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatLocal = exports.formatLocal = Internal.formatLocal;
/**
 * Format a `DateTime` as a string using the `DateTimeFormat` API.
 *
 * This forces the time zone to be UTC.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatUtc = exports.formatUtc = Internal.formatUtc;
/**
 * Format a `DateTime` as a string using the `DateTimeFormat` API.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatIntl = exports.formatIntl = Internal.formatIntl;
/**
 * Format a `DateTime` as a UTC ISO string.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatIso = exports.formatIso = Internal.formatIso;
/**
 * Format a `DateTime` as a time zone adjusted ISO date string.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatIsoDate = exports.formatIsoDate = Internal.formatIsoDate;
/**
 * Format a `DateTime` as a UTC ISO date string.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatIsoDateUtc = exports.formatIsoDateUtc = Internal.formatIsoDateUtc;
/**
 * Format a `DateTime.Zoned` as a ISO string with an offset.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatIsoOffset = exports.formatIsoOffset = Internal.formatIsoOffset;
/**
 * Format a `DateTime.Zoned` as a string.
 *
 * It uses the format: `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]`.
 *
 * @since 3.6.0
 * @category formatting
 */
const formatIsoZoned = exports.formatIsoZoned = Internal.formatIsoZoned;
/**
 * Create a Layer from the given time zone.
 *
 * @since 3.6.0
 * @category current time zone
 */
const layerCurrentZone = zone => Layer.succeed(CurrentTimeZone, zone);
/**
 * Create a Layer from the given time zone offset.
 *
 * @since 3.6.0
 * @category current time zone
 */
exports.layerCurrentZone = layerCurrentZone;
const layerCurrentZoneOffset = offset => Layer.succeed(CurrentTimeZone, Internal.zoneMakeOffset(offset));
/**
 * Create a Layer from the given IANA time zone identifier.
 *
 * @since 3.6.0
 * @category current time zone
 */
exports.layerCurrentZoneOffset = layerCurrentZoneOffset;
const layerCurrentZoneNamed = zoneId => Layer.effect(CurrentTimeZone, Internal.zoneMakeNamedEffect(zoneId));
/**
 * Create a Layer from the systems local time zone.
 *
 * @since 3.6.0
 * @category current time zone
 */
exports.layerCurrentZoneNamed = layerCurrentZoneNamed;
const layerCurrentZoneLocal = exports.layerCurrentZoneLocal = /*#__PURE__*/Layer.sync(CurrentTimeZone, zoneMakeLocal);
//# sourceMappingURL=DateTime.js.map