import deepEqual = require("deep-eql");
import { AssertionError as ImportedAssertionError } from "assertion-error";

declare global {
    namespace Chai {
        export type Message = string | (() => string);
        export type ObjectProperty = string | symbol | number;

        export interface PathInfo {
            parent: object;
            name: string;
            value?: any;
            exists: boolean;
        }

        export interface Constructor<T> {
            new(...args: any[]): T;
        }

        export interface ErrorConstructor {
            new(...args: any[]): Error;
        }

        export interface ChaiUtils {
            addChainableMethod(
                // object to define the method on, e.g. chai.Assertion.prototype
                ctx: object,
                // method name
                name: string,
                // method itself; any arguments
                method: (...args: any[]) => void,
                // called when property is accessed
                chainingBehavior?: () => void,
            ): void;
            overwriteChainableMethod(
                ctx: object,
                name: string,
                method: (...args: any[]) => void,
                chainingBehavior?: () => void,
            ): void;
            addLengthGuard(
                fn: Function,
                assertionName: string,
                isChainable: boolean,
            ): void;
            addMethod(ctx: object, name: string, method: Function): void;
            addProperty(ctx: object, name: string, getter: () => any): void;
            overwriteMethod(ctx: object, name: string, method: Function): void;
            overwriteProperty(ctx: object, name: string, getter: (this: AssertionStatic, _super: any) => any): void;
            compareByInspect(a: object, b: object): -1 | 1;
            expectTypes(obj: object, types: string[]): void;
            flag(obj: object, key: string, value?: any): any;
            getActual(obj: object, args: AssertionArgs): any;
            getProperties(obj: object): string[];
            getEnumerableProperties(obj: object): string[];
            getOwnEnumerablePropertySymbols(obj: object): symbol[];
            getOwnEnumerableProperties(obj: object): Array<string | symbol>;
            getMessage(errorLike: Error | string): string;
            getMessage(obj: any, args: AssertionArgs): string;
            inspect(obj: any, showHidden?: boolean, depth?: number, colors?: boolean): string;
            isProxyEnabled(): boolean;
            objDisplay(obj: object): void;
            proxify(obj: object, nonChainableMethodName: string): object;
            test(obj: object, args: AssertionArgs): boolean;
            transferFlags(assertion: Assertion, obj: object, includeAll?: boolean): void;
            compatibleInstance(thrown: Error, errorLike: Error | ErrorConstructor): boolean;
            compatibleConstructor(thrown: Error, errorLike: Error | ErrorConstructor): boolean;
            compatibleMessage(thrown: Error, errMatcher: string | RegExp): boolean;
            getConstructorName(constructorFn: Function): string;
            getFuncName(constructorFn: Function): string | null;

            // Reexports from pathval:
            hasProperty(obj: object | undefined | null, name: ObjectProperty): boolean;
            getPathInfo(obj: object, path: string): PathInfo;
            getPathValue(obj: object, path: string): object | undefined;

            eql: typeof deepEqual;
        }

        export type ChaiPlugin = (chai: ChaiStatic, utils: ChaiUtils) => void;

        export interface ChaiStatic {
            expect: ExpectStatic;
            should(): Should;
            /**
             * Provides a way to extend the internals of Chai
             */
            use(fn: ChaiPlugin): ChaiStatic;
            util: ChaiUtils;
            assert: AssertStatic;
            config: Config;
            Assertion: AssertionStatic;
            AssertionError: typeof AssertionError;
            version: string;
        }

        export interface ExpectStatic {
            (val: any, message?: string): Assertion;
            fail(message?: string): never;
            fail(actual: any, expected: any, message?: string, operator?: Operator): never;
        }

        export interface AssertStatic extends Assert {
        }

        // chai.Assertion.prototype.assert arguments
        export type AssertionArgs = [
            any, // expression to be tested
            Message, // message or function that returns message to display if expression fails
            Message, // negatedMessage or function that returns negatedMessage to display if expression fails
            any?, // expected value
            any?, // actual value
            boolean?, // showDiff, when set to `true`, assert will display a diff in addition to the message if expression fails
        ];

        export interface AssertionPrototype {
            assert(...args: AssertionArgs): void;
            _obj: any;
        }

        export interface AssertionStatic extends AssertionPrototype {
            prototype: AssertionPrototype;

            new(target: any, message?: string, ssfi?: Function, lockSsfi?: boolean): Assertion;

            // Deprecated properties:
            includeStack: boolean;
            showDiff: boolean;

            // Partials of functions on ChaiUtils:
            addProperty(name: string, getter: (this: AssertionStatic) => any): void;
            addMethod(name: string, method: (this: AssertionStatic, ...args: any[]) => any): void;
            addChainableMethod(
                name: string,
                method: (this: AssertionStatic, ...args: any[]) => void,
                chainingBehavior?: () => void,
            ): void;
            overwriteProperty(name: string, getter: (this: AssertionStatic, _super: any) => any): void;
            overwriteMethod(name: string, method: (this: AssertionStatic, ...args: any[]) => any): void;
            overwriteChainableMethod(
                name: string,
                method: (this: AssertionStatic, ...args: any[]) => void,
                chainingBehavior?: () => void,
            ): void;
        }

        export type Operator = string; // "==" | "===" | ">" | ">=" | "<" | "<=" | "!=" | "!==";

        export type OperatorComparable = boolean | null | number | string | undefined | Date;

        export interface ShouldAssertion {
            equal(value1: any, value2: any, message?: string): void;
            Throw: ShouldThrow;
            throw: ShouldThrow;
            exist(value: any, message?: string): void;
        }

        export interface Should extends ShouldAssertion {
            not: ShouldAssertion;
            fail(message?: string): never;
            fail(actual: any, expected: any, message?: string, operator?: Operator): never;
        }

        export interface ShouldThrow {
            (actual: Function, expected?: string | RegExp, message?: string): void;
            (actual: Function, constructor: Error | Function, expected?: string | RegExp, message?: string): void;
        }

        export interface Assertion extends LanguageChains, NumericComparison, TypeComparison {
            not: Assertion;
            deep: Deep;
            ordered: Ordered;
            nested: Nested;
            own: Own;
            any: KeyFilter;
            all: KeyFilter;
            a: Assertion;
            an: Assertion;
            include: Include;
            includes: Include;
            contain: Include;
            contains: Include;
            ok: Assertion;
            true: Assertion;
            false: Assertion;
            null: Assertion;
            undefined: Assertion;
            NaN: Assertion;
            exist: Assertion;
            empty: Assertion;
            arguments: Assertion;
            Arguments: Assertion;
            finite: Assertion;
            equal: Equal;
            equals: Equal;
            eq: Equal;
            eql: Equal;
            eqls: Equal;
            containSubset: ContainSubset;
            property: Property;
            ownProperty: Property;
            haveOwnProperty: Property;
            ownPropertyDescriptor: OwnPropertyDescriptor;
            haveOwnPropertyDescriptor: OwnPropertyDescriptor;
            length: Length;
            lengthOf: Length;
            match: Match;
            matches: Match;
            string(string: string, message?: string): Assertion;
            keys: Keys;
            key(string: string): Assertion;
            throw: Throw;
            throws: Throw;
            Throw: Throw;
            respondTo: RespondTo;
            respondsTo: RespondTo;
            itself: Assertion;
            satisfy: Satisfy;
            satisfies: Satisfy;
            closeTo: CloseTo;
            approximately: CloseTo;
            members: Members;
            increase: PropertyChange;
            increases: PropertyChange;
            decrease: PropertyChange;
            decreases: PropertyChange;
            change: PropertyChange;
            changes: PropertyChange;
            extensible: Assertion;
            sealed: Assertion;
            frozen: Assertion;
            oneOf: OneOf;
        }

        export interface LanguageChains {
            to: Assertion;
            be: Assertion;
            been: Assertion;
            is: Assertion;
            that: Assertion;
            which: Assertion;
            and: Assertion;
            has: Assertion;
            have: Assertion;
            with: Assertion;
            at: Assertion;
            of: Assertion;
            same: Assertion;
            but: Assertion;
            does: Assertion;
        }

        export interface NumericComparison {
            above: NumberComparer;
            gt: NumberComparer;
            greaterThan: NumberComparer;
            least: NumberComparer;
            gte: NumberComparer;
            greaterThanOrEqual: NumberComparer;
            below: NumberComparer;
            lt: NumberComparer;
            lessThan: NumberComparer;
            most: NumberComparer;
            lte: NumberComparer;
            lessThanOrEqual: NumberComparer;
            within(start: number, finish: number, message?: string): Assertion;
            within(start: Date, finish: Date, message?: string): Assertion;
        }

        export interface NumberComparer {
            (value: number | Date, message?: string): Assertion;
        }

        export interface TypeComparison {
            (type: string, message?: string): Assertion;
            instanceof: InstanceOf;
            instanceOf: InstanceOf;
        }

        export interface InstanceOf {
            (constructor: any, message?: string): Assertion;
        }

        export interface CloseTo {
            (expected: number, delta: number, message?: string): Assertion;
        }

        export interface Nested {
            include: Include;
            includes: Include;
            contain: Include;
            contains: Include;
            property: Property;
            members: Members;
        }

        export interface Own {
            include: Include;
            includes: Include;
            contain: Include;
            contains: Include;
            property: Property;
        }

        export interface Deep extends KeyFilter {
            be: Assertion;
            equal: Equal;
            equals: Equal;
            eq: Equal;
            include: Include;
            includes: Include;
            contain: Include;
            contains: Include;
            property: Property;
            ordered: Ordered;
            nested: Nested;
            oneOf: OneOf;
            own: Own;
        }

        export interface Ordered {
            members: Members;
        }

        export interface KeyFilter {
            keys: Keys;
            members: Members;
        }

        export interface Equal {
            (value: any, message?: string): Assertion;
        }

        export interface ContainSubset {
            (expected: any): Assertion;
        }

        export interface Property {
            (name: string | symbol, value: any, message?: string): Assertion;
            (name: string | symbol, message?: string): Assertion;
        }

        export interface OwnPropertyDescriptor {
            (name: string | symbol, descriptor: PropertyDescriptor, message?: string): Assertion;
            (name: string | symbol, message?: string): Assertion;
        }

        export interface Length extends LanguageChains, NumericComparison {
            (length: number, message?: string): Assertion;
        }

        export interface Include {
            (value: any, message?: string): Assertion;
            keys: Keys;
            deep: Deep;
            ordered: Ordered;
            members: Members;
            any: KeyFilter;
            all: KeyFilter;
            oneOf: OneOf;
        }

        export interface OneOf {
            (list: readonly unknown[], message?: string): Assertion;
        }

        export interface Match {
            (regexp: RegExp, message?: string): Assertion;
        }

        export interface Keys {
            (...keys: string[]): Assertion;
            (keys: readonly any[] | Object): Assertion;
        }

        export interface Throw {
            (expected?: string | RegExp, message?: string): Assertion;
            (constructor: Error | Function, expected?: string | RegExp, message?: string): Assertion;
        }

        export interface RespondTo {
            (method: string, message?: string): Assertion;
        }

        export interface Satisfy {
            (matcher: Function, message?: string): Assertion;
        }

        export interface Members {
            (set: readonly any[], message?: string): Assertion;
        }

        export interface PropertyChange {
            (object: Object, property?: string, message?: string): DeltaAssertion;
        }

        export interface DeltaAssertion extends Assertion {
            by(delta: number, msg?: string): Assertion;
        }

        export interface Assert {
            /**
             * @param expression    Expression to test for truthiness.
             * @param message    Message to display on error.
             */
            (expression: any, message?: string): asserts expression;

            /**
             * Throws a failure.
             *
             * @param message    Message to display on error.
             * @remarks Node.js assert module-compatible.
             */
            fail(message?: string): never;

            /**
             * Throws a failure.
             *
             * T   Type of the objects.
             * @param actual   Actual value.
             * @param expected   Potential expected value.
             * @param message    Message to display on error.
             * @param operator   Comparison operator, if not strict equality.
             * @remarks Node.js assert module-compatible.
             */
            fail<T>(actual: T, expected: T, message?: string, operator?: Operator): never;

            /**
             * Asserts that object is truthy.
             *
             * @param object   Object to test.
             * @param message    Message to display on error.
             */
            isOk(value: unknown, message?: string): asserts value;

            /**
             * Asserts that object is truthy.
             *
             * @param object   Object to test.
             * @param message    Message to display on error.
             */
            ok(value: unknown, message?: string): asserts value;

            /**
             * Asserts that object is falsy.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param message    Message to display on error.
             */
            isNotOk<T>(value: T, message?: string): void;

            /**
             * Asserts that object is falsy.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param message    Message to display on error.
             */
            notOk<T>(value: T, message?: string): void;

            /**
             * Asserts non-sL‰}ˆHUˆHMèãïÿAwuI‹º   I‹ÏH‹ ÿ½Ù5 H‹MàH…ÉtÿU×5 Hƒeà H‹MøH…ÉtÿA×5 Hƒeø H‹L$`H…ÉtquH‹º   H‹ ÿtÙ5 IÿÄL;e L‹mL‹½ˆ   …µıÿÿ¹8   èN<4 H‰E°LEI‹U H‹ÈèãûÿH‹ØH‰E HU H‹Ïès›ûÿH…Ût'@ ff„     suH‹º   H‹ËH‹ ÿÿØ5 L‹uxI‰>HMè{ÔíÿH‹€   H…ÉtquH‹º   H‹ ÿÍØ5 H‹M€H…ÉtquH‹º   H‹ ÿ­Ø5 H‹M¸H…É„U  ÿAÖ5 éJ  H‹M¸H…Étÿ-Ö5 ¾   ‹Îèu;4 H‹øH‰…€   I‹H‹QL‰ L‰`H‰PH‹ÈèuÙíÿ„À„Ş  WÀóD$p‹ÎÿôÕ5 H…ÀuÿaÔ5 ÌÇ@   Ç@   HÓR6 H‰H‰xH‰|$pH‰D$xI‹L‹hƒÎÿM…í„ó  I‹H‹8J‹<çH‰|$`H…ÿtÿG‹GÁè$H‹¹óF HEÇH‰EH…Àtÿ@H‹EH…À„R  I‹Oè¢îÿE3ÉLEHU˜H‹ètª ‹GÁè$„ô   ƒT…ê   H‹ÏèKÚğÿI‹WHÂh  E3ÀH‹è9Áïÿ„À„Ä   ƒ¥€    H‹ÏèúÙğÿH‹ H‰EˆH…Àtÿ@I‹Oè^‹îÿL…€   HUˆH‹èm ƒ½€    tbM‹GIÀh  HUˆHM èV’ğÿH‹Hƒ  H‰L$`H…ÿtwuH‹º   H‹ÏH‹ ÿÔÖ5 H‹M H…ÉtquH‹º   H‹ ÿµÖ5 H‹MˆH…ÉtquH‹º   H‹ ÿ•Ö5 HU˜HL$`èKßïÿH‹M˜H…ÉtquH‹º   H‹ ÿgÖ5 H‹|$`LD$`H‹L$pH‹QèØíÿH‹MH…ÉtquH‹º   H‹ ÿ/Ö5 H…ÿtwuH‹º   H‹ÏH‹ ÿÖ5 IÿÄM;å…şÿÿH‹½    Ç   Š…¸   ˆD$PÇD$H   ÇD$@   DŠ­¨   Dˆl$8H‰|$0L‹µ˜   L‰t$(DŠ¥   Dˆd$ L‹ˆ   LD$pHU¨I‹Ïè¨  HL$hH;ÈtH‹H‰\$hHƒ  H‹M¨H…ÉtquH‹º   H‹ ÿgÕ5 H…Ût
€{1 „Å  Ç   Š…¸   ˆD$PÇD$H   ÇD$@   Dˆl$8H‰|$0L‰t$(Dˆd$ L‹ˆ   LD$pHU(I‹Ïè  L‹ğHD$hI;Æt*H…ÛtsuH‹H‹º   H‹ËÿáÔ5 I‹H‰\$hIƒ& H‹M(H…ÉtquH‹º   H‹ ÿ¶Ô5 H…Ût
€{1 „  Ç   Š…¸   ˆD$PÇD$H   ÇD$@   Dˆl$8H‰|$0H‹…˜   H‰D$(Dˆd$ L‹ˆ   LD$pHUĞI‹Ïè`  L‹ğHD$hI;Æt*H…ÛtsuH‹H‹º   H‹Ëÿ)Ô5 I‹H‰\$hIƒ& H‹MĞH…ÉtquH‹º   H‹ ÿşÓ5 H…Ût
€{1 „\  Ç   ÆD$@ Dˆl$8H‰|$0H‹…˜   H‰D$(Dˆd$ L‹ˆ   L‹D$pHU°I‹Ïè¡  L‹ğHD$hI;Æt*H…ÛtsuH‹H‹º   H‹Ëÿ†Ó5 I‹H‰\$hIƒ& H‹M°H…ÉtquH‹º   H‹ ÿ[Ó5 3ÉH…Ût	8K1„¸   E„ä…¯   Ç   Š…¸   ˆD$PÇD$H   ‰L$@Dˆl$8H‰|$0L‹¥˜   L‰d$(ˆL$ L‹ˆ   LD$pHUØI‹Ïè   L‹ğHD$hI;Æt*H…ÛtsuH‹H‹º   H‹ËÿÉÒ5 I‹H‰\$hIƒ& H‹MØH…ÉtquH‹º   H‹ ÿÒ5 H…ÛtT€{1 uNL‹uxI‰H‹\$xH…Ût8‹ÆğÁCÆu-H‹L$xH‹H‹ ÿfÒ5 ‹ÆğÁCÆuH‹H‹ËH‹@ÿKÒ5 é¸   Ç   ¶¸   ‹ÁƒğƒÀˆL$P‰D$HÇD$@   Dˆl$8H‰|$0L‰d$(ÆD$  L‹ˆ   LD$pL‹uxI‹ÖI‹Ïèı   H‹|$xH…ÿt<‹ÆğÁGÆu,H‹L$xH‹H‹ ÿËÑ5 ‹ÆğÁGÆuH‹H‹ÏH‹@ÿ°Ñ5 H‹\$hH…ÛtsuH‹º   H‹ËH‹ ÿÑ5 I‹ÆH‹œ$p  HÄ0  A_A^A]A\_^]ÃÇ…°    €Hşå; H°   è?4 Ç…°    €Hàå; H°   è ?4 Ç…°    €HÂå; H°   èâ>4 Ç…°    €H¤å; H°   èÄ>4 ÌH‹ÄL‰H L‰@H‰PH‰HUSVWATAUAVAWHl$¨HìX  M‹áM‹èH‹úL‹ùH‹IèøJîÿE3ö„ÀtL‰7H‹ÇéÉ   I‹_HÃ0  WÀóE ¹   ÿ<Î5 H‹ğH‰EèH…Àuÿ¢Ì5 ÌÇ@   Ç@   Hü{6 H‰H‰^H‰] H‰u(I‹OèÌIîÿLkÈD‹I‹OA@üHcĞH¯‘ğ  A@‰I;Ñ~ZL‰7HƒÏÿ‹ÇğÁFÇu*H‹H‹ÎH‹ ÿşÏ5 ‹ÇğÁFÇuH‹H‹ÎH‹@ÿãÏ5 L‹½¨   I‹ÇHÄX  A_A^A]A\_^[]ÃA¾   A‹Îè³24 H‹Ø3ÿH‰8H‰xH‰xWÀóE0A‹ÎÿNÍ5 L‹ğH…Àuÿ¸Ë5 ÌÇ@   Ç@   H*J6 I‰I‰^H‰]0L‰u8H‰}¸H‰}ÀH‰}ÈH‰}ĞH‰}ØH‰}à»   ‹Ëè;24 H‹ø3ÀH‰H‰GH‰GWÀóD$p‹ËÿÖÌ5 H‹ØH…Àuÿ@Ë5 ÌÇC   ÇC   H²I6 H‰H‰{H‰|$pH‰\$xHƒÏÿ‹…à   ;…è   „{  3ÛHL$pH‰L$(HM¸H‰L$ M‹ÌM‹Å‹ĞI‹Ïè¨ÿÿ„À„  A½   Dˆl$`H‹L$pH‹YI+İE3äH;ß„   H‹I‹WHÂ  E3ÀH‹ØèA¸ïÿ„ÀtVH‹D$pH‹H‹ÙH‹H‹€0  ÿIÎ5 L9 u5H‹D$pH‹H‹ÙH‹H‹€8  ÿ(Î5 L9 uH‹ÓH‹L$pè¶Û  H‹L$pë"H‹L$pH‹H‹Ø‹BÁèA"ÅtƒzTtDˆd$`I+İéYÿÿÿA¿   A‹ÏèÓ04 H‹ØH‰E@H‹L$pH‹QL‰ L‰`H‰PH‹ÈèÔÎíÿ„À„t  WÀóEA‹ÏÿSË5 3ÒH…À„Q  D‰hD‰hH9H6 H‰H‰XH‰]H‰E˜D‹úH‹D$pL‹`M…ätUH‹]H‹ HUğJ‹øè=¼ïÿL‹ÀH‹SH‹ËèòÎíÿH‹MğH…ÉtyuH‹A‹ÕH‹ ÿ!Í5 MıM;ütH‹D$pë±H‹uè3ÒWÀóE¨L‹½    ƒ½à   uQI‹_D9kuG¹   ÿ—Ê5 L‹è3ÒH…À„‹  Ç@   Ç@   HLw6 I‰E I‰]H‰]¨L‰m°I‹O‰QëL‹m°H‰T$h8T$`„¶   DŠ¥ğ   Dˆd$HˆT$@Š…Ø   ˆD$8H‹…Ğ   H‰D$0H‹…È   H‰D$(Š…À   ˆD$ LM¸LEHUøI‹Ïè(ìÿÿH‹ØHD$hH;Ãt-H‹L$hH…ÉtyuH‹H‹º   ÿÌ5 H‹H‰D$h3ÀH‰H‹Mø3ÛH…É„¹  y…°  H‹SH‹ ÿßË5 éœ  I‹GH‹€  H‰EˆH…Àtÿ@H‹EL‹`H‹ÚM…ä„   3öH‹EH‹LÙHUˆHM èEgğÿL‹øHEˆI;Çt)H‹MˆH…ÉtyuH‹H‹º   ÿjË5 I‹H‰EˆI‰7H‹M H…ÉtyuH‹º   H‹ ÿAË5 HÿÃI;ÜuŒH‹uèL‹½    I‹OèîÿH‹H‹E¸E3äDˆd$(Dˆd$ D‹LEˆHU èYñ  H‹M H…ÉtuDˆd$ M‹OLE¸HU HMè»ûÿH‹ØHD$hH;Ãt+H‹L$hH…ÉtyuH‹H‹AT$ÿ°Ê5 H‹H‰D$hL‰#H‹MH…ÉtyuH‹º   H‹ ÿ†Ê5 H‹M H…ÉtyuH‹º   H‹ ÿgÊ5 H‹MˆH…ÉtyuH‹º   H‹ ÿGÊ5 DŠ¥ğ   3ÛH‹L$hH…É„ê  8Y1…á  E3ÉE3ÀI‹WètûÿM‹GHT$hHMèÈ H‹ØHD$hH;Ãt/H‹L$hH…ÉtyuH‹H‹º   ÿÙÉ5 H‹H‰D$h3ÀH‰ë3ÀH‹MH…ÉtyuH‹º   H‹ ÿ©É5 3ÀH‰E¨I‹İL‹èH‰E°H…Ût9‹ÇğÁCÇu*H‹H‹ËH‹ ÿzÉ5 ‹ÇğÁCÇuH‹H‹ËH‹@ÿ_É5 L‹m°Dˆd$PŠ…Ø   ˆD$HH‹…Ğ   H‰D$@H‹…È   H‰D$8Š…À   ˆD$0L‹¥¸   L‰d$(HE¸H‰D$ LL$hLD$pHUI‹Ïè³xÿÿH‹ØHD$hH;Ãt-H‹L$hH…ÉtyuH‹H‹º   ÿÒÈ5 H‹H‰D$h3ÀH‰H‹MH…ÉtyuH‹º   H‹ ÿ¦È5 H‹L$hH…É„Y  H‹EÀE3äH…ÀIEÄH‰EÀ3ÒHM¸èËíÿHMĞèúëôÿH‹D$hL‹½¨   I‰L‰d$hH‹]˜H…Ût7‹ÇğÁCÇu,H‹M˜H‹H‹ ÿ:È5 ‹ÇğÁCÇuH‹H‹ËH‹@ÿÈ5 H‹\$xH…Ût8‹ÇğÁCÇu-H‹L$xH‹H‹ ÿøÇ5 ‹ÇğÁCÇuH‹H‹ËH‹@ÿİÇ5 HMĞè_ÃíÿH‹M¸H…Ét
ÿlÅ5 L‰e¸‹ÇğAÁFÇu,I‹I‹ÎH‹ ÿ¥Ç5 ‹ÇğAÁFÇuI‹I‹ÎH‹@ÿ‰Ç5 ‹ÇğÁFÇ…÷ÿÿH‹H‹ÎH‹ ÿjÇ5 ‹ÇğÁFÇ…÷ÿÿH‹H‹ÎH‹@ÿKÇ5 éj÷ÿÿL‹¥¸   H…ÉtyuH‹º   H‹ ÿ$Ç5 M…ít<‹ÇğAÁEÇu0H‹]°H‹H‹ËH‹ ÿÿÆ5 ‹ÇğÁCÇuH‹M°H‹H‹@ÿãÆ5 H‹]˜H…Ût6‹ÇğÁCÇu+H‹M˜H‹H‹ ÿ¾Æ5 ‹ÇğÁCÇuH‹H‹ËH‹@ÿ£Æ5 3ÛL‹­°   H‹EÀH…ÀHEÃH‰EÀ3ÒHM¸èÉíÿHMĞèÿéôÿ‹…à   ÿÀ‰…à   ;…è   …Œ÷ÿÿH‹\$xL‹½¨   E3äM‰'é-şÿÿÿpÂ5 ÿiÂ5 Ç…     €HÇÚ; H    èç34 Ì@SHƒì H‹ÙHƒÁè’ÁíÿH‹H…Ét
ÿ Ã5 Hƒ# HƒÄ [ÃH‹ÄH‰XH‰pD‰H UWAUAVAWHh±Hì   M‹øH‹úH‹ñA¾   €y t€y tA¾   ¹   è›(4 H‹ØH‰EWHƒ  Hƒ` A½   L‰hA‹ÕH‹ÈèšÆíÿ„À„I  WÀóE÷AMÿÃ5 H…Àuÿ…Á5 ÌD‰hD‰hHı?6 H‰H‰XH‰]÷H‰EÿM‹ÇH‹SH‹ËèÛÆíÿHƒe Hƒe L‰mI‹ÕHMè™Çíÿ„À„Ä   HUoHMèTÁíÿAƒş”ÀˆD$PD‰t$Hƒd$@ ÆD$8 HEH‰D$0Hƒd$( ÆD$  LMLE÷H‹×H‹ÎèÃóÿÿH‹MH…ÉtÿOÂ5 Hƒe H‹]ÿH…Ût9ƒÎÿ‹ÆğÁCÆu+H‹MÿH‹H‹ ÿ{Ä5 ‹ÆğÁCÆuH‹H‹ËH‹@ÿ`Ä5 H‹ÇLœ$   I‹[8I‹s@I‹ãA_A^A]_]ÃÇEw €HÓØ; HMwèö14 ÇEw €H»Ø; HMwèŞ14 ÌH‹ÄL‰H L‰@H‰PH‰HUSVWATAUAVAWH¨XşÿÿHìh  I‹øL‹âL‹ùE3íD‰l$@Š…è  ˆAAMH‹…à  ‰I‹PH…Ò„5  L!m@L!mHH‰UPHM@èºÄíÿ„À„ú4  2Ò‰T$h@2ö@ˆµè  MGL‰D$XI‹ H‹ˆ  H‰L$pEUH…ÉtDQI‹ H‹ˆ  H‰L$xH…ÉtDQ3ÛH‰]€H‹GH‰E H…À„O  L‹½Ø   H‹uXL‹uÀHƒd$H Hƒd$P H‹H‹Ø‹AÁèA"ÂL‹äŞF LEÉL‰L$`M…Ét	EQL‹L$`M…É„‘  I‹ ¿   9xu I‹W I‹ÉH‹@Hÿ¼Â5 „À… 
  L‹D$XI‹èƒtîÿE3ÉLD$`HUØH‹Èè[¨ AƒÍD‰l$@H‹8H‰½Ğ   Hƒ  A¼   AöÅt(AƒåıD‰l$@H‹MØH…ÉtD)auH‹A‹ÔH‹ ÿIÂ5 E„ìt'AƒåşD‰l$@M…ÿtAƒouI‹A‹ÔI‹ÏH‹ ÿÂ5 ‹GÁèA"Ät‹D$h¶Àƒ8ADÄ‰D$hH‹L$`èÈÄğÿH‹‹AÁèA"Ät=H‹L$`è°ÄğÿH‹H‹I8è Sõÿ„Àt#H‹L$`èrÄğÿH‹0H‰uXH…ötDfAƒÍH‹Æë<H‹L$`èsÄğÿH‹ØH‹L$`èBÄğÿL‹ÃH‹ĞHM¸èëğÿL‹0L‰uÀHƒ  AƒÍI‹ÆH‹]€D‰l$@H…ÀtD`H‹L$PH‰D$PH…ÉtƒiuH‹A‹ÔH‹ ÿ;Á5 AöÅt'AƒåïD‰l$@M…ötAƒnuI‹A‹ÔI‹ÎH‹ ÿÁ5 AöÅt(Aƒå÷D‰l$@H‹M¸H…ÉtƒiuH‹A‹ÔH‹ ÿáÀ5 AöÅt&AƒåûD‰l$@H…ötƒnuH‹A‹ÔH‹ÎH‹ ÿ´À5 L‹¥À  I‹$H‹ØH‹H‹€8  ÿ•À5 H‹ĞHL$PèLÉïÿI‹$H‹ØH‹H‹€0  ÿpÀ5 L‹À3ÛH9„¥   H‹L$PH…É„—   H‹H‹‚x  ˆ\$(ˆ\$ L«ÛF HUˆÿ1À5 H‹MˆH‹3ÒH‹€˜  ÿÀ5 H‹MˆH‹ÁH…ÉtÿAH‹MˆL‹D$PH‰D$PM…ÀtAƒhuI‹ º   I‹ÈH‹ ÿİ¿5 H‹MˆH…ÉtƒiuH‹º   H‹ ÿ½¿5 L‹d$XI‹$è‹qîÿˆ\$ A±LD$PHUhH‹Èè§m H‹ØHD$HH;Ãt-H‹L$HH…ÉtƒiuH‹H‹º   ÿi¿5 H‹H‰D$HHƒ# H‹MhH…ÉtƒiuH‹º   H‹ ÿ=¿5 ƒe˜ H‹L$`èßÁğÿH‹‹AÁè$t!H‹L$`èìÁğÿH‹H‹ƒÊÿH‹@Xÿ¿5 „Àt(I‹$èÔpîÿÆD$(Hƒd$  E3ÉLE˜HT$HH‹ÈèéJ I‹$è¬pîÿE3ÉLD$HHU`H‹Èè„¤ H‹ØHD$HH;Ãt-H‹L$HH…ÉtƒiuH‹H‹º   ÿ¾5 H‹H‰D$HHƒ# H‹M`»   H…Ét)YuH‹‹ÓH‹ ÿa¾5 I‹$9Y…²   ƒe H‹D$HH‰…ˆ   H…ÀtXI‹$H)×F H‰…   èpîÿLEH•ˆ   H‹Èèâx ƒ} tAL‹…ˆ   I‹ÈM…ÀtAXL‹…ˆ   L‹L$HH‰L$HM…Ét$AƒiuI‹‹ÓI‹ÉH‹ ÿË½5 L‹…ˆ   H‹L$HM…ÀtAƒhuI‹ ‹ÓI‹ÈH‹ ÿ¢½5 H‹L$H‹AÁè	"Ã„,  ƒyT…"  H‹3ÒH‹€ğ  ÿs½5 H‹‹AÁè"Ã„ÿ   H‹L$HH‹3ÒH‹€ğ  ÿK½5 H‹H‹I8èNõÿ„À…Ô   H‹L$HH‹A@ƒx…Ø   H‹‹ÓH‹€ğ  ÿ½5 H‹ H‰EĞH…ÀtXH‹L$HH‹H‹€8  ÿî¼5 H‹ØH‹L$HH‹H‹‚0  ÿÖ¼5 ƒd$( ÆD$  E3ÉL‹ÃH‹ĞHMĞèV©ïÿH‹]ĞH…ÛtÿCH‹L$HH‰\$HH…ÉtƒiuH‹º   H‹ ÿˆ¼5 H…ÛtƒkuH‹º   H‹ËH‹ ÿh¼5 »   ƒo…G  H‹‹ÓH‹Ïé1  ¹ˆ   è>4 H‰…È   LD$H3ÒH‹Èè°sñÿH‰EÈH‰…À   AºíD‰l$@H‹L‹¡H  H‹L$HH‹H‹‚  ÿø»5 ‹ØH‹L$HH‹H‹‚0  ÿá»5 D‹ÃH‹ĞH‹MÈI‹ÄÿÎ»5 L‹eÈI‹$H‹˜X  H‹L$HH‹H‹‚8  ÿª»5 H‹ĞI‹ÌH‹Ãÿ›»5 »   A\$H‹L$HL‰d$HH…Ét)YuH‹‹ÓH‹ ÿo»5 Aƒl$…ÿşÿÿI‹$‹ÓI‹ÌH‹ ÿP»5 éèşÿÿH‹L‹ØM…Àt	EPL‹L$`H‹L$HL‰D$HH…ÉtƒiuH‹A‹ÒH‹ ÿ»5 L‹D$HL‹L$`E‹PA‹ÂÁè¿   @"ÇA‹Â…T  Áè@"Ç„ú   I‹H8è(Lõÿ„À„é   H‹L$PH‹H‹€0  ÿ»º5 L‹ÀHT$xHM°èZVğÿH‹ØHD$xH;Ãt)H‹L$xH…Ét)yuH‹H‹‹×ÿ€º5 H‹H‰D$xHƒ# H‹M°H…Ét)yuH‹‹×H‹ ÿXº5 H‹L$PH‹H‹€8  ÿCº5 L‹ÀHT$pHMàèâUğÿH‹ØHD$pH;Ãt)H‹L$pH…Ét)yuH‹H‹‹×ÿº5 H‹H‰D$pHƒ# H‹MàH…É„S  )yé& ual value.
             * @param message    Message to display on error.
             */
            notExists(value: unknown, message?: string): asserts value is
                | null
                | undefined;

            /**
             * Asserts that value is undefined.
             *
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isUndefined(value: unknown, message?: string): asserts value is undefined;

            /**
             * Asserts that value is not undefined.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isDefined<T>(value: T, message?: string): asserts value is Exclude<T, undefined>;

            /**
             * Asserts that value is a function.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isFunction<T>(value: T, message?: string): void;

            /**
             * Asserts that value is not a function.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNotFunction<T>(value: T, message?: string): void;

            /**
             * Asserts that value is an object of type 'Object'
             * (as revealed by Object.prototype.toString).
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             * @remarks The assertion does not match subclassed objects.
             */
            isObject<T>(value: T, message?: string): void;

            /**
             * Asserts that value is not an object of type 'Object'
             * (as revealed by Object.prototype.toString).
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNotObject<T>(value: T, message?: string): void;

            /**
             * Asserts that value is an array.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isArray<T>(value: T, message?: string): void;

            /**
             * Asserts that value is not an array.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNotArray<T>(value: T, message?: string): void;

            /**
             * Asserts that value is a string.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isString<T>(value: T, message?: string): void;

            /**
             * Asserts that value is not a string.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNotString<T>(value: T, message?: string): void;

            /**
             * Asserts that value is a number.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNumber<T>(value: T, message?: string): void;

            /**
             * Asserts that value is not a number.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNotNumber<T>(value: T, message?: string): void;

            /**
             * Asserts that value is a finite number.
             * Unlike `.isNumber`, this will fail for `NaN` and `Infinity`.
             *
             * T   Type of value
             * @param value    Actual value
             * @param message   Message to display on error.
             */
            isFinite<T>(value: T, message?: string): void;

            /**
             * Asserts that value is a boolean.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isBoolean<T>(value: T, message?: string): void;

            /**
             * Asserts that value is not a boolean.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param message   Message to display on error.
             */
            isNotBoolean<T>(value: T, message?: string): void;

            /**
             * Asserts that value's type is name, as determined by Object.prototype.toString.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param name   Potential expected type name of value.
             * @param message   Message to display on error.
             */
            typeOf<T>(value: T, name: string, message?: string): void;

            /**
             * Asserts that value's type is not name, as determined by Object.prototype.toString.
             *
             * T   Type of value.
             * @param value   Actual value.
             * @param name   Potential expected type name of value.
             * @param message   Message to display on error.
             */
            notTypeOf<T>(value: T, name: string, message?: string): void;

            /**
             * Asserts that value is an instance of constructor.
             *
             * T   Expected type of value.
             * @param value   Actual value.
             * @param constructor   Potential expected contructor of value.
             * @param message   Message to display on error.
             */
            instanceOf<T>(
                value: unknown,
                constructor: Constructor<T>,
                message?: string,
            ): asserts value is T;

            /**
             * Asserts that value is not an instance of constructor.
             *
             * T   Type of value.
             * U   Type that value shouldn't be an instance of.
             * @param value   Actual value.
             * @param constructor   Potential expected contructor of value.
             * @param message   Message to display on error.
             */
            notInstanceOf<T, U>(value: T, type: Constructor<U>, message?: string): asserts value is Exclude<T, U>;

            /**
             * Asserts that haystack includes needle.
             *
             * @param haystack   Container string.
             * @param needle   Potential substring of haystack.
             * @param message   Message to display on error.
             */
            include(haystack: string, needle: string, message?: string): void;

            /**
             * Asserts that haystack includes needle.
             *
             * T   Type of values in haystack.
             * @param haystack   Container array, set or map.
             * @param needle   Potential value contained in haystack.
             * @param message   Message to display on error.
             */
            include<T>(
                haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,
                needle: T,
                message?: string,
            ): void;

            /**
             * Asserts that haystack includes needle.
             *
             * T   Type of values in haystack.
             * @param haystack   WeakSet container.
             * @param needle   Potential value contained in haystack.
             * @param message   Message to display on error.
             */
            include<T extends object>(haystack: WeakSet<T>, needle: T, message?: string): void;

            /**
             * Asserts that haystack includes needle.
             *
             * T   Type of haystack.
             * @param haystack   Object.
             * @param needle   Potential subset of the haystack's properties.
             * @param message   Message to display on error.
             */
            include<T>(haystack: T, needle: Partial<T>, message?: string): void;

            /**
             * Asserts that haystack does not include needle.
             *
             * @param haystack   Container string.
             * @param needle   Potential substring of haystack.
             * @param message   Message to display on error.
             */
            notInclude(haystack: string, needle: string, message?: string): void;

            /**
             * Asserts that haystack does not include needle.
             *
             * T   Type of values in haystack.
             * @param haystack   Container array, set or map.
             * @param needle   Potential value contained in haystack.
             * @param message   Message to display on error.
             */
            notInclude<T>(
                haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,
                needle: T,
                message?: string,
            ): void;

            /**
             * Asserts that haystack does not include needle.
             *
             * T   Type of values in haystack.
             * @param haystack   WeakSet container.
             * @param needle   Potential value contained in haystack.
             * @param message   Message to display on error.
             */
            notInclude<T extends object>(haystack: WeakSet<T>, needle: T, message?: string): void;

            /**
             * Asserts that haystack does not include needle.
             *
             * T   Type of haystack.
             * @param haystack   Object.
             * @param needle   Potential subset of the haystack's properties.
             * @param message   Message to display on error.
             */
            notInclude<T>(haystack: T, needle: Partial<T>, message?: string): void;

            /**
             * Asserts that haystack includes needle. Deep equality is used.
             *
             * @param haystack   Container string.
             * @param needle   Potential substring of haystack.
             * @param message   Message to display on error.
             *
             * @deprecated Does not have any effect on string. Use {@link Assert#include} instead.
             */
            deepInclude(haystack: string, needle: string, message?: string): void;

            /**
             * Asserts that haystack includes needle. Deep equality is used.
             *
             * T   Type of values in haystack.
             * @param haystack   Container array, set or map.
             * @param needle   Potential value contained in haystack.
             * @param message   Message to display on error.
             */
            deepInclude<T>(
                haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,
                needle: T,
                message?: string,
            ): void;

            /**
             * Asserts that haystack includes needle. Deep equality is used.
             *
             * T   Type of haystack.
             * @param haystack   Object.
             * @param needle   Potential subset of the haystack's properties.
             * @param message   Message to display on error.
             */
            deepInclude<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string): void;

            /**
             * Asserts that haystack does not include needle. Deep equality is used.
             *
             * @param haystack   Container string.
             * @param needle   Potential substring of haystack.
             * @param message   Message to display on error.
             *
             * @deprecated Does not have any effect on string. Use {@link Assert#notInclude} instead.
             */
            notDeepInclude(haystack: string, needle: string, message?: string): void;

            /**
             * Asserts that haystack does not include needle. Deep equality is used.
             *
             * T   Type of values in haystack.
             * @param haystack   Container array, set or map.
             * @param needle   Potential value contained in haystack.
             * @param message   Message to display on error.
             */
            notDeepInclude<T>(
                haystack: readonly T[] | ReadonlySet<T> | ReadonlyMap<any, T>,
                needle: T,
                message?: string,
            ): void;

            /**
             * Asserts that haystack does not include needle. Deep equality is used.
             *
             * T   Type of haystack.
             * @param haystack   Object.
             * @param needle   Potential subset of the haystack's properties.
             * @param message   Message to display on error.
             */
            notDeepInclude<T>(haystack: T, needle: T extends WeakSet<any> ? never : Partial<T>, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ includes â€˜needleâ€™. Can be used to assert the inclusion of a subset of properties in an object.
             *
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.Asserts that â€˜haystackâ€™ includes â€˜needleâ€™.
             * Can be used to assert the inclusion of a subset of properties in an object.
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            nestedInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ does not include â€˜needleâ€™. Can be used to assert the absence of a subset of properties in an object.
             *
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.Asserts that â€˜haystackâ€™ includes â€˜needleâ€™.
             * Can be used to assert the inclusion of a subset of properties in an object.
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            notNestedInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ includes â€˜needleâ€™. Can be used to assert the inclusion of a subset of properties in an object while checking for deep equality
             *
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.Asserts that â€˜haystackâ€™ includes â€˜needleâ€™.
             * Can be used to assert the inclusion of a subset of properties in an object.
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            deepNestedInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ does not include â€˜needleâ€™. Can be used to assert the absence of a subset of properties in an object while checking for deep equality.
             *
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.Asserts that â€˜haystackâ€™ includes â€˜needleâ€™.
             * Can be used to assert the inclusion of a subset of properties in an object.
             * Enables the use of dot- and bracket-notation for referencing nested properties.
             * â€˜[]â€™ and â€˜.â€™ in property names can be escaped using double backslashes.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            notDeepNestedInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ includes â€˜needleâ€™. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            ownInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ includes â€˜needleâ€™. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            notOwnInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ includes â€˜needleâ€™. Can be used to assert the inclusion of a subset of properties in an object while ignoring inherited properties and checking for deep
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            deepOwnInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that â€˜haystackâ€™ includes â€˜needleâ€™. Can be used to assert the absence of a subset of properties in an object while ignoring inherited properties and checking for deep equality.
             *
             * @param haystack
             * @param needle
             * @param message   Message to display on error.
             */
            notDeepOwnInclude(haystack: any, needle: any, message?: string): void;

            /**
             * Asserts that value matches the regular expression regexp.
             *
             * @param value   Actual value.
             * @param regexp   Potential match of value.
             * @param message   Message to display on error.
             */
            match(value: string, regexp: RegExp, message?: string): void;

            /**
             * Asserts that value does not match the regular expression regexp.
             *
             * @param value   Actual value.
             * @param regexp   Potential match of value.
             * @param message   Message to display on error.
             */
            notMatch(expected: any, regexp: RegExp, message?: string): void;

            /**
             * Asserts that object has a property named by property.
             *
             * T   Type of object.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param message   Message to display on error.
             */
            property<T>(object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that object does not have a property named by property.
             *
             * T   Type of object.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param message   Message to display on error.
             */
            notProperty<T>(object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that object has a property named by property, which can be a string
             * using dot- and bracket-notation for deep reference.
             *
             * T   Type of object.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param message   Message to display on error.
             */
            deepProperty<T>(object: T, property: string, message?: string): void;

            /**
             * Asserts that object does not have a property named by property, which can be a
             * string using dot- and bracket-notation for deep reference.
             *
             * T   Type of object.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param message   Message to display on error.
             */
            notDeepProperty<T>(object: T, property: string, message?: string): void;

            /**
             * Asserts that object has a property named by property with value given by value.
             *
             * T   Type of object.
             * V   Type of value.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param value   Potential expected property value.
             * @param message   Message to display on error.
             */
            propertyVal<T, V>(object: T, property: string, /* keyof T */ value: V, message?: string): void;

            /**
             * Asserts that object has a property named by property with value given by value.
             *
             * T   Type of object.
             * V   Type of value.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param value   Potential expected property value.
             * @param message   Message to display on error.
             */
            notPropertyVal<T, V>(object: T, property: string, /* keyof T */ value: V, message?: string): void;

            /**
             * Asserts that object has a property named by property, which can be a string
             * using dot- and bracket-notation for deep reference.
             *
             * T   Type of object.
             * V   Type of value.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param value   Potential expected property value.
             * @param message   Message to display on error.
             */
            deepPropertyVal<T, V>(object: T, property: string, value: V, message?: string): void;

            /**
             * Asserts that object does not have a property named by property, which can be a
             * string using dot- and bracket-notation for deep reference.
             *
             * T   Type of object.
             * V   Type of value.
             * @param object   Container object.
             * @param property   Potential contained property of object.
             * @param value   Potential expected property value.
             * @param message   Message to display on error.
             */
            notDeepPropertyVal<T, V>(object: T, property: string, value: V, message?: string): void;

            /**
             * Asserts that object has a length property with the expected value.
             *
             * T   Type of object.
             * @param object   Container object.
             * @param length   Potential expected length of object.
             * @param message   Message to display on error.
             */
            lengthOf<T extends { readonly length?: number | undefined } | { readonly size?: number | undefined }>(
                object: T,
                length: number,
                message?: string,
            ): void;

            /**
             * Asserts that fn will throw an error.
             *
             * @param fn   Function that may throw.
             * @param errMsgMatcher   Expected error message matcher.
             * @param ignored   Ignored parameter.
             * @param message   Message to display on error.
             */
            throw(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;

            /**
             * Asserts that fn will throw an error.
             *
             * @param fn   Function that may throw.
             * @param errorLike   Expected error constructor or error instance.
             * @param errMsgMatcher   Expected error message matcher.
             * @param message   Message to display on error.
             */
            throw(
                fn: () => void,
                errorLike?: ErrorConstructor | Error | null,
                errMsgMatcher?: RegExp | string | null,
                message?: string,
            ): void;

            /**
             * Asserts that fn will throw an error.
             *
             * @param fn   Function that may throw.
             * @param errMsgMatcher   Expected error message matcher.
             * @param ignored   Ignored parameter.
             * @param message   Message to display on error.
             */
            throws(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;

            /**
             * Asserts that fn will throw an error.
             *
             * @param fn   Function that may throw.
             * @param errorLike   Expected error constructor or error instance.
             * @param errMsgMatcher   Expected error message matcher.
             * @param message   Message to display on error.
             */
            throws(
                fn: () => void,
                errorLike?: ErrorConstructor | Error | null,
                errMsgMatcher?: RegExp | string | null,
                message?: string,
            ): void;

            /**
             * Asserts that fn will throw an error.
             *
             * @param fn   Function that may throw.
             * @param errMsgMatcher   Expected error message matcher.
             * @param ignored   Ignored parameter.
             * @param message   Message to display on error.
             */
            Throw(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;

            /**
             * Asserts that fn will throw an error.
             *
             * @param fn   Function that may throw.
             * @param errorLike   Expected error constructor or error instance.
             * @param errMsgMatcher   Expected error message matcher.
             * @param message   Message to display on error.
             */
            Throw(
                fn: () => void,
                errorLike?: ErrorConstructor | Error | null,
                errMsgMatcher?: RegExp | string | null,
                message?: string,
            ): void;

            /**
             * Asserts that fn will not throw an error.
             *
             * @param fn   Function that may throw.
             * @param errMsgMatcher   Expected error message matcher.
             * @param ignored   Ignored parameter.
             * @param message   Message to display on error.
             */
            doesNotThrow(fn: () => void, errMsgMatcher?: RegExp | string, ignored?: any, message?: string): void;

            /**
             * Asserts that fn will not throw an error.
             *
             * @param fn   Function that may throw.
             * @param errorLike   Expected error constructor or error instance.
             * @param errMsgMatcher   Expected error message matcher.
             * @param message   Message to display on error.
             */
            doesNotThrow(
                fn: () => void,
                errorLike?: ErrorConstructor | Error | null,
                errMsgMatcher?: RegExp | string | null,
                message?: string,
            ): void;

            /**
             * Compares two values using operator.
             *
             * @param val1   Left value during comparison.
             * @param operator   Comparison operator.
             * @param val2   Right value during comparison.
             * @param message   Message to display on error.
             */
            operator(val1: OperatorComparable, operator: Operator, val2: OperatorComparable, message?: string): void;

            /**
             * Asserts that the target is equal to expected, to within a +/- delta range.
             *
             * @param actual   Actual value
             * @param expected   Potential expected value.
             * @param delta   Maximum differenced between values.
             * @param message   Message to display on error.
             */
            closeTo(actual: number, expected: number, delta: number, message?: string): void;

            /**
             * Asserts that the target is equal to expected, to within a +/- delta range.
             *
             * @param actual   Actual value
             * @param expected   Potential expected value.
             * @param delta   Maximum differenced between values.
             * @param message   Message to display on error.
             */
            approximately(act: number, exp: number, delta: number, message?: string): void;

            /**
             * Asserts that set1 and set2 have the same members. Order is not take into account.
             *
             * T   Type of set values.
             * @param set1   Actual set of values.
             * @param set2   Potential expected set of values.
             * @param message   Message to display on error.
             */
            sameMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that set1 and set2 have the same members using deep equality checking.
             * Order is not take into account.
             *
             * T   Type of set values.
             * @param set1   Actual set of values.
             * @param set2   Potential expected set of values.
             * @param message   Message to display on error.
             */
            sameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that `set1` and `set2` don't have the same members in any order.
             * Uses a deep equality check.
             *
             *  T   Type of set values.
             * @param set1
             * @param set2
             * @param message
             */
            notSameDeepMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that set1 and set2 have the same members in the same order.
             * Uses a strict equality check (===).
             *
             * T   Type of set values.
             * @param set1   Actual set of values.
             * @param set2   Potential expected set of values.
             * @param message   Message to display on error.
             */
            sameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that set1 and set2 donâ€™t have the same members in the same order.
             * Uses a strict equality check (===).
             *
             * T   Type of set values.
             * @param set1   Actual set of values.
             * @param set2   Potential expected set of values.
             * @param message   Message to display on error.
             */
            notSameOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that set1 and set2 have the same members in the same order.
             * Uses a deep equality check.
             *
             * T   Type of set values.
             * @param set1   Actual set of values.
             * @param set2   Potential expected set of values.
             * @param message   Message to display on error.
             */
            sameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that set1 and set2 donâ€™t have the same members in the same order.
             * Uses a deep equality check.
             *
             * T   Type of set values.
             * @param set1   Actual set of values.
             * @param set2   Potential expected set of values.
             * @param message   Message to display on error.
             */
            notSameDeepOrderedMembers<T>(set1: T[], set2: T[], message?: string): void;

            /**
             * Asserts that subset is included in superset in the same order beginning with the first element in superset.
             * Uses a strict equality check (===).
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            includeOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that subset isnâ€™t included in superset in the same order beginning with the first element in superset.
             * Uses a strict equality check (===).
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            notIncludeOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that subset is included in superset in the same order beginning with the first element in superset.
             * Uses a deep equality check.
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            includeDeepOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that subset isnâ€™t included in superset in the same order beginning with the first element in superset.
             * Uses a deep equality check.
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            notIncludeDeepOrderedMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that subset is included in superset. Order is not take into account.
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            includeMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that subset isnâ€™t included in superset in any order.
             * Uses a strict equality check (===). Duplicates are ignored.
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential not contained set of values.
             * @param message   Message to display on error.
             */
            notIncludeMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that subset is included in superset using deep equality checking.
             * Order is not take into account.
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            includeDeepMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that `subset` isn't included in `superset` in any order. Uses a
             * deep equality check. Duplicates are ignored.
             *
             * assert.notIncludeDeepMembers([ { a: 1 }, { b: 2 }, { c: 3 } ], [ { b: 2 }, { f: 5 } ], 'not include deep members');
             *
             * T   Type of set values.
             * @param superset   Actual set of values.
             * @param subset   Potential contained set of values.
             * @param message   Message to display on error.
             */
            notIncludeDeepMembers<T>(superset: T[], subset: T[], message?: string): void;

            /**
             * Asserts that non-object, non-array value inList appears in the flat array list.
             *
             * T   Type of list values.
             * @param inList   Value expected to be in the list.
             * @param list   List of values.
             * @param message   Message to display on error.
             */
            oneOf<T>(inList: T, list: T[], message?: string): void;

            /**
             * Asserts that a function changes the value of a property.
             *
             * T   Type of object.
             * @param modifier   Function to run.
             * @param object   Container object.
             * @param property   Property of object expected to be modified.
             * @param message   Message to display on error.
             */
            changes<T>(modifier: Function, object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that a function changes the value of a property by an amount (delta).
             *
             * @param modifier function
             * @param object or getter function
             * @param property name _optional_
             * @param change amount (delta)
             * @param message _optional_
             */
            changesBy<T>(
                modifier: Function,
                object: T,
                property: string,
                /* keyof T */ change: number,
                message?: string,
            ): void;
            changesBy<T>(modifier: Function, object: T, change: number, message?: string): void;

            /**
             * Asserts that a function does not change the value of a property.
             *
             * T   Type of object.
             * @param modifier   Function to run.
             * @param object   Container object.
             * @param property   Property of object expected not to be modified.
             * @param message   Message to display on error.
             */
            doesNotChange<T>(modifier: Function, object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that a function increases an object property.
             *
             * T   Type of object.
             * @param modifier   Function to run.
             * @param object   Container object.
             * @param property   Property of object expected to be increased.
             * @param message   Message to display on error.
             */
            increases<T>(modifier: Function, object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that a function increases a numeric object property or a function's return value by an amount (delta).
             *
             * T   Type of object or function.
             * @param modifier function
             * @param object or getter function
             * @param property name _optional_
             * @param change amount (delta)
             * @param message _optional_
             */
            increasesBy<T>(
                modifier: Function,
                object: T,
                property: string,
                /* keyof T */ change: number,
                message?: string,
            ): void;
            increasesBy<T>(modifier: Function, object: T, change: number, message?: string): void;

            /**
             * Asserts that a function does not increase an object property.
             *
             * T   Type of object.
             * @param modifier   Function to run.
             * @param object   Container object.
             * @param property   Property of object expected not to be increased.
             * @param message   Message to display on error.
             */
            doesNotIncrease<T>(modifier: Function, object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that a function does not increase a numeric object property or function's return value by an amount (delta).
             *
             * T   Type of object or function.
             * @param modifier function
             * @param object or getter function
             * @param property name _optional_
             * @param change amount (delta)
             * @param message _optional_
             */

            increasesButNotBy<T>(
                modifier: Function,
                object: T,
                property: string,
                /* keyof T */ change: number,
                message?: string,
            ): void;
            increasesButNotBy<T>(modifier: Function, object: T, change: number, message?: string): void;

            /**
             * Asserts that a function decreases an object property.
             *
             * T   Type of object.
             * @param modifier   Function to run.
             * @param object   Container object.
             * @param property   Property of object expected to be decreased.
             * @param message   Message to display on error.
             */
            decreases<T>(modifier: Function, object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that a function decreases a numeric object property or a function's return value by an amount (delta)
             *
             * T   Type of object or function.
             * @param modifier function
             * @param object or getter function
             * @param property name _optional_
             * @param change amount (delta)
             * @param message _optional_
             */

            decreasesBy<T>(
                modifier: Function,
                object: T,
                property: string,
                /* keyof T */ change: number,
                message?: string,
            ): void;
            decreasesBy<T>(modifier: Function, object: T, change: number, message?: string): void;

            /**
             * Asserts that a function does not decrease an object property.
             *
             * T   Type of object.
             * @param modifier   Function to run.
             * @param object   Container object.
             * @param property   Property of object expected not to be decreased.
             * @param message   Message to display on error.
             */
            doesNotDecrease<T>(modifier: Function, object: T, property: string, /* keyof T */ message?: string): void;

            /**
             * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
             *
             * T   Type of object or function.
             * @param modifier function
             * @param object or getter function
             * @param property name _optional_
             * @param change amount (delta)
             * @param message _optional_
             */

            doesNotDecreaseBy<T>(
                modifier: Function,
                object: T,
                property: string,
                /* keyof T */ change: number,
                message?: string,
            ): void;
            doesNotDecreaseBy<T>(modifier: Function, object: T, change: number, message?: string): void;

            /**
             * Asserts that a function does not decreases a numeric object property or a function's return value by an amount (delta)
             *
             * T   Type of object or function.
             * @param modifier function
             * @param object or getter function
             * @param property name _optional_
             * @param change amount (delta)
             * @param message _optional_
             */

            decreasesButNotBy<T>(
                modifier: Function,
                object: T,
                property: string,
                /* keyof T */ change: number,
                message?: string,
            ): void;
            decreasesButNotBy<T>(modifier: Function, object: T, change: number, message?: string): void;

            /**
             * Asserts if value is not a false value, and throws if it is a true value.
             *
             * T   Type of object.
             * @param object   Actual value.
             * @param message   Message to display on error.
             * @remarks This is added to allow for chai to be a drop-in replacement for
             *          Nodeâ€™s assert class.
             */
            ifError<T>(object: T, message?: string): void;

            /**
             * Asserts that object is extensible (can have new properties added to it).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isExtensible<T>(object: T, message?: string): void;

            /**
             * Asserts that object is extensible (can have new properties added to it).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            extensible<T>(object: T, message?: string): void;

            /**
             * Asserts that object is not extensible.
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isNotExtensible<T>(object: T, message?: string): void;

            /**
             * Asserts that object is not extensible.
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            notExtensible<T>(object: T, message?: string): void;

            /**
             * Asserts that object is sealed (can have new properties added to it
             * and its existing properties cannot be removed).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isSealed<T>(object: T, message?: string): void;

            /**
             * Asserts that object is sealed (can have new properties added to it
             * and its existing properties cannot be removed).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            sealed<T>(object: T, message?: string): void;

            /**
             * Asserts that object is not sealed.
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isNotSealed<T>(object: T, message?: string): void;

            /**
             * Asserts that object is not sealed.
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            notSealed<T>(object: T, message?: string): void;

            /**
             * Asserts that object is frozen (cannot have new properties added to it
             * and its existing properties cannot be removed).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isFrozen<T>(object: T, message?: string): void;

            /**
             * Asserts that object is frozen (cannot have new properties added to it
             * and its existing properties cannot be removed).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            frozen<T>(object: T, message?: string): void;

            /**
             * Asserts that object is not frozen (cannot have new properties added to it
             * and its existing properties cannot be removed).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isNotFrozen<T>(object: T, message?: string): void;

            /**
             * Asserts that object is not frozen (cannot have new properties added to it
             * and its existing properties cannot be removed).
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            notFrozen<T>(object: T, message?: string): void;

            /**
             * Asserts that the target does not contain any values. For arrays and
             * strings, it checks the length property. For Map and Set instances, it
             * checks the size property. For non-function objects, it gets the count
             * of own enumerable string keys.
             *
             * T   Type of object
             * @param object   Actual value.
             * @param message   Message to display on error.
             */
            isEmpty<T>(object: T, message?: string): void;

            /**
             * Asserts that the target contains values. For arrays and strings, it checks
             * the length property. For Map and Set instances, it checks the size property.
             * For non-function objects, it gets the count of own enumerable string keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param message    Message to display on error.
             */
            isNotEmpty<T>(object: T, message?: string): void;

            /**
             * Asserts that `object` has at least one of the `keys` provided.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            hasAnyKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;

            /**
             * Asserts that `object` has all and only all of the `keys` provided.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            hasAllKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;

            /**
             * Asserts that `object` has all of the `keys` provided but may have more keys not listed.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            containsAllKeys<T>(
                object: T,
                keys: Array<Object | string> | { [key: string]: any },
                message?: string,
            ): void;

            /**
             * Asserts that `object` has none of the `keys` provided.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            doesNotHaveAnyKeys<T>(
                object: T,
                keys: Array<Object | string> | { [key: string]: any },
                message?: string,
            ): void;

            /**
             * Asserts that `object` does not have at least one of the `keys` provided.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            doesNotHaveAllKeys<T>(
                object: T,
                keys: Array<Object | string> | { [key: string]: any },
                message?: string,
            ): void;

            /**
             * Asserts that `object` has at least one of the `keys` provided.
             * Since Sets and Maps can have objects as keys you can use this assertion to perform
             * a deep comparison.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            hasAnyDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;

            /**
             * Asserts that `object` has all and only all of the `keys` provided.
             * Since Sets and Maps can have objects as keys you can use this assertion to perform
             * a deep comparison.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            hasAllDeepKeys<T>(object: T, keys: Array<Object | string> | { [key: string]: any }, message?: string): void;

            /**
             * Asserts that `object` contains all of the `keys` provided.
             * Since Sets and Maps can have objects as keys you can use this assertion to perform
             * a deep comparison.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            containsAllDeepKeys<T>(
                object: T,
                keys: Array<Object | string> | { [key: string]: any },
                message?: string,
            ): void;

            /**
             * Asserts that `object` contains all of the `keys` provided.
             * Since Sets and Maps can have objects as keys you can use this assertion to perform
             * a deep comparison.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            doesNotHaveAnyDeepKeys<T>(
                object: T,
                keys: Array<Object | string> | { [key: string]: any },
                message?: string,
            ): void;

            /**
             * Asserts that `object` contains all of the `keys` provided.
             * Since Sets and Maps can have objects as keys you can use this assertion to perform
             * a deep comparison.
             * You can also provide a single object instead of a `keys` array and its keys
             * will be used as the expected set of keys.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param keys   Keys to check
             * @param message    Message to display on error.
             */
            doesNotHaveAllDeepKeys<T>(
                object: T,
                keys: Array<Object | string> | { [key: string]: any },
                message?: string,
            ): void;

            /**
             * Asserts that object has a direct or inherited property named by property,
             * which can be a string using dot- and bracket-notation for nested reference.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param property    Property to test.
             * @param message    Message to display on error.
             */
            nestedProperty<T>(object: T, property: string, message?: string): void;

            /**
             * Asserts that object does not have a property named by property,
             * which can be a string using dot- and bracket-notation for nested reference.
             * The property cannot exist on the object nor anywhere in its prototype chain.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param property    Property to test.
             * @param message    Message to display on error.
             */
            notNestedProperty<T>(object: T, property: string, message?: string): void;

            /**
             * Asserts that object has a property named by property with value given by value.
             * property can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param property    Property to test.
             * @param value    Value to test.
             * @param message    Message to display on error.
             */
            nestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;

            /**
             * Asserts that object does not have a property named by property with value given by value.
             * property can use dot- and bracket-notation for nested reference. Uses a strict equality check (===).
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param property    Property to test.
             * @param value    Value to test.
             * @param message    Message to display on error.
             */
            notNestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;

            /**
             * Asserts that object has a property named by property with a value given by value.
             * property can use dot- and bracket-notation for nested reference. Uses a deep equality check.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param property    Property to test.
             * @param value    Value to test.
             * @param message    Message to display on error.
             */
            deepNestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;

            /**
             * Asserts that object does not have a property named by property with value given by value.
             * property can use dot- and bracket-notation for nested reference. Uses a deep equality check.
             *
             * T   Type of object.
             * @param object   Object to test.
             * @param property    Property to test.
             * @param value    Value to test.
             * @param message    Message to display on error.
             */
            notDeepNestedPropertyVal<T>(object: T, property: string, value: any, message?: string): void;
        }

        export interface Config {
            /**
             * Default: false
             */
            includeStack: boolean;

            /**
             * Default: true
             */
            showDiff: boolean;

            /**
             * Default: 40
             */
            truncateThreshold: number;

            /**
             * Default: true
             */
            useProxy: boolean;

            /**
             * Default: ['then', 'catch', 'inspect', 'toJSON']
             */
            proxyExcludedKeys: string[];

            deepEqual: <L, R>(expected: L, actual: R) => void;
        }

        export type { ImportedAssertionError as AssertionError };
    }
}

export function use(fn: Chai.ChaiPlugin): Chai.ChaiStatic;

export const util: Chai.ChaiUtils;
export const config: Chai.Config;
export const Assertion: Chai.AssertionStatic;
export const AssertionError: typeof ImportedAssertionError;
export function should(): Chai.Should;
export function Should(): Chai.Should;
export const assert: Chai.AssertStatic;
export const expect: Chai.ExpectStatic;
