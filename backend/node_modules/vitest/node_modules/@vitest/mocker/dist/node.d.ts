import { Plugin, Rollup, ViteDevServer } from 'vite';
import MagicString, { SourceMap } from 'magic-string';
import { c as MockerRegistry } from './registry.d-D765pazg.js';
export { findMockRedirect } from './redirect.js';

declare function createManualModuleSource(moduleUrl: string, exports: string[], globalAccessor?: string): string;

interface AutomockPluginOptions {
	/**
	* @default "__vitest_mocker__"
	*/
	globalThisAccessor?: string;
}
declare function automockPlugin(options?: AutomockPluginOptions): Plugin;
// TODO: better source map replacement
declare function automockModule(code: string, mockType: "automock" | "autospy", parse: (code: string) => any, options?: AutomockPluginOptions): MagicString;

interface DynamicImportPluginOptions {
	/**
	* @default `"__vitest_mocker__"`
	*/
	globalThisAccessor?: string;
	filter?: (id: string) => boolean;
}
declare function dynamicImportPlugin(options?: DynamicImportPluginOptions): Plugin;

// This definition file follows a somewhat unusual format. ESTree allows
// runtime type checks based on the `type` parameter. In order to explain this
// to typescript we want to use discriminated union types:
// https://github.com/Microsoft/TypeScript/pull/9163
//
// For ESTree this is a bit tricky because the high level interfaces like
// Node or Function are pulling double duty. We want to pass common fields down
// to the interfaces that extend them (like Identifier or
// ArrowFunctionExpression), but you can't extend a type union or enforce
// common fields on them. So we've split the high level interfaces into two
// types, a base type which passes down inherited fields, and a type union of
// all types which extend the base type. Only the type union is exported, and
// the union is how other types refer to the collection of inheriting types.
//
// This makes the definitions file here somewhat more difficult to maintain,
// but it has the notable advantage of making ESTree much easier to use as
// an end user.

interface BaseNodeWithoutComments {
    // Every leaf interface that extends BaseNode must specify a type property.
    // The type property should be a string literal. For example, Identifier
    // has: `type: "Identifier"`
    type: string;
    loc?: SourceLocation | null | undefined;
    range?: [number, number] | undefined;
}

interface BaseNode extends BaseNodeWithoutComments {
    leadingComments?: Comment[] | undefined;
    trailingComments?: Comment[] | undefined;
}

interface NodeMap {
    AssignmentProperty: AssignmentProperty;
    CatchClause: CatchClause;
    Class: Class;
    ClassBody: ClassBody;
    Expression: Expression;
    Function: Function;
    Identifier: Identifier;
    Literal: Literal;
    MethodDefinition: MethodDefinition;
    ModuleDeclaration: ModuleDeclaration;
    ModuleSpecifier: ModuleSpecifier;
    Pattern: Pattern;
    PrivateIdentifier: PrivateIdentifier;
    Program: Program;
    Property: Property;
    PropertyDefinition: PropertyDefinition;
    SpreadElement: SpreadElement;
    Statement: Statement;
    Super: Super;
    SwitchCase: SwitchCase;
    TemplateElement: TemplateElement;
    VariableDeclarator: VariableDeclarator;
}

type Node$1 = NodeMap[keyof NodeMap];

interface Comment extends BaseNodeWithoutComments {
    type: "Line" | "Block";
    value: string;
}

interface SourceLocation {
    source?: string | null | undefined;
    start: Position;
    end: Position;
}

interface Position {
    /** >= 1 */
    line: number;
    /** >= 0 */
    column: number;
}

interface Program extends BaseNode {
    type: "Program";
    sourceType: "script" | "module";
    body: Array<Directive | Statement | ModuleDeclaration>;
    comments?: Comment[] | undefined;
}

interface Directive extends BaseNode {
    type: "ExpressionStatement";
    expression: Literal;
    directive: string;
}

interface BaseFunction extends BaseNode {
    params: Pattern[];
    generator?: boolean | undefined;
    async?: boolean | undefined;
    // The body is either BlockStatement or Expression because arrow functions
    // can have a body that's either. FunctionDeclarations and
    // FunctionExpressions have only BlockStatement bodies.
    body: BlockStatement | Expression;
}

type Function = FunctionDeclaration | FunctionExpression | ArrowFunctionExpression;

type Statement =
    | ExpressionStatement
    | BlockStatement
    | StaticBlock
    | EmptyStatement
    | DebuggerStatement
    | WithStatement
    | ReturnStatement
    | LabeledStatement
    | BreakStatement
    | ContinueStatement
    | IfStatement
    | SwitchStatement
    | ThrowStatement
    | TryStatement
    | WhileStatement
    | DoWhileStatement
    | ForStatement
    | ForInStatement
    | ForOfStatement
    | Declaration;

interface BaseStatement extends BaseNode {}

interface EmptyStatement extends BaseStatement {
    type: "EmptyStatement";
}

interface BlockStatement extends BaseStatement {
    type: "BlockStatement";
    body: Statement[];
    innerComments?: Comment[] | undefined;
}

interface StaticBlock extends Omit<BlockStatement, "type"> {
    type: "StaticBlock";
}

interface ExpressionStatement extends BaseStatement {
    type: "ExpressionStatement";
    expression: Expression;
}

interface IfStatement extends BaseStatement {
    type: "IfStatement";
    test: Expression;
    consequent: Statement;
    alternate?: Statement | null | undefined;
}

interface LabeledStatement extends BaseStatement {
    type: "LabeledStatement";
    label: Identifier;
    body: Statement;
}

interface BreakStatement extends BaseStatement {
    type: "BreakStatement";
    label?: Identifier | null | undefined;
}

interface ContinueStatement extends BaseStatement {
    type: "ContinueStatement";
    label?: Identifier | null | undefined;
}

interface WithStatement extends BaseStatement {
    type: "WithStatement";
    object: Expression;
    body: Statement;
}

interface SwitchStatement extends BaseStatement {
    type: "SwitchStatement";
    discriminant: Expression;
    cases: SwitchCase[];
}

interface ReturnStatement extends BaseStatement {
    type: "ReturnStatement";
    argument?: Expression | null | undefined;
}

interface ThrowStatement extends BaseStatement {
    type: "ThrowStatement";
    argument: Expression;
}

interface TryStatement extends BaseStatement {
    type: "TryStatement";
    block: BlockStatement;
    handler?: CatchClause | null | undefined;
    finalizer?: BlockStatement | null | undefined;
}

interface WhileStatement extends BaseStatement {
    type: "WhileStatement";
    test: Expression;
    body: Statement;
}

interface DoWhileStatement extends BaseStatement {
    type: "DoWhileStatement";
    body: Statement;
    test: Expression;
}

interface ForStatement extends BaseStatement {
    type: "ForStatement";
    init?: VariableDeclaration | Expression | null | undefined;
    test?: Expression | null | undefined;
    update?: Expression | null | undefined;
    body: Statement;
}

interface BaseForXStatement extends BaseStatement {
    left: VariableDeclaration | Pattern;
    right: Expression;
    body: Statement;
}

interface ForInStatement extends BaseForXStatement {
    type: "ForInStatement";
}

interface DebuggerStatement extends BaseStatement {
    type: "DebuggerStatement";
}

type Declaration = FunctionDeclaration | VariableDeclaration | ClassDeclaration;

interface BaseDeclaration extends BaseStatement {}

interface MaybeNamedFunctionDeclaration extends BaseFunction, BaseDeclaration {
    type: "FunctionDeclaration";
    /** It is null when a function declaration is a part of the `export default function` statement */
    id: Identifier | null;
    body: BlockStatement;
}

interface FunctionDeclaration extends MaybeNamedFunctionDeclaration {
    id: Identifier;
}

interface VariableDeclaration extends BaseDeclaration {
    type: "VariableDeclaration";
    declarations: VariableDeclarator[];
    kind: "var" | "let" | "const" | "using" | "await using";
}

interface VariableDeclarator extends BaseNode {
    type: "VariableDeclarator";
    id: Pattern;
    init?: Expression | null | undefined;
}

interface ExpressionMap {
    ArrayExpression: ArrayExpression;
    ArrowFunctionExpression: ArrowFunctionExpression;
    AssignmentExpression: AssignmentExpression;
    AwaitExpression: AwaitExpression;
    BinaryExpression: BinaryExpression;
    CallExpression: CallExpression;
    ChainExpression: ChainExpression;
    ClassExpression: ClassExpression;
    ConditionalExpression: ConditionalExpression;
    FunctionExpression: FunctionExpression;
    Identifier: Identifier;
    ImportExpression: ImportExpression;
    Literal: Literal;
    LogicalExpression: LogicalExpression;
    MemberExpression: MemberExpression;
    MetaProperty: MetaProperty;
    NewExpression: NewExpression;
    ObjectExpression: ObjectExpression;
    SequenceExpression: SequenceExpression;
    TaggedTemplateExpression: TaggedTemplateExpression;
    TemplateLiteral: TemplateLiteral;
    ThisExpression: ThisExpression;
    UnaryExpression: UnaryExpression;
    UpdateExpression: UpdateExpression;
    YieldExpression: YieldExpression;
}

type Expression = ExpressionMap[keyof ExpressionMap];

interface BaseExpression extends BaseNode {}

type ChainElement = SimpleCallExpression | MemberExpression;

interface ChainExpression extends BaseExpression {
    type: "ChainExpression";
    expression: ChainElement;
}

interface ThisExpression extends BaseExpression {
    type: "ThisExpression";
}

interface ArrayExpression extends BaseExpression {
    type: "ArrayExpression";
    elements: Array<Expression | SpreadElement | null>;
}

interface ObjectExpression extends BaseExpression {
    type: "ObjectExpression";
    properties: Array<Property | SpreadElement>;
}

interface PrivateIdentifier extends BaseNode {
    type: "PrivateIdentifier";
    name: string;
}

interface Property extends BaseNode {
    type: "Property";
    key: Expression | PrivateIdentifier;
    value: Expression | Pattern; // Could be an AssignmentProperty
    kind: "init" | "get" | "set";
    method: boolean;
    shorthand: boolean;
    computed: boolean;
}

interface PropertyDefinition extends BaseNode {
    type: "PropertyDefinition";
    key: Expression | PrivateIdentifier;
    value?: Expression | null | undefined;
    computed: boolean;
    static: boolean;
}

interface FunctionExpression extends BaseFunction, BaseExpression {
    id?: Identifier | null | undefined;
    type: "FunctionExpression";
    body: BlockStatement;
}

interface SequenceExpression extends BaseExpression {
    type: "SequenceExpression";
    expressions: Expression[];
}

interface UnaryExpression extends BaseExpression {
    type: "UnaryExpression";
    operator: UnaryOperator;
    prefix: true;
    argument: Expression;
}

interface BinaryExpression extends BaseExpression {
    type: "BinaryExpression";
    operator: BinaryOperator;
    left: Expression | PrivateIdentifier;
    right: Expression;
}

interface AssignmentExpression extends BaseExpression {
    type: "AssignmentExpression";
    operator: AssignmentOperator;
    left: Pattern | MemberExpression;
    right: Expression;
}

interface UpdateExpression extends BaseExpression {
    type: "UpdateExpression";
    operator: UpdateOperator;
    argument: Expression;
    prefix: boolean;
}

interface LogicalExpression extends BaseExpression {
    type: "LogicalExpression";
    operator: LogicalOperator;
    left: Expression;
    right: Expression;
}

interface ConditionalExpression extends BaseExpression {
    type: "ConditionalExpression";
    test: Expression;
    alternate: Expression;
    consequent: Expression;
}

interface BaseCallExpression extends BaseExpression {
    callee: Expression | Super;
    arguments: Array<Expression | SpreadElement>;
}
type CallExpression = SimpleCallExpression | NewExpression;

interface SimpleCallExpression extends BaseCallExpression {
    type: "CallExpression";
    optional: boolean;
}

interface NewExpression extends BaseCallExpression {
    type: "NewExpression";
}

interface MemberExpression extends BaseExpression, BasePattern {
    type: "MemberExpression";
    object: Expression | Super;
    property: Expression | PrivateIdentifier;
    computed: boolean;
    optional: boolean;
}

type Pattern = IdentifiE‹@H‹MA‹ÖA¹   H‹EH‹ H‹€   ÿPM‹Ç3É‰L$ ‰L$(E‹@H‹MA‹ÖA¹   H‹EH‹ H‹€   ÿPÇE¼   éT  ÷Æ   t'÷Æ   •Â¶ÒH‹MD‹ÇD‹ËèÏ  ¶È‰M¼é%  I‹Ïƒ9ÿ…‡   H‹Mè®PüÿH‹M‹ÓA¸   H‹EH‹ H‹€   ÿP(H‹M‹×D‹ÃE3Éè/  H‹M‹×D‹ÃèÀ£ıÿ„ÀtÇE¼   éÁ   3É‰L$ ‰L$(H‹M‹×D‹ÃA¹   H‹EH‹ H‹€   ÿPé‹   AƒşÿuÇE¼   é€   M‹ÇE‹@H‹MA‹ÖA¹   èµ  „Àu	ÇE¼   ëYI‹ÏƒyÿtH‹MA‹ÖèÂ¢ıÿ„Àt	ÇE¼   ë6M‹Ç3É‰L$ ‰L$(E‹@H‹MA‹ÖA¹   H‹EH‹ H‹€   ÿPÇE¼   H‹Ìè5   ëH‹Ìè+   ¸   HeÈ[^_A\A]A^A_]Ã‹E¼HeÈ[^_A\A]A^A_]ÃUAWAVAUATWVSHƒìHH‹i8H‰l$8H­°   H‹M‹‰¬  ÿÉH‹E‰ˆ¬  …Éu
H‹Mè¾óüÿHƒÄH[^_A\A]A^A_]ÃÌÌÌÌÌÌÌÌÌÌÌÌUAVWVSHƒìpH¬$   H‹ñH}¸¹
   3Àó«H‹ÎH‰e¨H‰MA‹ğA‹ùH‹Mÿ¬  H‹M‹™(  ƒû‡»  ‹ËH¿×Šÿ‹ˆLĞÿÿÿIÀÿà„Ò„>  H‹MH™à  H‹Ëƒ9ÿ…Š   H‹MèoNüÿH‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPH‹M‹ÖD‹ÇE3ÉèíŒ  H‹M‹ÖD‹Çè~¡ıÿ„ÀtÇEÜ   é  3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPéè  L‹EIÀÈ  E‹ E‹ÀAöÀ€„Ó   L‹ÃE‹@H‹M‹ÖA¹   èkŒ  „ÀuÇEÜ   é¬  H‹Ë‹	‰MĞH‹Ë‹I‰MÈH‹ML±ğ  I‹Îƒ9ÿtH‹Ëƒ9ÿtH‹M‹ÖèS ıÿ„ÀtÇEÜ   éd  M‹ÆA‹E‹FD‰D$ LEÈL‰D$(D‹EÈD‰D$0LEĞH‹MD‹Îè‘ E3ÀD‰D$ D‰D$(D‹CH‹M‹ÖE3ÉH‹EH‹ H‹€   ÿPéú  L‹ÃE‹@H‹M‹ÖA¹   è˜‹  „ÀuÇEÜ   éÙ  H‹ËƒyÿtH‹M‹Öè£Ÿıÿ„ÀtÇEÜ   é´  H‹Mè©LüÿL‹ÃE‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPL‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPéK  H‹MH™à  H‹Ëƒ9ÿ…Š   H‹Mè1LüÿH‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPH‹M‹ÖD‹ÇE3Éè¯Š  H‹M‹ÖD‹Çè@Ÿıÿ„ÀtÇEÜ   éá
  3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPéª   L‹ÃE‹@H‹M‹ÖA¹   èHŠ  „ÀuÇEÜ   é‰
  H‹ËƒyÿtH‹M‹ÖèSıÿ„ÀtÇEÜ   éd
  H‹MèYKüÿL‹ÃE‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPL‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPÇEÜ   éü	  „Ò„&  H‹MH™à  H‹Ëƒ9ÿ…‡   H‹MèÒJüÿH‹M‹ÖA¸   H‹EH‹ H‹€   ÿP H‹M‹ÖD‹ÇE3ÉèS‰  H‹M‹ÖD‹Çèäıÿ„ÀtÇEÜ   é…	  3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPéÉ  L‹EIÀÈ  E‹ E‹ÀAöÀ€„³   L‹ÃE‹@H‹M‹ÖA¹   èÑˆ  „ÀuÇEÜ   é	  H‹ML±ğ  I‹Îƒ9ÿtH‹ËƒyÿtH‹M‹ÖèÉœıÿ„ÀtÇEÜ   éÚ  H‹MèÏIüÿM‹ÆE‹ H‹M‹ÖA¹   è»  L‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖE3ÉH‹EH‹ H‹€   ÿPéû  L‹ÃE‹@H‹M‹ÖA¹   èˆ  „ÀuÇEÜ   é_  H‹Ëƒ9ÿtH‹M‹Öè*œıÿ„ÀtÇEÜ   é;  H‹Ó‹H‹ME3ÀH‹EH‹ H‹€   ÿP H‹M‹ÖA¸   H‹EH‹ H‹€   ÿP L‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPéA  H‹MH™à  H‹Ëƒ9ÿ…‡   H‹Mè¬HüÿH‹M‹ÖA¸   H‹EH‹ H‹€   ÿP H‹M‹ÖD‹ÇE3Éè-‡  H‹M‹ÖD‹Çè¾›ıÿ„ÀtÇEÜ   é_  3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPé£   L‹ÃE‹@H‹M‹ÖA¹   èÆ†  „ÀuÇEÜ   é  H‹ËƒyÿtH‹M‹ÖèÑšıÿ„ÀtÇEÜ   éâ  H‹Mè×GüÿH‹M‹ÖA¸   H‹EH‹ H‹€   ÿP L‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPÇEÜ   é  „Ò„‚  H‹MH™à  H‹Ëƒ9ÿ…Š   H‹MèWGüÿH‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPH‹M‹ÖD‹ÇE3ÉèÕ…  H‹M‹ÖD‹Çèfšıÿ„ÀtÇEÜ   é  3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPé´  L‹EIÀÈ  E‹ E‹ÀAöÀ€„^  L‹ÃE‹@H‹M‹ÖA¹   èS…  „ÀuÇEÜ   é”  H‹ML±ğ  I‹Îƒ9ÿtH‹Ëƒ9ÿtH‹M‹ÖèL™ıÿ„ÀtÇEÜ   é]  H‹MHƒ¹è    u)H‹MH‹EH‹ H‹€   ÿP0H‹UHŠè   H‹ĞÿµXwÿH‹UH‹Šè   H‹Ó‹9	ÿõSÿH‹ÈH‹ H‹@PÿP„Àt$H‹MèòEüÿM‹ÆE‹ H‹M‹ÖA¹   è*·  ëJL‹ÃE‹ D‰EÀL‹ÃE‹@D‰E¸M‹ÆA‹M‹ÆE‹@D‰D$ LE¸L‰D$(D‹E¸D‰D$0LEÀH‹MD‹Îèî L‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖE3ÉH‹EH‹ H‹€   ÿPé;  L‹ÃE‹@H‹M‹ÖA¹   èõƒ  „ÀuÇEÜ   é6  H‹Ëƒ9ÿtH‹M‹ÖD‹Çèn˜ıÿ„ÀtÇEÜ   é  H‹MHƒ¹è    u)H‹MH‹EH‹ H‹€   ÿP0H‹UHŠè   H‹ĞÿgWwÿH‹UH‹Šè   H‹Ó‹9	ÿ§
SÿH‹ÈH‹ H‹@PÿP„Àt<H‹Ó‹H‹ME3ÀH‹EH‹ H‹€   ÿP H‹M‹ÖA¸   H‹EH‹ H‹€   ÿP ëIL‹ÃA‹L‹ÃE‹@H‹ME3ÉH‹EH‹ H‹€   ÿPL‹ÃE‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPL‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPéÓ  H‹MH™à  H‹Ëƒ9ÿ…Š   H‹MèÕCüÿH‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPH‹M‹ÖD‹ÇE3ÉèS‚  H‹M‹ÖD‹Çèä–ıÿ„ÀtÇEÜ   é…  3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPé2  L‹ÃE‹@H‹M‹ÖA¹   èì  „ÀuÇEÜ   é-  H‹Ëƒ9ÿtH‹M‹Öèø•ıÿ„ÀtÇEÜ   é	  H‹MHƒ¹è    u)H‹MH‹EH‹ H‹€   ÿP0H‹UHŠè   H‹ĞÿaUwÿH‹UH‹Šè   H‹Ó‹9	ÿ¡SÿH‹ÈH‹ H‹@PÿP„Àt)H‹MèBüÿH‹M‹ÖA¸   H‹EH‹ H‹€   ÿP ë.H‹MèuBüÿL‹ÃE‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPL‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPÇEÜ   é  H‹MH™à  H‹Ëƒ9ÿ…„   H‹MèöAüÿH‹M‹×A¸   H‹EH‹ H‹€   ÿP(H‹M‹ÖD‹ÇE3Éèw€  H‹M‹ÖD‹Çè•ıÿ„ÀtÇEÜ   é©   3É‰L$ ‰L$(H‹M‹ÖD‹ÇA¹   H‹EH‹ H‹€   ÿPëvL‹ÃE‹@H‹M‹ÖA¹   è€  „Àu	ÇEÜ   ëWH‹ËƒyÿtH‹M‹Öè!”ıÿ„Àt	ÇEÜ   ë5L‹Ã3É‰L$ ‰L$(E‹@H‹M‹ÖA¹   H‹EH‹ H‹€   ÿPÇEÜ   H‹Ìè)   ëH‹Ìè   ¸   Heà[^_A^]Ã‹EÜHeà[^_A^]ÃUAVWVSHƒì@H‹i8H‰l$8H­   H‹M‹‰¬  ÿÉH‹E‰ˆ¬  …Éu
H‹Mè0åüÿHƒÄ@[^_A^]ÃÌÌÌÌUAWAVATWVSHì    H¬$Ğ   H‹ñH}¨¹
   3Àó«H‹ÎH‰¥hÿÿÿH‰M‹òH‹MHƒ¹è    u)H‹MH‹EH‹ H‹€   ÿP0H‹UHŠè   H‹Ğÿ RwÿH‹MH‹‰è   º@   9	ÿXSÿH…Àt‹H(ë¹ÿÿÿÿ‹ùƒÿÿtn3ÛH‹ML±à  I‹ÎƒyÿuiH‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿ%RwÿH‹MH‹‰à   º@   9	ÿıÂhÿD‹øAƒÿÿu3ÀHeĞ[^_A\A^A_]ÃI‹ÎD‹yH‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿµQwÿH‹MH‹‰à   A‹×H‹H‹@XÿP(¨„  H‹MH‹‰ˆ  ƒy é   H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿIQwÿH‹MH‹‰à   º@   A¸   9	ÿ;Âhÿ‹ØI‹ÎH‹Uƒ9ÿtI‹ÎD‹ëD‹ÇH‹ÊA‹ĞD‹ÃA¹   ÿ%ñRÿ„À„  H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿ¾PwÿL‹EI‹ˆà   M‹ÆE‹@D‹Ëº@   9	è\% XÿëH‹MH‹‰ˆ  ‹YH‹MH‹‰ˆ  Y$E‹ç…Ûuh»   ëaH‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿ6PwÿH‹MH‹‰à   A‹×A¸@   9	ÿjÁhÿD‹àAƒüÿtE‹üÿË…Û~Aƒüÿu•H‹Mÿ¬  I‹Î‹ƒúÿ…ú   H‹MèP=üÿH‹MD‹±(  AƒşwxA‹ÎHeÆŠÿ‹ŠLäüÿÿIĞÿâH‹M‹×E‹ÇA¹   H‹EH‹ H‹€   ÿPë=H‹MA‹×A¸   H‹EH‹ H‹€   ÿP(ëH‹M‹×A¸   H‹EH‹ H‹€   ÿP H‹M‹×E‹ÇE3Éèe{  H‹M‹×E‹Çèöıÿ„ÀtÇEÌ   é  3É‰L$ ‰L$(H‹M‹×E‹ÇA¹   H‹EH‹ H‹€   ÿPÇEÌ   ég  H‹E‹˜(  ƒû‡^  ‹ËLˆÅŠÿE‹ˆLòûÿÿMÁAÿàH‹ME‹ÇA¹   èĞz  „ÀuÇEÌ   é  I‹Îƒ9ÿtH‹MA‹×èıÿ„ÀtÇEÌ   éò  ÷Æ   „~   L‹EIÀÈ  E‹ E‹ÀAöÀ€tgM‹ÆE‹ D‰EÀM‹ÆE‹@D‰E¸L‹EI¸ğ  L‹ÇAƒxÿuÇEÌ   é™  L‹ÇA‹D‹MÀD‹GD‰D$ LE¸L‰D$(D‰|$0LEÀH‹MèÃ ë-H‹MèW;üÿI‹Ö‹H‹ME‹ÇA¹   H‹EH‹ H‹€   ÿP3Ò‰T$ ‰T$(A‹H‹ME‹ÇE3ÉH‹EH‹ H‹€   ÿPÇEÌ   é  H‹ME‹ÇA¹   èy  „ÀuÇEÌ   éä  I‹Îƒ9ÿtH‹MA‹×èØıÿ„ÀtÇEÌ   é¿  H‹Mè®:üÿ÷Æ   tjH‹UHÂÈ  ‹‹ÒöÂ€tVH‹UHºğ  H‹×D‹BAƒøÿuÇEÌ   éu  E;Ç}A‹ĞH‹ME‹ÇA¹   è­  ë3H‹MA‹×A¹   èî¬  ëH‹MA‹×A¸   H‹EH‹ H‹€   ÿP(I‹Ö3É‰L$ ‰L$(‹H‹ME‹ÇE3ÉH‹EH‹ H‹€   ÿPÇEÌ   éï  H‹ME‹ÇA¹   è…x  „ÀuÇEÌ   éÌ  I‹Îƒ9ÿtH‹MA‹×èÀıÿ„ÀtÇEÌ   é§  ÷Æ   „*  H‹MHÁÈ  ‹	‹ÉöÁ€„  H‹MH¹ğ  H‹ÏƒyÿuÇEÌ   éc  H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿµKwÿH‹UH‹Šà   I‹Ö‹RH‹H‹@XÿP(¨ tPH‹Mèü8üÿH‹×D9z}H‹×‹RH‹ME‹ÇA¹   èŠ«  é  L‹ÇE‹@H‹MA‹×A¹   èk«  éù   M‹ÆE‹ D‰E°M‹ÆE‹@D‰E¨L‹ÇA‹D‹M°L‹ÇE‹@D‰D$ LE¨L‰D$(D‰|$0LE°H‹MèÏ é­   H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿÃJwÿH‹UH‹Šà   I‹Ö‹RH‹H‹@XÿP(¨ t*H‹Mè
8üÿH‹MA‹×A¸   H‹EH‹ H‹€   ÿP(ë-H‹Mèà7üÿI‹Ö‹H‹ME‹ÇA¹   H‹EH‹ H‹€   ÿPM‹ÎA‹L‹MIÁÈ  3É‰L$ ‰L$(E‹	E‹ÉAöÁ€A”ÁE¶ÉH‹ME‹ÇH‹EH‹ H‹€   ÿPÇEÌ   ëvH‹ME‹ÇA¹   èv  „Àu	ÇEÌ   ëVI‹Îƒ9ÿtH‹MA‹×èJ‹ıÿ„Àt	ÇEÌ   ë4I‹Ö3É‰L$ ‰L$(‹H‹ME‹ÇA¹   H‹EH‹ H‹€   ÿPÇEÌ   H‹Ìè4   ëH‹Ìè*   ¸   HeĞ[^_A\A^A_]Ã‹EÌ¶ÀHeĞ[^_A\A^A_]ÃUAWAVATWVSHƒì@H‹i8H‰l$8H­Ğ   H‹M‹‰¬  ÿÉH‹E‰ˆ¬  …Éu
H‹MèÛüÿHƒÄ@[^_A\A^A_]ÃÌÌÌÌÌÌÌÌÌÌÌUAWAVATWVSHì°   H¬$à   H‹ñH}¨¹
   3Àó«H‹ÎH‰¥XÿÿÿH‰M‹òH‹MHƒ¹è    u)H‹MH‹EH‹ H‹€   ÿP0H‹UHŠè   H‹Ğÿ€HwÿH‹MH‹‰è   º@   9	ÿ8üRÿH…Àt‹H(ë¹ÿÿÿÿ‹ùƒÿÿtlH‹MH™à  H‹ËƒyÿuiH‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿHwÿH‹MH‹‰à   º@   9	ÿß¸hÿD‹ğAƒşÿu3ÀHeĞ[^_A\A^A_]ÃH‹ËD‹qH‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿ—GwÿH‹MH‹‰à   A‹ÖH‹H‹@XÿP(¨tH‹MH‹‰ˆ  D‹yëH‹MH‹‰ˆ  D‹y$E…ÿuA¿   E‹æëbH‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿGwÿH‹MH‹‰à   A‹ÖA¸@   9	ÿˆ¸hÿD‹àAƒüÿtE‹ôAÿÏE…ÿ~Aƒüÿu“H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿ§FwÿH‹MH‹‰à   A‹ÖH‹H‹@XÿP(¨„á   H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿPFwÿH‹MH‹‰à   º@   A¸   9	ÿB·hÿD‹ÀAƒøÿt1H‹ËH‹Uƒ9ÿtH‹ËD‹	ëD‹ÏH‹ÊA‹ÑA¹   ÿ(æRÿ„À„Õ  H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹ĞÿÁEwÿH‹MH‹‰à   ºB   9	ÿ™¶hÿD‹ğH‹Mÿ¬  H‹Ë‹ƒúÿ…÷   H‹Mèô2üÿH‹M‹™(  ƒûww‹ËH4¼Šÿ‹ŠL«üÿÿIĞÿâH‹M‹×E‹ÆA¹   H‹EH‹ H‹€   ÿPë=H‹MA‹ÖA¸   H‹EH‹ H‹€   ÿP(ëH‹M‹×A¸   H‹EH‹ H‹€   ÿP H‹M‹×E‹ÆE3Éèq  H‹M‹×E‹Æè…ıÿ„ÀtÇEÌ   é—  3É‰L$ ‰L$(H‹M‹×E‹ÆA¹   H‹EH‹ H‹€   ÿPÇEÌ   éa  H‹ED‹¸(  Aƒÿ‡V  A‹ÏLT»ŠÿE‹ˆL¶ûÿÿMÁAÿàH‹ME‹ÆA¹   ètp  „ÀuÇEÌ   é  H‹Ëƒ9ÿtH‹MA‹Öè¯…ıÿ„ÀtÇEÌ   éé  ÷Æ   „}   L‹EIÀÈ  E‹ E‹ÀAöÀ€tfL‹ÃE‹ D‰EÀL‹ÃE‹@D‰E¸L‹EI¸ğ  L‹ÇAƒ8ÿuÇEÌ   é‘  L‹ÇA‹D‹MÀD‹GD‰D$ LE¸L‰D$(D‰t$0LEÀH‹Mèhş  ë-H‹Mèü0üÿH‹Ó‹H‹ME‹ÆA¹   H‹EH‹ H‹€   ÿP3Ò‰T$ ‰T$(‹H‹ME‹ÆE3ÉH‹EH‹ H‹€   ÿPÇEÌ   é   H‹ME‹ÆA¹   èCo  „ÀuÇEÌ   éİ  H‹Ëƒ9ÿtH‹MA‹Öè~„ıÿ„ÀtÇEÌ   é¸  H‹MèT0üÿ÷Æ   tjH‹UHÂÈ  ‹‹ÒöÂ€tVH‹UHºğ  H‹×D‹BAƒøÿuÇEÌ   én  E;Æ}A‹ĞH‹ME‹ÆA¹   è©¢  ë3H‹MA‹ÖA¹   è”¢  ëH‹MA‹ÖA¸   H‹EH‹ H‹€   ÿP(H‹Ó3É‰L$ ‰L$(‹H‹ME‹ÆE3ÉH‹EH‹ H‹€   ÿPÇEÌ   éè  H‹ME‹ÆA¹   è+n  „ÀuÇEÌ   éÅ  H‹Ëƒ9ÿtH‹MA‹Öèfƒıÿ„ÀtÇEÌ   é   ÷Æ   „#  H‹MHÁÈ  ‹	‹ÉöÁ€„  H‹MH¹ğ  H‹ÏƒyÿuÇEÌ   é\  H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿ[AwÿH‹UH‹Šà   H‹Ó‹RH‹H‹@XÿP(¨ tIH‹Mè¢.üÿH‹×D‹BE;Æ}A‹ĞH‹ME‹ÆA¹   è0¡  é  H‹MA‹ÖA¹   è¡  éù   L‹ÃE‹ D‰E°L‹ÃE‹@D‰E¨L‹ÇA‹D‹M°L‹ÇE‹@D‰D$ LE¨L‰D$(D‰t$0LE°H‹Mè|û  é­   H‹MHƒ¹à    u)H‹MH‹EH‹ H‹€   ÿP8H‹UHŠà   H‹Ğÿp@wÿH‹UH‹Šà   H‹Ó‹RH‹H‹@XÿP(¨ t*H‹Mè·-üÿH‹MA‹ÖA¸   H‹EH‹ H‹€   ÿP(ë-H‹Mè-üÿH‹Ó‹H‹ME‹ÆA¹   H‹EH‹ H‹€   ÿPL‹ËA‹L‹MIÁÈ  3É‰L$ ‰L$(E‹	E‹ÉAöÁ€A”ÁE¶ÉH‹ME‹ÆH‹EH‹ H‹€   ÿPÇEÌ   ëvH‹ME‹ÆA¹   è¹k  „Àu	ÇEÌ   ëVH‹Ëƒ9ÿtH‹MA‹Öè÷€ıÿ„Àt	ÇEÌ   ë4H‹Ó3É‰L$ ‰L$(‹H‹ME‹ÆA¹   H‹EH‹ H‹€   ÿPÇEÌ   H‹Ìè4   ëH‹Ìè*   ¸   HeĞ[^_A\A^A_]Ã‹EÌ¶ÀHeĞ[^_A\A^A_]ÃUAWAVATWVSHƒì@H‹i8H‰l$8H­à   H‹M‹‰¬  ÿÉH‹E‰ˆ¬  …Éu
H‹MèÈĞüÿHƒÄ@[^_A\A^A_]ÃÌÌÌÌÌÌÌÌWVHƒì(H‹ñ‹úH‹Îè\äúÿ„ÀtH‹Î‹×H‹lİRÿHƒÄ(^_HÿàH‹Î‹×H‹İRÿHƒÄ(^_HÿàÌÌÌÌÌÌÌÌÌÌÌÌÌÌUAWAVAUATWVSHƒìxH¬$°   H‹ñH}˜¹   3Àó«H‹ÎH‰eˆH‰M‹òL‹EE‹€À  H‹M‹ÖèDÉÿÿ‰EÀ€}À t(€}À u¹&   ÿª»Wÿ‹EÁ¶ÀHeÈ[^_A\A]A^A_]ÃH‹MHƒ¹è    u)H‹MH‹EH‹ H‹€   ÿP0H‹UHŠè   H‹Ğÿœ=wÿH‹MH‹‰è   º@   E3À9	ÿañRÿH…Àt‹H(ë¹ÿ