import { __commonJS, __require } from "./chunk.js";
import { require_lib } from "./lib.js";

//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/format-import-prelude.js
var require_format_import_prelude = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/format-import-prelude.js": ((exports, module) => {
	module.exports = function formatImportPrelude$2(layer, media, supports) {
		const parts = [];
		if (typeof layer !== "undefined") {
			let layerParams = "layer";
			if (layer) layerParams = `layer(${layer})`;
			parts.push(layerParams);
		}
		if (typeof supports !== "undefined") parts.push(`supports(${supports})`);
		if (typeof media !== "undefined") parts.push(media);
		return parts.join(" ");
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/base64-encoded-import.js
var require_base64_encoded_import = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/base64-encoded-import.js": ((exports, module) => {
	const formatImportPrelude$1 = require_format_import_prelude();
	module.exports = function base64EncodedConditionalImport$1(prelude, conditions) {
		if (!conditions?.length) return prelude;
		conditions.reverse();
		const first = conditions.pop();
		let params = `${prelude} ${formatImportPrelude$1(first.layer, first.media, first.supports)}`;
		for (const condition of conditions) params = `'data:text/css;base64,${Buffer.from(`@import ${params}`).toString("base64")}' ${formatImportPrelude$1(condition.layer, condition.media, condition.supports)}`;
		return params;
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/apply-conditions.js
var require_apply_conditions = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/apply-conditions.js": ((exports, module) => {
	const base64EncodedConditionalImport = require_base64_encoded_import();
	module.exports = function applyConditions$1(bundle, atRule) {
		const firstImportStatementIndex = bundle.findIndex((stmt) => stmt.type === "import");
		const lastImportStatementIndex = bundle.findLastIndex((stmt) => stmt.type === "import");
		bundle.forEach((stmt, index) => {
			if (stmt.type === "charset" || stmt.type === "warning") return;
			if (stmt.type === "layer" && (index < lastImportStatementIndex && stmt.conditions?.length || index > firstImportStatementIndex && index < lastImportStatementIndex)) {
				stmt.type = "import";
				stmt.node = stmt.node.clone({
					name: "import",
					params: base64EncodedConditionalImport(`'data:text/css;base64,${Buffer.from(stmt.node.toString()).toString("base64")}'`, stmt.conditions)
				});
				return;
			}
			if (!stmt.conditions?.length) return;
			if (stmt.type === "import") {
				stmt.node.params = base64EncodedConditionalImport(stmt.fullUri, stmt.conditions);
				return;
			}
			let nodes;
			let parent;
			if (stmt.type === "layer") {
				nodes = [stmt.node];
				parent = stmt.node.parent;
			} else {
				nodes = stmt.nodes;
				parent = nodes[0].parent;
			}
			const atRules = [];
			for (const condition of stmt.conditions) {
				if (typeof condition.media !== "undefined") {
					const mediaNode = atRule({
						name: "media",
						params: condition.media,
						source: parent.source
					});
					atRules.push(mediaNode);
				}
				if (typeof condition.supports !== "undefined") {
					const supportsNode = atRule({
						name: "supports",
						params: `(${condition.supports})`,
						source: parent.source
					});
					atRules.push(supportsNode);
				}
				if (typeof condition.layer !== "undefined") {
					const layerNode = atRule({
						name: "layer",
						params: condition.layer,
						source: parent.source
					});
					atRules.push(layerNode);
				}
			}
			const outerAtRule = atRules.shift();
			const innerAtRule = atRules.reduce((previous, next) => {
				previous.append(next);
				return next;
			}, outerAtRule);
			parent.insertBefore(nodes[0], outerAtRule);
			nodes.forEach((node) => {
				node.parent = void 0;
			});
			nodes[0].raws.before = nodes[0].raws.before || "\n";
			innerAtRule.append(nodes);
			stmt.type = "nodes";
			stmt.nodes = [outerAtRule];
			delete stmt.node;
		});
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/apply-raws.js
var require_apply_raws = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/apply-raws.js": ((exports, module) => {
	module.exports = function applyRaws$1(bundle) {
		bundle.forEach((stmt, index) => {
			if (index === 0) return;
			if (stmt.parent) {
				const { before } = stmt.parent.node.raws;
				if (stmt.type === "nodes") stmt.nodes[0].raws.before = before;
				else stmt.node.raws.before = before;
			} else if (stmt.type === "nodes") stmt.nodes[0].raws.before = stmt.nodes[0].raws.before || "\n";
		});
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/apply-styles.js
var require_apply_styles = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/apply-styles.js": ((exports, module) => {
	module.exports = function applyStyles$1(bundle, styles) {
		styles.nodes = [];
		bundle.forEach((stmt) => {
			if ([
				"charset",
				"import",
				"layer"
			].includes(stmt.type)) {
				stmt.node.parent = void 0;
				styles.append(stmt.node);
			} else if (stmt.type === "nodes") stmt.nodes.forEach((node) => {
				node.parent = void 0;
				styles.append(node);
			});
		});
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/data-url.js
var require_data_url = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/data-url.js": ((exports, module) => {
	const anyDataURLRegexp = /^data:text\/css(?:;(base64|plain))?,/i;
	const base64DataURLRegexp = /^data:text\/css;base64,/i;
	const plainDataURLRegexp = /^data:text\/css;plain,/i;
	function isValid(url) {
		return anyDataURLRegexp.test(url);
	}
	function contents(url) {
		if (base64DataURLRegexp.test(url)) return Buffer.from(url.slice(21), "base64").toString();
		if (plainDataURLRegexp.test(url)) return decodeURIComponent(url.slice(20));
		return decodeURIComponent(url.slice(14));
	}
	module.exports = {
		isValid,
		contents
	};
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/parse-statements.js
var require_parse_statements = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/parse-statements.js": ((exports, module) => {
	const valueParser = require_lib();
	const { stringify } = valueParser;
	module.exports = function parseStatements$1(result, styles, conditions, from) {
		const statements = [];
		let nodes = [];
		let encounteredNonImportNodes = false;
		styles.each((node) => {
			let stmt;
			if (node.type === "atrule") {
				if (node.name === "import") stmt = parseImport(result, node, conditions, from);
				else if (node.name === "charset") stmt = parseCharset(result, node, conditions, from);
				else if (node.name === "layer" && !encounteredNonImportNodes && !node.nodes) stmt = parseLayer(result, node, conditions, from);
			} else if (node.type !== "comment") encounteredNonImportNodes = true;
			if (stmt) {
				if (nodes.length) {
					statements.push({
						type: "nodes",
						nodes,
						conditions: [...conditions],
						from
					});
					nodes = [];
				}
				statements.push(stmt);
			} else nodes.push(node);
		});
		if (nodes.length) statements.push({
			type: "nodes",
			nodes,
			conditions: [...conditions],
			from
		});
		return statements;
	};
	function parseCharset(result, atRule, conditions, from) {
		if (atRule.prev()) return result.warn("@charset must precede all other statements", { node: atRule });
		return {
			type: "charset",
			node: atRule,
			conditions: [...conditions],
			from
		};
	}
	function parseImport(result, atRule, conditions, from) {
		let prev = atRule.prev();
		if (prev) do {
			if (prev.type === "comment" || prev.type === "atrule" && prev.name === "import") {
				prev = prev.prev();
				continue;
			}
			break;
		} while (prev);
		if (prev) do {
			if (prev.type === "comment" || prev.type === "atrule" && (prev.name === "charset" || prev.name === "layer" && !prev.nodes)) {
				prev = prev.prev();
				continue;
			}
			return result.warn("@import must precede all other statements (besides @charset or empty @layer)", { node: atRule });
		} while (prev);
		if (atRule.nodes) return result.warn("It looks like you didn't end your @import statement correctly. Child nodes are attached to it.", { node: atRule });
		const params = valueParser(atRule.params).nodes;
		const stmt = {
			type: "import",
			uri: "",
			fullUri: "",
			node: atRule,
			conditions: [...conditions],
			from
		};
		let layer;
		let media;
		let supports;
		for (let i = 0; i < params.length; i++) {
			const node = params[i];
			if (node.type === "space" || node.type === "comment") continue;
			if (node.type === "string") {
				if (stmt.uri) return result.warn(`Multiple url's in '${atRule.toString()}'`, { node: atRule });
				if (!node.value) return result.warn(`Unable to find uri in '${atRule.toString()}'`, { node: atRule });
				stmt.uri = node.value;
				stmt.fullUri = stringify(node);
				continue;
			}
			if (node.type === "function" && /^url$/i.test(node.value)) {
				if (stmt.uri) return result.warn(`Multiple url's in '${atRule.toString()}'`, { node: atRule });
				if (!node.nodes?.[0]?.value) return result.warn(`Unable to find uri in '${atRule.toString()}'`, { node: atRule });
				stmt.uri = node.nodes[0].value;
				stmt.fullUri = stringify(node);
				continue;
			}
			if (!stmt.uri) return result.warn(`Unable to find uri in '${atRule.toString()}'`, { node: atRule });
			if ((node.type === "word" || node.type === "function") && /^layer$/i.test(node.value)) {
				if (typeof layer !== "undefined") return result.warn(`Multiple layers in '${atRule.toString()}'`, { node: atRule });
				if (typeof supports !== "undefined") return result.warn(`layers must be defined before support conditions in '${atRule.toString()}'`, { node: atRule });
				if (node.nodes) layer = stringify(node.nodes);
				else layer = "";
				continue;
			}
			if (node.type === "function" && /^supports$/i.test(node.value)) {
				if (typeof supports !== "undefined") return result.warn(`Multiple support conditions in '${atRule.toString()}'`, { node: atRule });
				supports = stringify(node.nodes);
				continue;
			}
			media = stringify(params.slice(i));
			break;
		}
		if (!stmt.uri) return result.warn(`Unable to find uri in '${atRule.toString()}'`, { node: atRule });
		if (typeof media !== "undefined" || typeof layer !== "undefined" || typeof supports !== "undefined") stmt.conditions.push({
			layer,
			media,
			supports
		});
		return stmt;
	}
	function parseLayer(result, atRule, conditions, from) {
		return {
			type: "layer",
			node: atRule,
			conditions: [...conditions],
			from
		};
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/process-content.js
var require_process_content = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/process-content.js": ((exports, module) => {
	const path$2 = __require("path");
	let sugarss;
	module.exports = function processContent$1(result, content, filename, options, postcss) {
		const { plugins } = options;
		const ext = path$2.extname(filename);
		const parserList = [];
		if (ext === ".sss") {
			if (!sugarss)
 /* c8 ignore next 3 */
			try {
				sugarss = __require("sugarss");
			} catch {}
			if (sugarss) return runPostcss(postcss, content, filename, plugins, [sugarss]);
		}
		if (result.opts.syntax?.parse) parserList.push(result.opts.syntax.parse);
		if (result.opts.parser) parserList.push(result.opts.parser);
		parserList.push(null);
		return runPostcss(postcss, content, filename, plugins, parserList);
	};
	function runPostcss(postcss, content, filename, plugins, parsers, index) {
		if (!index) index = 0;
		return postcss(plugins).process(content, {
			from: filename,
			parser: parsers[index]
		}).catch((err) => {
			index++;
			if (index === parsers.length) throw err;
			return runPostcss(postcss, content, filename, plugins, parsers, index);
		});
	}
}) });

//#endregion
//#region ../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/parse-styles.js
var require_parse_styles = /* @__PURE__ */ __commonJS({ "../../node_modules/.pnpm/postcss-import@16.1.1_postcss@8.5.6/node_modules/postcss-import/lib/parse-styles.js": ((exports, module) => {
	const path$1 = __require("path");
	const dataURL = require_data_url();
	const parseStatements = require_parse_statements();
	const processContent = require_process_content();
	const resolveId$1 = (id) => id;
	const formatImportPrelude = require_format_import_prelude();
	async function parseStyles$1(result, styles, options, state, conditions, from, postcss) {
		const statements = parseStatements(result, styles, conditions, from);
		for (const stmt of statements) {
			if (stmt.type !== "import" || !isProcessableURL(stmt.uri)) continue;
			if (options.filter && !options.filter(stmt.uri)) continue;
			await resolveImportId(result, stmt, options, state, postcss);
		}
		let charset;
		const beforeBundle = [];
		const bundle = [];
		function handleCharset(stmt) {
			if (!charset) charset = stmt;
			else if (stmt.node.params.toLowerCase() !== charset.node.params.toLowerCase()) throw stmt.node.error(`Incompatible @charset statements:
  ${stmt.node.params} specified in ${stmt.node.source.input.file}
  ${charset.node.params} specified in ${charset.node.source.input.file}`);
		}
		statements.forEach((stmt) => {
			if (stmt.type === "charset") handleCharset(stmt);
			else if (stmt.type === "import") if (stmt.children) stmt.children.forEach((child, index) => {
				if (child.type === "import") beforeBundle.push(child);
				else if (child.type === "layer") beforeBundle.push(child);
				else if (child.type === "charset") handleCharset(child);
				else bundle.push(child);
				if (index === 0) child.parent = stmt;
			});
			else beforeBundle.push(stmt);
			else if (stmt.type === "layer") beforeBundle.push(stmt);
			else if (stmt.type === "nodes") bundle.push(stmt);
		});
		return charset ? [charset, ...beforeBundle.concat(bundle)] : beforeBundle.concat(bundle);
	}
	async function resolveImportId(result, stmt, options, state, postcss) {
		if (dataURL.isValid(stmt.uri)) {
			stmt.children = await loadImportContent(result, stmt, stmt.uri, options, state, postcss);
			return;
		} else if (dataURL.isValid(stmt.from.slice(-1))) throw stmt.node.error(`Unable to import '${stmt.uri}' from a stylesheet that is embedded in a data url`);
		const atRule = stmt.node;
		let sourceFile;
		if (atRule.source?.input?.file) sourceFile = atRule.source.input.file;
		const base = sourceFile ? path$1.dirname(atRule.source.input.file) : options.root;
		const paths = [await options.resolve(stmt.uri, base, options, atRule)].flat();
		const resolved = await Promise.all(paths.map((file) => {
			return !path$1.isAbsolute(file) ? resolveId$1(file, base, options, atRule) : file;
		}));
		resolved.forEach((file) => {
			result.messages.push({
				type: "dependency",
				plugin: "postcss-import",
				file,
				parent: sourceFile
			});
		});
		stmt.children = (await Promise.all(resolved.map((file) => {
			return loadImportContent(result, stmt, file, options, state, postcss);
		}))).flat().filter((x) => !!x);
	}
	async function loadImportContent(result, stmt, filename, options, state, postcss) {
		const atRule = stmt.node;
		const { conditions, from } = stmt;
		const stmtDuplicateCheckKey = conditions.map((condition) => fo*{K r# poå {K oT &{K oÿ *{K r¦S poå {K oT &{K oÿ *{K rb3 poå {K oT &{K oÿ *{K r^3 poå {K oT &{K oÿ *{K oü o¸ +8	o  
t o= o= (ì ,o= ( ( &Þr	o  
-ÀÞ	uN  ,o  
Ü{K o  -*{K r¯ poå {K oT &{K oÿ *{K oÿ r®S po= s z*      \D     0 Ñ   3 
.3
s o oÐ ,oÑ oS o  -o" oÃ ,moS oH oW ,oW o +K(K s. 	o	 o 	 o	 o	 o	 oä u^ oX o .3o˜	 &o 	 *   0 a   ; QQQs 
o˜	 &r* po‘	 ,oa	 Qr23 po‘	 ,oa	 QrD3 po‘	 ,oa	 QÞoš	 Ü*       HY     Â(x  
rðQ p(ð   % þ“  oE  
¢(— 
sf  
*Š-s *s* *0     4 {Q :Ž   {N o>  
1t{O o>  
1X{N rM  p{O (D  

{S oõ (À  
{Q -{S oõ o5 }Q Þ$,(Â  
Ü{N }Q +{O }Q {Q *   L )u 
    0 C   ª  
,<o>  
Y+oH  
:.baX
Y/ãcY
cY
cY
* 0 p       ( o# (2 o# (3 o# (4 o	# }V o
# }W o# -	o# +o# }X *’,{U `Ò}U *{U û_Ò}U *’,{U `Ò}U *{U ÷_Ò}U *  0        ,zo# {U _3jo# {U _þ3Wo# {U _þ3Do	# {V 36o
# {W 3(o# {X uƒ 3o# {X uq 3**†(<  
-rHQ p(ð s 
z}\ *   0 !   5 u 
,oè *oF oè *   0 .   7 o8 
-*o™, oD, oŸ, s] o› *  0      o8 
-*o, s] *   0 (   7 o8 
-*o™, oD, oŸ, s] *0 7   Ï  (x  
rÞS p(ð   %o@ 
 þ“  oE  
¢(— 
sf  
z 0 G   8 {\ o@ 	.{\ *{\ oG u 
,3{\ *{J ,3ç*ž{\ o@ 	3{\ t *{\ oF * 0    ‹  oA 
+3*oA 
,3ì* 0 "   ‹  oA 
+oA 
,
o@ 	3ìþ*  0   9 .	(L ,r T p(ð s 
z-oS *oI -r.T p(ð sf  
zoA .r`T p(ð s 
z3*oF 
oF ,..rŒT p(ð s 
zoV -rQ p(ð sf  
zoA ,oA oQ &o@ 30oG ,oQ &oN &oO &*u ,o@ oU -rØP p(ð sf  
zt t o> oA o~ ,o 	oG 36	}J oJ }J oz o† 9‡   	o† ,	(ˆ +v	oC t 	}J }J oz o† ,3o† ,(ˆ 	o† ,2	(ˆ +)	o† ,!	(‰ +o† ,	o† ,	(ˆ ,o€ *   0 #  : .	(L ,r T p(ð s 
z-oR *oI -r.T p(ð sf  
zoA .r`T p(ð s 
z3*oF 
oF ,..rŒT p(ð s 
zoW -rQ p(ð sf  
zoA ,oA oQ &o@ 3=oG +%oD 	oQ &oO &	-×*u ,o@ oU -rØP p(ð sf  
zt t o> oA o~ ,o 	oJ 3=	{J }J 	}J oK oz 	o† 9…   o† ,}	(ˆ +t	{J 

}J 	}J oz 	o† ,5o† ,	(ˆ 
o† ,6
(ˆ +,
o† ,#	
(‰ +o† ,
o† ,
(ˆ ,o€ * 0    È oD 
oQ &oN *  0 [  ; oI -r¾T p(ð sf  
zoA .rðT p(ð s 
zt 
o> o~ ,o oJ oG 3Z	