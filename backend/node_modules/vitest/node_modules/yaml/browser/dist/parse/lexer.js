import { BOM, DOCUMENT, FLOW_END, SCALAR } from './cst.js';

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = new Set('0123456789ABCDEFabcdef');
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(',[]{}');
const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== 'string')
                throw TypeError('source is not a string');
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            let cs = line.indexOf('#');
            while (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t') {
                    dirEnd = cs - 1;
                    break;
                }
                else {
             º   {5g	C   Æ	k* º   {5t	C   †Ø Â5  {5|	C   †î   {5	C   †» Â5  |5«	C   †Ñ   |5Ê	C   †Û Â5  }5×	C   †ñ   }5ö	C   †) Â5  ~5
C   †?   ~5
C   †ñ Â5  5-
C   †   5@
C   †7 Â5  €5R
C   †U   €5e
C   †ª Â5  5r
C   †Â   5€
C   Æ	¬ë º   ‚5
C   Æ	µç º   ‚5,ˆR   Æ	Ôç    ‚5š
C   †± Ö1  ƒ5§
C   †à  UÈ ƒ5¯
C   Ä†N    ƒ5À
C   Ä	TH   ƒ5Ì
C   „¨ º   ƒ5Ô
C   „ÑÈ    ƒ5¾ĞA   Æ.O  Â5  „5DÈA   Æ<O    „5ŒMB   †n‡ ü  …5•MB   †ƒ‡ ü  †5ëàD   uÕ º   ‡5tˆR   
t    ‡5öàD   ƒ9 ?¯ ˆ5 C   †  Â5  ˆ5C   †2   ˆ5C   †N Â5  ‰5(C   †`   ‰56C   †‚ Â5  Š5CC   †–   Š5QC   Æ	Xë º   ‹5ãˆR   Æ	hë    ‹5áD   ƒê ?¯ Œ5áD   ƒ3µ ?¯ Œ5áD   ƒ¯5 º   Œ5YC   †ç Â5  Œ5aC   †
   Œ5ƒC   † Â5  5‹C   †*   5­C   †ª Â5  5ºC   †Ä   5ÓC   †@ Â5  5ÛC   †Z   5ıC   †òK º   5C   †L    54áD   á	ñz º   ‘5"C   †† Â5  ‘5,C   †”   ‘5&ÉA   †[N o¯ ’5.ÉA   †gN İ¹ ’57ÉA   †‚} ü  “5@ÉA   †•} ü  ”5zC   †Í­ Ç •5‰R   †Ş­ Í •5‚C   †m( Ô –5ŠC   †¤t H   –5§C   †·t Š   –5¨‰R   †Aa Å —5ìR   †-a –5  ˜5ÉC   †[ Ú ˜5ØC   †Ÿ‘ ñ ˜5üC   †´‘ à ˜5İÑA   ÅQ  º   ™5İ0B   ÆL  Õ  ™5R   ÆL  ±)  ™5AáD   ƒïî º   š5øÉA   ÆáP  «  š5œèA   ÆêP  (   š5è,B   †q  ü  ›5ñ,B   † ü  œ5C   †HX º   5hR   †YX    5NáD   ƒR ?¯ 5C   Æ	xë º   5"C   Æ	‹ë    5^C   „Ç= ç Ÿ5uC   „İ= í Ÿ5‹C   †± Â5   5˜C   †Ã    5±C   †´ Â5  ¡5¾C   †Æ   ¡5×C   † Â5  ¢5ßC   †   ¢5 R    èR ô £5¦B   †[Ò Ä½ ¤5¦B   †gÒ Ä½ ¥5'¦B   †T  Ë½ ¦50¦B   †Ú}  Ë½ §5¦B   †ê× Ä½ ¨5¦B   †ô× Ä½ ©59¦B   †Fƒ  ° ª5B¦B   †dÏ ° «5K¦B   †ˆ× ° ¬5T¦B   †”× ° ­5OÅA   †w> ° ®5XÅA   †…> ° ¯5ÅA   †Š…  ü  °5"ÅA   †
x  ü  ±5+ÅA   †Ò; ü  ²54ÅA   †4ƒ  ü  ³5C   †À| û ´5C   †Ù| û µ5[áD   á	“x í  ¶5náD   á	óx í  ·5'C   †Øm  ¸5:C   †ïm  ¹5MC   †/ ü  º5`C   †G ü  »5sC   †‰ 	 ¼5†C   †¥ 	 ½5™C   †d‹ ü  ¾5¬C   †‹ ü  ¿5áD   ƒ 8Ñ  À5¤R   ƒ ‡Ñ  Â5¿C   †  Q    Æ5áD    ƒŠ    Æ5¢áD   ƒ Óf    Æ5·áD   ƒ Š] & Æ5è’R   Ä ¨Q  ?¯ Ç5ÕáD    Œ	 - Ç5 “R    "f 6 È5ÍA   ÄB  < È5(“R    sÑ E É5d”R    áË Q Ë5ŞáD   ƒ G:    Ï5È”R    ^    Ï5$–R   Ä M      Ï5øáD    ]ÿ    Ğ5ˆ—R    K ] Ñ5p˜R    bÛ e Ó5Ä˜R    |¶ l Ô5™R   ‘ ß€ t Ö57âD   áR    Ø5È™R    íc ˜  Ø5,šR    S]    Ù5àšR    EE    Ù5T›R    –    Ù5HœR    ƒS Õç Ù5¤œR   á¬ º   Ú5ÕC   † íP    Ú5@R   ‘ |] ~ Ú5DâD   ƒ F&	 Š Ü5 R   ƒ ›¡ CÉ Ü5$ŸR    I© “  İ5sâD   ƒ 0h  Ş5‘âD    Á	 – Ş5™âD   áƒ      Ş5ÏâD   ƒ  º   Ş5lŸR   á$% œ Ş5ØâD    ; £ ß5  R   á     á5h¡R    mµ (É â5¸¡R    Hg (É ä5¢R    “ « æ5t¢R    ? ³ è5 £R    ó¶ « ê5ìC   Ä ×S  Œ® ì5ûC   Ä èS  Œ® í5*bD   ƒ ” N° î5
C   Ä V  Œ® ï5ÿ£R   Ä [V  Œ® ğ5CC   Ä #W  Œ® ñ5¤R   Ä [  ¬  ò5œ¤R    6
    ô54©R   Ä X  N° õ5”©R   Ä ‡X  N° ö5ªR   Ä ˜X  N° ÷5§ÃA   áH  Ê  ø5zC   Ä =Y  Œ® ù5$ãD    Oó   ú5œC   „ G	 » ü5ÊC   „ u   ı5X«R   Ä ÀX  7° ÿ5äC   Ä Œ®  6C   Äö Â 6DC   Ä¢
 É 6à¬R   ƒ 0¼ Ğ 6;ãD   ƒ  Ø 6tC   Ä â 6¤C   Äÿ Œ® 6ˆ­R    # é 	6JãD    ,   6®R    !“ ñ 6<®R    ı_ ñ 6¨®R    _‚   6 ¯R    :ó   6ğ¯R    `¯   6ÒC   Ä U  Œ® 6œ±R   Ä@Z  ì¹ 6¼³R   Æ ºZ     6Ü³R    ºZ     6\´R   ƒ Àï    6Ğ´R   † 5( & 60¶R   ƒ ^Ñ [ë 6·R    °S    6@·R   ƒ ^] ø 6Ì¸R   ƒ }Ñ î  6<ºR   ƒ }Ñ V   !6UãD    ”à    "6bãD    ;ß    "6oãD    ·á    "6ãD    …á    "6“ãD    9á    "6¥ãD    là    "6¥ãD    üŞ    "6 »R   ƒ Í Û  "6øC   † \ä    $6\»R    ïN    $6¬»R   á4' œ $6T¼R    ê    %6²ãD   ƒ S	 ö  &6ÄãD    Çc   (6¸¼R    ®Î  *6Ô½R    w¢    +6P¾R    ¯    ,6êãD    ›    ,6˜¾R    ›    ,6ÄÂR   „ Tf    -6"ÃR   Ä	ğ. J  .68ÃR   Ä	Ø. J  .6NÃR ine[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else {
                this.indentNext =
                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ')
            ch = this.buffer[++i];
        if (ch === '\t') {
            while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')
                ch = this.buffer[++i];
            nl = i - 1;
        }
        else if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && flowIndicatorChars.has(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.has(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.has(this.buffer[i + 1]) &&
                    hexDigits.has(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

export { Lexer };
