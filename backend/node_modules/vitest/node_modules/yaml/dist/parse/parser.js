'use strict';

var node_process = require('process');
var cst = require('./cst.js');
var lexer = require('./lexer.js');

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !it.explicitKey;
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent &&
                (it.sep || it.explicitKey) &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start, explicitKey: true });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken], explicitKey: true }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key;
                            // @ts-expect-error type guard is wrong here
                            delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (bv.t b r i d   
 { \ l i s t l e v e l  \ l e v e l n f c  \ l e v e l n f c n  \ l e v e l j c 0  \ l e v e l j c n 0  \ l e v e l f o l l o w 0  \ l e v e l s t a r t a t  \ l e v e l s p a c e 0  \ l e v e l i n d e n t 0  { \ l e v e l t e x t  !\ l e v e l t e m p l a t e i d  \ ' 0 1 \ ' b 7 } !{ \ l e v e l n u m b e r s ; }  \ ' 0 2 \ ' 0 . ; }  ){ \ l e v e l n u m b e r s \ ' 0 1 ; } \ f i - 3 6 0 \ l i  	\ l i n  \ j c l i s t t a b \ t x   
 { \ l i s t n a m e   ; }  \ l i s t i d  }  
  +{ \ * \ l i s t o v e r r i d e t a b l e  ! 
 { \ l i s t o v e r r i d e  '\ l i s t o v e r r i d e c o u n t 0  \ l s   
 }  
  \ l i n e    \ l a n g  \ l o c h  \ b  \ b 0  \ i  \ i 0  \ u l  	\ u l 0  \ s t r i k e  \ s t r i k e 0  \ f s  \ c f  \ h i g h l i g h t  \ s u p e r  \ s u p e r 0  	\ s u b  \ s u b 0  \ l t r c h  \ r t l c h  A{ \ f i e l d { \ * \ f l d i n s t   {   H Y P E R L I N K   "  \ \  "   } } { \ f l d r s l t   {  } } }  	\ p a r  \ r t l p a r  \ q l  \ q r  \ q c  \ q j  \ s l  \ s l m u l t 0  \ i n t b l  \ i t a p  \ r i  \ s a  \ s b  \ f i  \ c b p a t  \ n e s t c e l l  '{ \ n o n e s t t a b l e s \ p a r }  \ c e l l  { \ l i s t t e x t    \ t a b }  \ i l v l  { \ p n t e x t    \ t a b } { \ * \ p n  \ p n l v l  \ p n h a n g  \ p n s t a r t  { \ p n t x t b \ ' B 7 } } +{ \ p n t x t a   } { \ p n t x t b   } }  { \ p n t x t a   . } }  \ i n t b l \ i t a p  #\ * \ n e s t t a b l e p r o p s  \ n e s t r o w  	\ r o w  } }  \ t r o w d  \ t r l e f t  \ t r g a p h - \ t r g a p h 0  \ t r l e f t 0  \ t r q l  \ r t l r o w  \ l t r r o w  \ t r b r d r t  \ t r b r d r b  \ t r b r d r r  \ t r b r d r l  \ t r b r d r v  \ t r b r d r h  \ t r f t s W i d t h 1  \ t r f t s W i d t h B 3  \ t r p a d d l 1 0  \ t r p a d d r 1 0  \ t r p a d d b 1 0  \ t r p a d d t 1 0  \ t r p a d d f l 3  \ t r p a d d f r 3  \ t r p a d d f t 3  \ t r p a d d f b 3  \ c l v m g f  \ c l v m r g  \ c l v e r t a l t  \ c l b r d r t  \ c l b r d r l  \ c l b r d r b  \ c l b r d r r  \ c l c b p a t  \ c l f t s W i d t h 1  O\ l o c h \ h i c h \ d b c h \ p a r d \ p l a i n \ l t r p a r \ i t a p 0  #{ \ * \ s h p p i c t { \ p i c t  \ d n  \ p i c w g o a l  \ p i c h g o a l  \ p n g b l i p  \ j p e g b l i p  	. t i f  	. d i b  U n i f o r m T o F i l l  U p O n l y  D o w n O n l y  MX p s V a l i d a t i n g L o a d e r U r i N o t I n S a m e P a c k a g e  KX p s V a l i d a t i n g L o a d e r D u p l i c a t e R e f e r e n c e  GX p s V a l i d a t i n g L o a d e r U n l i s t e d R e s o u r c e  uh t t p : / / s c h e m a s . m i c r o s o f t . c o m / x p s / 2 0 0 5 / 0 6 / r e q u i r e d - r e s o u r c e GZ o o m P e r c e n t a g e C o n v e r t e r S t r i n g F o r m a t  9S p e l l e r C O M L a t e n c y M e a s u r e m e n t  IS O F T W A R E \ M i c r o s o f t \ W i n F X   S e r i a l i z e r s  )s e r i a l i z e r D e s c r i p t o r  GS e r i a l i z e r P r o v i d e r A l r e a d y R e g i s t e r e d  ?S e r i a l i z e r P r o v i d e r N o t R e g i s t e r e d  =S e r i a l i z e r P r o v i d e r W r o n g V e r s i o n  GS e r i a l i z e r P r o v i d e r U n k n o w n S e r i a l i z e r  9S e r i a l i z e r P r o v i d e r C a n n o t L o a d  f a c t o r y I n s t a n c e  CS e r i a l i z e r P r o v i d e r D i s p l a y N a m e N u l l  MS e r i a l i z e r P r o v i d e r M a n u f a c t u r e r N a m e N u l l  SS e r i a l i z e r P r o v i d e r M a n u f a c t u r e r W e b s i t e N u l l  US e r i a l i z e r P r o v i d e r D e f a u l t F i l e E x t e n s i o n N u l l  u i L a n g u a g e  d i s p l a y N a m e  !m a n u f a c t u r e r N a m e  'm a n u f a c t u r e r W e b s i t e  )d e f a u l t F i l e E x t e n s i o n  )f a c t o r y I n t e r f a c e N a m e  a s s e m b l y V e r s i o n  w i n F X V e r s i o n  SD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 4  SD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 1  t a b l e R o w G r o u p  t a b l e R o w  t a b l e C e l l  s t o r y F r a g m e n t  SD o c u m e n t S t r u c t u r e U n e x p e c t e d P a r a m e t e r T y p e 6  d i c t i o n a r y P a t h  l a n g u a g e T a g  e n u m S t r i n g  s p e l l i n g E r r o r s  e r r o r s  e x c e p t i o n  e x c e p t i o n s  %a t t a c h e d A n n o t a t i o n  9A d d A n n o t a t i o n s N o t I m p l e m e n t e d  +I n v a l i d V a l u e S p e c i f i e d  N o t S u p p o r t e d  +I n v a l i d A n c h o r P o s i t i o n  CP o s i t i o n T r a n s f o r m   c a n n o t   b e   n u l l .  7I n v a l i d S t i c k y N o t e A n n o t a t i o n  M e t a   D a t a  CN o t e ' s   r i g h t   i s   o f f   l e f t   o f   p a g e . CN o t e ' s   l e f t   i s   o f f   r i g h t   o f   p a g e . CN o t e ' s   b o t t o m   i s   o f f   t o p   o f   p a g e . CN o t e ' s   t o p   i s   o f f   b o t t o m   o f   p a g e . T e x t S t i c k y N o t e  {h t t p : / / s c h e m a s . m i c r o s o f t . c o m / w i n d o w s / a n n o t a t i o n s / 2 0 0 3 / 1 1 / b a s e  I n k S t i c k y N o t e  A u t h o r  I s E x p a n d e d  #I s M o u s e O v e r A n c h o r  #C a p t i o n F o n t F a m i l y  C a p t i o n F o n t S i z e  %C a p t i o n F o n t S t r e t c h  !C a p t i o n F o n t S t y l e  #C a p t i o n F o n t W e i g h t  P e n W i d t h  S t i c k y N o t e T y p e  D e l e t e N o t e  I n k  I n k E d i t i n g M o d e  3S t i c k y N o t e C o n t r o l S t y l e K e y  QI n n e r C o n t r o l   i s   n u l l   o r   n o t   a   U I E l e m e n t .  !C o n t e n t   i s   n u l l .  !P A R T _ C l o s e B u t t o n  P A R T _ I c o n B u t t o n  P A R T _ T i t l e T h u m b  'P A R T _ C o n t e n t C o n t r o l  7P A R T _ R e s i z e B o t t o m R i g h t T h u m b  7A t t a c h e d A n n o t a t i o n   i s   n u l l .  GA t t a c h e d A n n o t a t i o n ' s   S t o r e   i s   n u l l . }D r a g g i n g   o c c u r r e d   w h e n   t h e   S t i c k y N o t e C o n t r o l   w a s   n o t   e x p a n d e d .  +I n n e r C o n t r o l   i s   n u l l .  mI n n e r C o n t r o l   i s   n o t   a n   I n k C a n v a s   f o r   n o t e   o f   t y p e   I n k .  qI n n e r C o n t r o l   i s   n o t   a   T e x t B o x B a s e   f o r   n o t e   o f   t y p e   T e x t .  'U n e x p e c t e d   C o m m a n d s  !U n k n o w n   C o m m a n d s  /C a n n o t P r o c e s s I n k C o m m a n d  !U n k n o w n   c o m m a n d .  )I n v a l i d I n k F o r e g r o u n d  !P A R T _ I n k M e n u I t e m  'P A R T _ S e l e c t M e n u I t e m  %P A R T _ E r a s e M e n u I t e m  #P A R T _ C o p y M e n u I t e m  %P A R T _ P a s t e M e n u I t e m  /P A R T _ C l i p b o a r d S e p a r a t o r  5U n s u p p o r t e d   p o s i t i o n   t y p e .  ;T e x t R u n   h a s   n o t   b e e n   c r e a t e d .  IT e x t R u n   h a s   t o   h a v e   p o s i t i v e   l e n g t h .  yE x p e c t i n g   e x a c t l y   o n e   T e x t B o u n d s   f o r   a   s i n g l e   t e x t   p o s i t i o n .  E x p e c t i n g   e x a c t l y   o n e   T e x t R u n B o u n d s   f o r   a   s i n g l e   t e x t   p o s i t i o n .  +C o u l d n ' t   f i n d   o f f s e t ! CL i n e   i s   o u t   o f   s y n c   w i t h   m e t r i c s !  EM u s t N o t T e m p l a t e U n a s s o c i a t e d C o n t r o l  AI n v a l i d C o n t r o l T e m p l a t e T a r g e t T y p e  SA d o r n e d E l e m e n t P l a c e h o l d e r M u s t B e I n T e m p l a t e  EA u d i o V i d e o _ I n v a l i d D e p e n d e n c y O b j e c t  ;A u d i o V i d e o _ C a n n o t C o n t r o l M e d i a  3U n e x p e c t e d   s t a t e   r e q u e s t .  oM e d i a E l e m e n t _ C a n n o t S e t S o u r c e O n M e d i a E l e m e n t D r i v e n B y C l o c k  I s D e f a u l t  I s C a n c e l  I s D e f a u l t e d     )S e l e c t e d D a t e s C h a n g e d  'C a l e n d a r B u t t o n S t y l e  -C a l e n d a r D a y B u t t o n S t y l e  #C a l e n d a r I t e m S t y l e  D i s p l a y D a t e  D i s p l a y D a t e E n d  !D i s p l a y D a t e S t a r t  D i s p l a y M o d e  F i r s t D a y O f W e e k  %I s T o d a y H i g h l i g h t e d  S e l e c t e d D a t e  S e l e c t i o n M o d e  WC a l e n d a r _ O n S e l e c t e d D a t e C h a n g e d _ I n v a l i d V a l u e  _C a l e n d a r _ O n S e l e c t e d D a t e C h a n g e d _ I n v a l i d O p e r a t i o n  #P A R T _ C a l e n d a r I t e m  yC a l e n d a r C o l l e c t i o n _ M u l t i T h r e a d e d C o l l e c t i o n C h a n g e N o t S u p p o r t e d  5C a l e n d a r _ U n S e l e c t a b l e D a t e s  E n d  S t a r t  I s D r o p D o w n O p e n  ?S h o u l d P r e s e r v e U s e r E n t e r e d P r e f i x  I s E d i t a b l e  !S e l e c t i o n B o x I t e m  1S e l e c t i o n B o x I t e m T e m p l a t e  9S e l e c t i o n B o x I t e m S t r i n g F o r m a t  S t a y s O p e n O n E d i t  3I s S e l e c t i o n B o x H i g h l i g h t e d  D i s a b l e d  M o u s e O v e r  N o r m a l  U n f o c u s e d  F o c u s e d D r o p D o w n  F o c u s e d  E d i t a b l e  U n e d i t a b l e  )P A R T _ E d i t a b l e T e x t B o x  P A R T _ P o p u p  I s H i g h l i g h t e d  OC o n t e n t C o n t r o l C a n n o t H a v e M u l t i p l e C o n t e n t  )E l e m e n t M u s t B e I n P o p u p  AC o n t e x t M e n u I n D i f f e r e n t D i s p a t c h e r  H a s D r o p S h a d o w  P l a c e m e n t T a r g e t  %P l a c e m e n t R e c t a n g l e  S h o w O n D i s a b l e d  %C o n t e x t M e n u O p e n i n g  %C o n t e x t M e n u C l o s i n g  /P r e v i e w M o u s e D o u b l e C l i c k  !M o u s e D o u b l e C l i c k  9T o S t r i n g F o r m a t S t r i n g _ C o n t r o l  I n v a l i d F o c u s e d  !I n v a l i d U n f o c u s e d  V a l i d  CC u s t o m D i c t i o n a r y I t e m A l r e a d y E x i s t s  1C u s t o m D i c t i o n a r y N u l l I t e m  KC u s t o m D i c t i o n a r y S o u r c e s U n s u p p o r t e d U R I  =V a l i d a t i o n R u l e _ U n e x p e c t e d V a l u e  )C a n U s e r R e s i z e C o l u m n s  M i n C o l u m n W i d t h  M a x C o l u m n W i d t h  'G r i d L i n e s V i s i b i l i t y  1H o r i z o n t a l G r i d L i n e s B r u s h  -V e r t i c a l G r i d L i n e s B r u s h  R o w S t y l e  5R o w V a l i d a t i o n E r r o r T e m p l a t e  !R o w S t y l e S e l e c t o r  R o