import fs from 'node:fs';
import { pathToFileURL } from 'node:url';
import vm from 'node:vm';
import { processError } from '@vitest/utils/error';
import { normalize as normalize$1 } from 'pathe';
import { ViteNodeRunner, DEFAULT_REQUEST_STUBS } from 'vite-node/client';
import { isInternalRequest, isNodeBuiltin as isNodeBuiltin$1, isPrimitive, toFilePath } from 'vite-node/utils';
import { distDir } from '../path.js';
import { resolve as resolve$1, isAbsolute as isAbsolute$1 } from 'node:path';
import { MockerRegistry, mockObject, RedirectedModule, AutomockedModule } from '@vitest/mocker';
import { builtinModules } from 'node:module';
import { highlight } from '@vitest/utils';

const _DRIVE_LETTER_START_RE = /^[A-Za-z]:\//;
function normalizeWindowsPath(input = "") {
	if (!input) return input;
	return input.replace(/\\/g, "/").replace(_DRIVE_LETTER_START_RE, (r) => r.toUpperCase());
}
const _UNC_REGEX = /^[/\\]{2}/;
const _IS_ABSOLUTE_RE = /^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;
const _DRIVE_LETTER_RE = /^[A-Za-z]:$/;
const _EXTNAME_RE = /.(\.[^./]+|\.)$/;
const normalize = function(path) {
	if (path.length === 0) return ".";
	path = normalizeWindowsPath(path);
	const isUNCPath = path.match(_UNC_REGEX);
	const isPathAbsolute = isAbsolute(path);
	const trailingSeparator = path[path.length - 1] === "/";
	path = normalizeString(path, !isPathAbsolute);
	if (path.length === 0) {
		if (isPathAbsolute) return "/";
		return trailingSeparator ? "./" : ".";
	}
	if (trailingSeparator) path += "/";
	if (_DRIVE_LETTER_RE.test(path)) path += "/";
	if (isUNCPath) {
		if (!isPathAbsolute) return `//./${path}`;
		return `//${path}`;
	}
	return isPathAbsolute && !isAbsolute(path) ? `/${path}` : path;
};
const join = function(...segments) {
	let path = "";
	for (const seg of segments) {
		if (!seg) continue;
		if (path.length > 0) {
			const pathTrailing = path[path.length - 1] === "/";
			const segLeading = seg[0] === "/";
			const both = pathTrailing && segLeading;
			if (both) path += seg.slice(1);
			else path += pathTrailing || segLeading ? seg : `/${seg}`;
		} else path += seg;
	}
	return normalize(path);
};
function cwd() {
	if (typeof process !== "undefined" && typeof process.cwd === "function") return process.cwd().replace(/\\/g, "/");
	return "/";
}
const resolve = function(...arguments_) {
	arguments_ = arguments_.map((argument) => normalizeWindowsPath(argument));
	let resolvedPath = "";
	let resolvedAbsolute = false;
	for (let index = arguments_.length - 1; index >= -1 && !resolvedAbsolute; index--) {
		const path = index >= 0 ? arguments_[index] : cwd();
		if (!path || path.length === 0) continue;
		resolvedPath = `${path}/${resolvedPath}`;
		resolvedAbsolute = isAbsolute(path);
	}
	resolvedPath = normalizeString(resolvedPath, !resolvedAbsolute);
	if (resolvedAbsolute && !isAbsolute(resolvedPath)) return `/${resolvedPath}`;
	return resolvedPath.length > 0 ? resolvedPath : ".";
};
function normalizeString(path, allowAboveRoot) {
	let res = "";
	let lastSegmentLength = 0;
	let lastSlash = -1;
	let dots = 0;
	let char = null;
	for (let index = 0; index <= path.length; ++index) {
		if (index < path.length) char = path[index];
		else if (char === "/") break;
		else char = "/";
		if (char === "/") {
			if (lastSlash === index - 1 || dots === 1);
			else if (dots === 2) {
				if (res.length < 2 || lastSegmentLength !== 2 || res[res.length - 1] !== "." || res[res.length - 2] !== ".") {
					if (res.length > 2) {
						const lastSlashIndex = res.lastIndexOf("/");
						if (lastSlashIndex === -1) {
							res = "";
							lastSegmentLength = 0;
						} else {
							res = res.slice(0, lastSlashIndex);
							lastSegmentLength = res.length - 1 - res.lastIndexOf("/");
						}
						lastSlash = index;
						dots = 0;
						continue;
					} else if (res.length > 0) {
						res = "";
						lastSegmentLength = 0;
						lastSlash = index;
						dots = 0;
						continue;
					}
				}
				if (allowAboveRoot) {
					res += res.length > 0 ? "/.." : "..";
					lastSegmentLength = 2;
				}
			} else {
				if (res.length > 0) res += `/${path.slice(lastSlash + 1, index)}`;
				else res = path.slice(lastSlash + 1, index);
				lastSegmentLength = index - lastSlash - 1;
			}
			lastSlash = index;
			dots = 0;
		} else if (char === "." && dots !== -1) ++dots;
		else dots = -1;
	}
	return res;
}
const isAbsolute = function(p) {
	return _IS_ABSOLUTE_RE.test(p);
};
const extname = function(p) {
	if (p === "..") return "";
	const match = _EXTNAME_RE.exec(normalizeWindowsPath(p));
	return match && match[1] || "";
};
const dirname = function(p) {
	const segments = normalizeWindowsPath(p).replace(/\/$/, "").split("/").slice(0, -1);
	if (segments.length === 1 && _DRIVE_LETTER_RE.test(segments[0])) segments[0] += "/";
	return segments.join("/") || (isAbsolute(p) ? "/" : ".");
};
const basename = function(p, extension) {
	const segments = normalizeWindowsPath(p).split("/");
	let lastSegment = "";
	for (let i = segments.length - 1; i >= 0; i--) {
		const val = segments[i];
		if (val) {
			lastSegment = val;
			break;
		}
	}
	return extension && lastSegment.endsWith(extension) ? lastSegment.slice(0, -extension.length) : lastSegment;
};

const { existsSync, readdirSync, statSync } = fs;
function findMockRedirect(root, mockPath, external) {
	const path = external || mockPath;
	// it's a node_module alias
	// all mocks should be inside <root>/__mocks__
	if (external || isNodeBuiltin(mockPath) || !existsSync(mockPath)) {
		const mockDirname = dirname(path);
		const mockFolder = join(root, "__mocks__", mockDirname);
		if (!existsSync(mockFolder)) return null;
		const baseOriginal = basename(path);
		function findFile(mockFolder, baseOriginal) {
			const files = readdirSync(mockFolder);
			for (const file of files) {
				const baseFile = basename(file, extname(file));
				if (baseFile === baseOriginal) {
					const path = resolve(mockFolder, file);
					// if the same name, return the file
					if (statSync(path).isFile()) return path;
					else {
						// find folder/index.{js,ts}
						const indexFile = findFile(path, "index");
						if (indexFile) return indexFile;
					}
				}
			}
			return null;
		}
		return findFile(mockFolder, baseOriginal);
	}
	const dir = dirname(path);
	const baseId = basename(path);
	const fullPath = resolve(dir, "__mocks__", baseId);
	return existsSync(fullPath) ? fullPath : null;
}
const builtins = new Set([
	...builtinModules,
	"assert/strict",
	"diagnostics_channel",
	"dns/promises",
	"fs/promises",
	"path/posix",
	"path/win32",
	"readline/promises",
	"stream/consumers",
	"stream/promises",
	"stream/web",
	"timers/promises",
	"util/types",
	"wasi"
]);
// https://nodejs.org/api/modules.html#built-in-modules-with-mandatory-node-prefix
const prefixedBuiltins = new Set([
	"node:sea",
	"node:sqlite",
	"node:test",
	"node:test/reporters"
]);
const NODE_BUILTIN_NAMESPACE = "node:";
function isNodeBuiltin(id) {
	if (prefixedBuiltins.has(id)) return true;
	return builtins.has(id.startsWith(NODE_BUILTIN_NAMESPACE) ? id.slice(NODE_BUILTIN_NAMESPACE.length) : id);
}

const spyModulePath = resolve$1(distDir, "spy.js");
class VitestMocker {
	static pendingIds = [];
	spyModule;
	primitives;
	filterPublicKeys;
	registries = /* @__PURE__ */ new Map();
	mockContext = { callstack: null };
	constructor(executor) {
		this.executor = executor;
		const context = this.executor.options.context;
		if (context) this.primitives = vm.runInContext("({ Object, Error, Function, RegExp, Symbol, Array, Map })", context);
		else this.primitives = {
			Object,
			Error,
			Function,
			RegExp,
			Symbol: globalThis.Symbol,
			Array,
			Map
		};
		const Symbol = this.primitives.Symbol;
		this.filterPublicKeys = [
			"__esModule",
			Symbol.asyncIterator,
			Symbol.hasInstance,
			Symbol.isConcatSpreadable,
			Symbol.iterator,
			Symbol.match,
			Symbol.matchAll,
			Symbol.replace,
			Symbol.search,
			Symbol.split,
			Symbol.species,
			Symbol.toPrimitive,
			Symbol.toStringTag,
			Symbol.unscopables
		];
	}
	get root() {
		return this.executor.options.root;
	}
	get moduleCache() {
		return this.executor.moduleCache;
	}
	get moduleDirectories() {
		return this.executor.options.moduleDirectories || [];
	}
	async initializeSpyModule() {
		this.spyModule = await this.executor.executeId(spyModulePath);
	}
	getMockerRegistry() {
		const suite = this.getSuiteFilepath();
		if (!this.registries.has(suite)) this.registries.set(suite, new MockerRegistry());
		return this.registries.get(suite);
	}
	reset() {
		this.registries.clear();
	}
	deleteCachedItem(id) {
		const mockId = this.getMockPath(id);
		if (this.moduleCache.has(mockId)) this.moduleCache.delete(mockId);
	}
	isModuleDirectory(path) {
		return this.moduleDirectories.some((dir) => path.includes(dir));
	}
	getSuiteFilepath() {
		return this.executor.state.filepath || "global";
	}
	createError(message, codeFrame) {
		const Error = this.primitives.Error;
		const error = new Error(message);
		Object.assign(error, { codeFrame });
		return error;
	}
	async resolvePath(rawId, importer) {
		let id;
		let fsPath;
		try {
			[id, fsPath] = await this.executor.originalResolveUrl(rawId, importer);
		} catch (error) {
			// it's allowed to mock unresolved modules
			if (error.code === "ERR_MODULE_NOT_FOUND") {
				const { id: unresolvedId } = error[Symbol.for("vitest.error.not_found.data")];
				id = unresolvedId;
				fsPath = unresolvedId;
			} else throw error;
		}
		// external is node_module or unresolved module
		// for example, some people mock "vscode" and don't have it installed
		const external = !isAbsolute$1(fsPath) || this.isModuleDirectory(fsPath) ? rawId : null;
		return {
			id,
			fsPath,
			external: external ? this.normalizePath(external) : external
		};
	}
	async resolveMocks() {
		if (!VitestMocker.pendingIds.length) return;
		await Promise.all(VitestMocker.pendingIds.map(async (mock) => {
			const { fsPath, external } = await this.resolvePath(mock.id, mock.importer);
			if (mock.action === "unmock") this.unmockPath(fsPath);
			if (mock.action === "mock") this.mockPath(mock.id, fsPath, external, mock.type, mock.factory);
		}));
		VitestMocker.pendingIds = [];
	}
	async callFunctionMock(dep, mock) {
		const cached = this.moduleCache.get(dep)?.exports;
		if (cached) return cached;
		const exports = await mock.resolve();
		const moduleExports = new Proxy(exports, { get: (target, prop) => {
			const val = target[prop];
			// 'then' can exist on non-Promise objects, need nested instanceof check for logic to work
			if (prop === "then") {
				if (target instanceof Promise) return target.then.bind(target);
			} else if (!(prop in target)) {
				if (this.filterPublicKeys.includes(prop)) return void 0;
				throw this.createError(`[vitest] No "${String(prop)}" export is defined on the "${mock.raw}" mock. Did you forget to return it from "vi.mock"?
If you need to partially mock a module, you can use "importOriginal" helper inside:
`, highlight(`vi.mock(import("${mock.raw}"), async (importOriginal) => {
  const actual = await importOriginal()
  return {
    ...actual,
    // your mocked methods
  }
})`));
			}
			return val;
		} });
		this.moduleCache.set(dep, { exports: moduleExports });
		return moduleExports;
	}
	// public method to avoid circular dependency
	getMockContext() {
		return this.mockContext;
	}
	// path used to store mocked dependencies
	getMockPath(dep) {
		return `mock:${dep}`;
	}
	getDependencyMock(id) {
		const registry = this.getMockerRegistry();
		return registry.get(id);
	}
	normalizePath(path) {
		return this.moduleCache.normalizePath(path);
	}
	resolveMockPath(mockPath, external) {
		return findMockRedirect(this.root, mockPath, external);
	}
	mockObject(object, mockExports = {}, behavior = "automock") {
		const spyOn = this.spyModule?.spyOn;
		if (!spyOn) throw this.createError("[vitest] `spyModule` is not defined. This is a Vitest error. Please open a new issue with reproduction.");
		return mockObject({
			globalConstructors: this.primitives,
			spyOn,
			type: behavior
		}, object, mockExports);
	}
	unmockPath(path) {
		const registry = this.getMockerRegistry();
		const id = this.normalizePath(path);
		registry.delete(id);
		this.deleteCachedItem(id);
	}
	mockPath(originalId, path, external, mockType, factory) {
		const registry = this.getMockerRegistry();
		const id = this.normalizePath(path);
		if (mockType === "manual") registry.register("manual", originalId, id, id, factory);
		else if (mockType === "autospy") registry.register("autospy", originalId, id, id);
		else {
			const redirect = this.resolveMockPath(id, external);
			if (redirect) registry.register("redirect", originalId, id, id, redirect);
			else registry.register("automock", originalId, id, id);
		}
		// every time the mock is registered, we remove the previous one from the cache
		this.deleteCachedItem(id);
	}
	async importActual(rawId, importer, callstack) {
		const { id, fsPath } = await this.resolvePath(rawId, importer);
		const result = await this.executor.cachedRequest(id, fsPath, callstack || [importer]);
		return result;
	}
	async importMock(rawId, importee) {
		const { id, fsPath, external } = await this.resolvePath(rawId, importee);
		const normalizedId = this.normalizePath(fsPath);
		let mock = this.getDependencyMock(normalizedId);
		if (!mock) {
			const redirect = this.resolveMockPath(normalizedId, external);
			if (redirect) mock = new RedirectedModule(rawId, normalizedId, normalizedId, redirect);
			else mock = new AutomockedModule(rawId, normalizedId, normalizedId);
		}
		if (mock.type === "automock" || mock.type === "autospy") {
			const mod = await this.executor.cachedRequest(id, fsPath, [importee]);
			return this.mockObject(mod, {}, mock.type);
		}
		if (mock.type === "manual") return this.callFunctionMock(fsPath, mock);
		return this.executor.dependencyRequest(mock.redirect, mock.redirect, [importee]);
	}
	async requestWithMock(url, callstack) {
		const id = this.normalizePath(url);
		const mock = this.getDependencyMock(id);
		if (!mock) return;
		const mockPath = this.getMockPath(id);
		if (mock.type === "automock" || mock.type === "autospy") {
			const cache = this.moduleCache.get(mockPath);
			if (cache.exports) return cache.exports;
			const exports = {};
			// Assign the empty exports object early to allow for cycles to work. The object will be filled by mockObject()
			this.moduleCache.set(mockPath, { exports });
			const mod = await this.executor.directRequest(url, url, callstack);
			this.mockObject(mod, exports, mock.type);
			return exports;
		}
		if (mock.type === "manual" && !callstack.includes(mockPath) && !callstack.includes(url)) try {
			callstack.push(mockPath);
			// this will not work if user does Promise.all(import(), import())
			// we can also use AsyncLocalStorage to store callstack, but this won't work in the browser
			// maybe we should improve mock API in the future?
			this.mockContext.callstack = callstack;
			return await this.callFunctionMock(mockPath, mock);
		} finally {
			this.mockContext.callstack = null;
			const indexMock = callstack.indexOf(mockPath);
			callstack.splice(indexMock, 1);
		}
		else if (mock.type === "redirect" && !callstack.includes(mock.redirect)) return mock.redirect;
	}
	queueMock(id, importer, factoryOrOptions) {
		const mockType = getMockType(factoryOrOptions);
		VitestMocker.pendingIds.push({
			action: "mock",
			id,
			importer,
			factory: typeof factoryOrOptions === "function" ? factoryOrOptions : void 0,
			type: mockType
		});
	}
	queueUnmock(id, importer) {
		VitestMocker.pendingIds.push({
			action: "unmock",
			id,
			importer
		});
	}
}
function getMockType(factoryOrOptions) {
	if (!factoryOrOptions) return "automock";
	if (typeof factoryOrOptions === "function") return "manual";
	return factoryOrOptions.spy ? "autospy" : "automock";
}

const normalizedDistDir = normalize$1(distDir);
const { readFileSync } = fs;
async function createVitestExecutor(options) {
	const runner = new VitestExecutor(options);
	await runner.executeId("/@vite/env");
	await runner.mocker.initializeSpyModule();
	return runner;
}
const externalizeMap = /* @__PURE__ */ new Map();
const bareVitestRegexp = /^@?vitest(?:\/|$)/;
const dispose = [];
function listenForErrors(state) {
	dispose.forEach((fn) => fn());
	dispose.length = 0;
	function catchError(err, type, event) {
		const worker = state();
		const listeners = process.listeners(event);
		// if there is another listener, assume that it's handled by user code
		// one is Vitest's own listener
		if (listeners.length > 1) return;
		const error = processError(err);
		if (!isPrimitive(error)) {
			error.VITEST_TEST_NAME = worker.current?.type === "test" ? worker.current.name : void 0;
			if (worker.filepath) error.VITEST_TEST_PATH = worker.filepath;
			error.VITEST_AFTER_ENV_TEARDOWN = worker.environmentTeardownRun;
		}
		state().rpc.onUnhandledError(error, type);
	}
	const uncaughtException = (e) => catchError(e, "Uncaught Exception", "uncaughtException");
	const unhandledRejection = (e) => catchError(e, "Unhandled Rejection", "unhandledRejection");
	process.on("uncaughtException", uncaughtException);
	process.on("unhandledRejection", unhandledRejection);
	dispose.push(() => {
		process.off("uncaughtException", uncaughtException);
		process.off("unhandledRejection", unhandledRejection);
	});
}
const relativeIds = {};
function getVitestImport(id, state) {
	if (externalizeMap.has(id)) return { externalize: externalizeMap.get(id) };
	// always externalize Vitest because we import from there before running tests
	// so we already have it cached by Node.js
	const root = state().config.root;
	const relativeRoot = relativeIds[root] ?? (relativeIds[root] = normalizedDistDir.slice(root.length));
	if (id.includes(distDir) || id.includes(normalizedDistDir) || relativeRoot && relativeRoot !== "/" && id.startsWith(relativeRoot)) {
		const { path } = toFilePath(id, root);
		const externalize = pathToFileURL(path).toString();
		externalizeMap.set(id, externalize);
		return { externalize };
	}
	if (bareVitestRegexp.test(id)) {
		externalizeMap.set(id, id);
		return { externalize: id };
	}
	return null;
}
async function startVitestExecutor(options) {
	const state = () => globalThis.__vitest_worker__ || options.state;
	const rpc = () => state().rpc;
	process.exit = (code = process.exitCode || 0) => {
		throw new Error(`process.exit unexpectedly called with "${code}"`);
	};
	listenForErrors(state);
	const getTransformMode = () => {
		return state().environment.transformMode ?? "ssr";
	};
	return await createVitestExecutor({
		async fetchModule(id) {
			const vitest = getVitestImport(id, state);
			if (vitest) return vitest;
			const result = await rpc().fetch(id, getTransformMode());
			if (result.id && !result.externalize) {
				const code = readFileSync(result.id, "utf-8");
				return { code };
			}
			return result;
		},
		resolveId(id, importer) {
			return rpc().resolveId(id, importer, getTransformMode());
		},
		get moduleCache() {
			return state().moduleCache;
		},
		get moduleExecutionInfo() {
			return state().moduleExecutionInfo;
		},
		get interopDefault() {
			return state().config.deps.interopDefault;
		},
		get moduleDirectories() {
			return state().config.deps.moduleDirectories;
		},
		get root() {
			return state().config.root;
		},
		get base() {
			return state().config.base;
		},
		...options
	});
}
function updateStyle(id, css) {
	if (typeof document === "undefined") return;
	const element = document.querySelector(`[data-vite-dev-id="${id}"]`);
	if (element) {
		element.textContent = css;
		return;
	}
	const head = document.querySelector("head");
	const style = document.createElement("style");
	style.setAttribute("type", "text/css");
	style.setAttribute("data-vite-dev-id", id);
	style.textContent = css;
	head?.appendChild(style);
}
function removeStyle(id) {
	if (typeof document === "undefined") return;
	const sheet = document.querySelector(`[data-vite-dev-id="${id}"]`);
	if (sheet) document.head.removeChild(sheet);
}
function getDefaultRequestStubs(context) {
	if (!context) {
		const clientStub = {
			...DEFAULT_REQUEST_STUBS["@vite/client"],
			updateStyle,
			removeStyle
		};
		return {
			"/@vite/client": clientStub,
			"@vite/client": clientStub
		};
	}
	const clientStub = vm.runInContext(`(defaultClient) => ({ ...defaultClient, updateStyle: ${updateStyle.toString()}, removeStyle: ${removeStyle.toString()} })`, context)(DEFAULT_REQUEST_STUBS["@vite/client"]);
	return {
		"/@JРуPРуVРу\РуbРуhРуnРуrРуvРуzРу~РуВРуЖРуКРуОРуТРуЦРуЬРувРуиРуоРу▓Ру╢Ру║Ру╛Ру┬Ру╞Ру╩Ру╬Ру╥Ру╓Ру┌Ру▐РутРуцРуъРуюРуЄРуЎРу·Ру■РуСуСу
СуСуСуСуСуСу"Су&Су*Су.Су2Су6Су:Су>СуBСуFСуJСуNСуRСуVСуZСу^СуbСуfСуjСуnСуrСуvСуzСу~СуВСуЖСуКСуОСуТСуЦСуЪСуЮСувСужСукСуоСу▓Су╢Су║Су╛Су┬Су╞Су╩Су╬Су╥Су╓Су┌Су▐СутСуцСуъСуюСуЄСуЎСу·Су■СуТуТу
ТуТуТуТуТуТу"Ту&Ту*Ту.Ту2Ту6Ту:Ту>ТуBТуFТуJТуNТуRТуVТуZТу^ТуbТуfТуjТуnТуrТуvТуzТу~ТуВТуЖТуКТуРТуЦТуЬТувТуиТуоТу┤Ту║Ту└Ту╞Ту╠Ту╥Ту╪Ту▐ТуфТуъТуЁТуЎТу№ТуУуУуУуУуУу Уу&Уу,Уу2Уу8Уу>УуDУуJУуPУуVУу\УуbУуhУуnУуtУуzУуАУуЖУуМУуТУуШУуЮУудУукУу░Уу╢Уу╝Уу┬Уу╚Уу╬Уу╘Уу┌УурУуцУуьУуЄУу°Уу■УуФу
ФуФуФуФу"Фу(Фу.Фу4Фу:Фу@ФуFФуLФуRФуXФу^ФуdФуjФуpФуvФу|ФуВФуИФуОФуФФуЪФуаФужФумФу▓Фу╕Фу╛Фу─Фу╩Фу╨Фу╓Фу▄ФутФушФуюФуЇФу·Фу ХуХуХуХуХуХу$Ху*Ху0Ху6Ху<ХуBХуHХуNХуTХуZХу`ХуfХуlХуrХуxХу~ХуДХуКХуРХуЦХуЬХувХуиХуоХу┤Ху║Ху└Ху╞Ху╠Ху╥Ху╪Ху▐ХуфХуъХуЁХуЎХу№ХуЦуЦуЦуЦуЦу Цу&Цу,Цу2Цу8Цу>ЦуDЦуJЦуPЦуVЦу\ЦуbЦуhЦуnЦуtЦуzЦуАЦуЖЦуМЦуТЦуШЦуЮЦудЦукЦу░Цу╢Цу╝Цу┬Цу╚Цу╬Цу╥Цу╓Цу┌Цу▐ЦутЦуцЦуъЦуюЦуЄЦуЎЦу·Цу■ЦуЧуЧу
ЧуЧуЧуЧуЧуЧу"Чу&Чу*Чу.Чу2Чу6Чу:Чу>ЧуBЧуFЧуJЧуNЧуRЧуVЧуZЧу^ЧуbЧуfЧуjЧуnЧуrЧуvЧуzЧу~ЧуВЧуЖЧуКЧуОЧуТЧуЦЧуЪЧуЮЧувЧужЧукЧуоЧу▓Чу╢Чу║Чу╛Чу┬Чу╞Чу╩Чу╬Чу╥Чу╓Чу┌Чу▐ЧутЧуцЧуъЧуюЧуЄЧуЎЧу·Чу■ЧуШуШу
ШуШуШуШуШуШу"Шу&Шу*Шу.Шу2Шу6Шу:Шу>ШуBШуFШуJШуNШуRШуVШуZШу^ШуbШуfШуjШуnШуrШуvШуzШу~ШуВШуЖШуКШуОШуТШуЦШуЪШуЮШувШужШукШуоШу▓Шу╢Шу║Шу╛Шу┬Шу╞Шу╩Шу╬Шу╥Шу╓Шу┌Шу▐ШутШуцШуъШуюШуЄШуЎШу·Шу■ШуЩуЩу
ЩуЩуЩуЩуЩуЩу$Щу*Щу0Щу6Щу<ЩуBЩуHЩуNЩуTЩуZЩу`ЩуfЩуlЩуrЩуxЩу~ЩуДЩуКЩуРЩуЦЩуЬЩувЩуиЩуоЩу┤Щу║Щу└Щу╞Щу╠Щу╥Щу╪Щу▐ЩуфЩуъЩуЁЩуЎЩу№ЩуЪуЪуЪуЪуЪу Ъу&Ъу,Ъу2Ъу8Ъу>ЪуDЪуJЪуPЪуVЪу\ЪуbЪуhЪуnЪуtЪуzЪуАЪуЖЪуМЪуТЪуШЪуЮЪудЪукЪу░Ъу╢Ъу╝Ъу┬Ъу╚Ъу╬Ъу╘Ъу┌ЪурЪуцЪуьЪуЄЪу°Ъу■ЪуЫу
ЫуЫуЫуЫу"Ыу(Ыу.Ыу4Ыу:Ыу@ЫуFЫуLЫуRЫуXЫу^ЫуdЫуjЫуpЫуvЫу|ЫуВЫуИЫуОЫуФЫуЪЫуаЫужЫумЫу▓Ыу╕Ыу╛Ыу─Ыу╩Ыу╨Ыу╓Ыу▄ЫутЫушЫуюЫуЇЫу·Ыу ЬуЬуЬуЬуЬуЬу$Ьу*Ьу0Ьу6Ьу<ЬуBЬуHЬуNЬуTЬуZЬу`ЬуfЬуlЬуrЬуxЬу~ЬуДЬуКЬуРЬуЦЬуЬЬувЬуиЬуоЬу┤Ьу║Ьу└Ьу╞Ьу╠Ьу╥Ьу╪Ьу▐ЬуфЬуъЬуЁЬуЎЬу№ЬуЭуЭуЭуЭуЭу Эу&Эу,Эу2Эу8Эу>ЭуDЭуJЭуPЭуVЭу\ЭуbЭуhЭуnЭуtЭуzЭуАЭуЖЭуМЭуТЭуШЭуЮЭудЭукЭу░Эу╢Эу╝Эу┬Эу╚Эу╬Эу╘Эу┌ЭурЭуцЭуьЭуЄЭу°Эу■ЭуЮу
ЮуЮуЮуЮу"Юу(Юу.Юу4Юу:Юу@ЮуFЮуLЮуRЮуXЮу^ЮуdЮуjЮуpЮуvЮу|ЮуВЮуИЮуОЮуФЮуЪЮуаЮужЮумЮу▓Юу╕Юу╛Юу─Юу╩Юу╨Юу╓Юу▄ЮутЮушЮуюЮуЇЮу·Юу ЯуЯуЯуЯуЯуЯу$Яу*Яу0Яу6Яу<ЯуBЯуHЯуNЯуTЯуZЯу`ЯуfЯуlЯуrЯуxЯу~ЯуДЯуКЯуРЯуЦЯуЬЯувЯуиЯуоЯу┤Яу╖Яу║Яу╜Яу└Яу├Яу╞Яу╔Яу╠Яу█ЯуъЯуЁЯу·Яуауауау&ау4ауBауPау^ауlауzауКауРауЬауваумау╢ау└ау╩ау╪ауцауЇаубубу!бу0бу?буNбу]буlбу{буКбуРбуФбуШбувбунбу╕бу╝бу╟бу╓бучбуыбуябуєбуўбу√бу бувувувувувувувуву#ву'ву+ву/ву3ву7ву;ву?вуCвуGвуYвуkву}вуПвубву│ву┼ву╫вущву√вугугу1гуCгуUгуgгуyгуЛгуЭгупгу┴гу╙гухгуўгу	дуду-ду?дуQдуcдуuдуЗдуЛдуПдубду│ду┼ду╦ду╤дуфдуўду
еуеу0еуCеуVеу\еу`еуdеуvеуИеуЪеумеу╛еу╨еу╘еу╪еу▐еутеуцеу°еу
жужу.жу@жуRжуdжуvжуИжуМжуРжуЦжуЬжувжуижу║жу╠жу▐жуЁжузузузу зу&зу,зу2зу8зу>зуDзуJзуPзуbзуtзуЖзуМзуТзуШзуЮзудзукзу╝зу╬зурзуцзуьзуЄзу°зу■зуиу
иуиуиуиу"иу(иу:иуLиу^иуpиуВиуФиужиу╕иу╩иу▄иуюиу йуйу$йу6йуHйуZйуlйу~йуРйувйу┤йу╞йу╪йу▐йуфйуЎйукуку,ку>куPкуbкуtкуЖкуШкукку╝ку└ку─ку╚ку╠ку╨ку╘ку┌куркуцкуькуЄку°ку■кулу
лулулулу"лу(лу:луLлу^луbлуfлуjлуnлуrлуvлуzлу~луВлуЖлуКлуОлуТлуЦлуЪлуЮлувлужлуклуолу▓лу╢лу║лу╛лу┬лу╞лу╩лу╬лурл