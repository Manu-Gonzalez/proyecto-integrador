'use strict';

var assert = require('node:assert');
var fs = require('node:fs');
var node_perf_hooks = require('node:perf_hooks');
var node_url = require('node:url');
var createDebug = require('debug');
var pathe = require('pathe');
var vite = require('vite');
var browser = require('./chunk-browser.cjs');
var esModuleLexer = require('es-module-lexer');
var constants = require('./constants.cjs');
var utils = require('./utils.cjs');
var sourceMap = require('./source-map.cjs');
require('node:module');
require('node:path');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var esModuleLexer__namespace = /*#__PURE__*/_interopNamespaceDefault(esModuleLexer);

/* eslint-disable no-console */
function hashCode(s) {
	return s.split("").reduce((a, b) => {
		a = (a << 5) - a + b.charCodeAt(0);
		return a & a;
	}, 0);
}
class Debugger {
	dumpDir;
	initPromise;
	externalizeMap = /* @__PURE__ */ new Map();
	constructor(root, options) {
		this.options = options;
		if (options.dumpModules) this.dumpDir = pathe.resolve(root, options.dumpModules === true ? ".vite-node/dump" : options.dumpModules);
		if (this.dumpDir) if (options.loadDumppedModules) console.info(browser.s.gray(`[vite-node] [debug] load modules from ${this.dumpDir}`));
		else console.info(browser.s.gray(`[vite-node] [debug] dump modules to ${this.dumpDir}`));
		this.initPromise = this.clearDump();
	}
	async clearDump() {
		if (!this.dumpDir) return;
		if (!this.options.loadDumppedModules && fs.existsSync(this.dumpDir)) await fs.promises.rm(this.dumpDir, {
			recursive: true,
			force: true
		});
		await fs.promises.mkdir(this.dumpDir, { recursive: true });
	}
	encodeId(id) {
		return `${id.replace(/[^\w@\-]/g, "_").replace(/_+/g, "_")}-${hashCode(id)}.js`;
	}
	async recordExternalize(id, path) {
		if (!this.dumpDir) return;
		this.externalizeMap.set(id, path);
		await this.writeInfo();
	}
	async dumpFile(id, result) {
		if (!result || !this.dumpDir) return;
		await this.initPromise;
		const name = this.encodeId(id);
		return await fs.promises.writeFile(pathe.join(this.dumpDir, name), `// ${id.replace(/\0/g, "\\0")}\n${result.code}`, "utf-8");
	}
	async loadDump(id) {
		if (!this.dumpDir) return null;
		await this.initPromise;
		const name = this.encodeId(id);
		const path = pathe.join(this.dumpDir, name);
		if (!fs.existsSync(path)) return null;
		const code = await fs.promises.readFile(path, "utf-8");
		return {
			code: code.replace(/^\/\/.*\n/, ""),
			map: void 0
		};
	}
	async writeInfo() {
		if (!this.dumpDir) return;
		const info = JSON.stringify({
			time: (/* @__PURE__ */ new Date()).toLocaleString(),
			externalize: Object.fromEntries(this.externalizeMap.entries())
		}, null, 2);
		return fs.promises.writeFile(pathe.join(this.dumpDir, "info.json"), info, "utf-8");
	}
}

const BUILTIN_EXTENSIONS = new Set([
	".mjs",
	".cjs",
	".node",
	".wasm"
]);
const ESM_EXT_RE = /\.(es|esm|esm-browser|esm-bundler|es6|module)\.js$/;
const ESM_FOLDER_RE = /\/(es|esm)\/(.*\.js)$/;
const defaultInline = [
	/virtual:/,
	/\.[mc]?ts$/,
	/[?&](init|raw|url|inline)\b/,
	constants.KNOWN_ASSET_RE
];
const depsExternal = [/\/node_modules\/.*\.cjs\.js$/, /\/node_modules\/.*\.mjs$/];
function guessCJSversion(id) {
	if (id.match(ESM_EXT_RE)) {
		for (const i of [
			id.replace(ESM_EXT_RE, ".mjs"),
			id.replace(ESM_EXT_RE, ".umd.js"),
			id.replace(ESM_EXT_RE, ".cjs.js"),
			id.replace(ESM_EXT_RE, ".js")
		]) if (fs.existsSync(i)) return i;
	}
	if (id.match(ESM_FOLDER_RE)) {
		for (const i of [
			id.replace(ESM_FOLDER_RE, "/umd/$1"),
			id.replace(ESM_FOLDER_RE, "/cjs/$1"),
			id.replace(ESM_FOLDER_RE, "/lib/$1"),
			id.replace(ESM_FOLDER_RE, "/$1")
		]) if (fs.existsSync(i)) return i;
	}
}
// The code from https://github.com/unjs/mlly/blob/c5bcca0cda175921344fd6de1bc0c499e73e5dac/src/syntax.ts#L51-L98
async function isValidNodeImport(id) {
	const extension = pathe.extname(id);
	if (BUILTIN_EXTENSIONS.has(extension)) return true;
	if (extension !== ".js") return false;
	id = id.replace("file:///", "");
	const package_ = await utils.findNearestPackageData(pathe.dirname(id));
	if (package_.type === "module") return true;
	if (/\.(?:\w+-)?esm?(?:-\w+)?\.js$|\/esm?\//.test(id)) return false;
	try {
		await esModuleLexer__namespace.init;
		const code = await fs.promises.readFile(id, "utf8");
		const [, , , hasModuleSyntax] = esModuleLexer__namespace.parse(code);
		return !hasModuleSyntax;
	} catch {
		return false;
	}
}
const _defaultExternalizeCache = /* @__PURE__ */ new Map();
async function shouldExternalize(id, options, cache = _defaultExternalizeCache) {
	if (!cache.has(id)) cache.set(id, _shouldExternalize(id, options));
	return cache.get(id);
}
async function _shouldExternalize(id, options) {
	if (utils.isNodeBuiltin(id)) return id;
	// data: should be processed by native import,
	// since it is a feature of ESM.
	// also externalize network imports since nodejs allows it when --experimental-network-imports
	if (id.startsWith("data:") || /^(?:https?:)?\/\//.test(id)) return id;
	id = patchWindowsImportPath(id);
	const moduleDirectories = (options === null || options === void 0 ? void 0 : options.moduleDirectories) || ["/node_modules/"];
	if (matchExternalizePattern(id, moduleDirectories, options === null || options === void 0 ? void 0 : options.inline)) return false;
	if ((options === null || options === void 0 ? void 0 : options.inlineFiles) && (options === null || options === void 0 ? void 0 : options.inlineFiles.includes(id))) return false;
	if (matchExternalizePattern(id, moduleDirectories, options === null || options === void 0 ? void 0 : options.external)) return id;
	// Unless the user explicitly opted to inline them, externalize Vite deps.
	// They are too big to inline by default.
	if ((options === null || options === void 0 ? void 0 : options.cacheDir) && id.includes(options.cacheDir)) return id;
	const isLibraryModule = moduleDirectories.some((dir) => id.includes(dir));
	const guessCJS = isLibraryModule && (options === null || options === void 0 ? void 0 : options.fallbackCJS);
	id = guessCJS ? guessCJSversion(id) || id : id;
	if (matchExternalizePattern(id, moduleDirectories, defaultInline)) return false;
	if (matchExternalizePattern(id, moduleDirectories, depsExternal)) return id;
	if (isLibraryModule && await isValidNodeImport(id)) return id;
	return false;
}
function matchExternalizePattern(id, moduleDirectories, patterns) {
	if (patterns == null) return false;
	if (patterns === true) return true;
	for (const ex of patterns) if (typeof ex === "string") {
		if (moduleDirectories.some((dir) => id.includes(pathe.join(dir, ex)))) return true;
	} else if (ex.test(id)) return true;
	return false;
}
function patchWindowsImportPath(path) {
	if (path.match(/^\w:\\/)) return `file:///${utils.slash(path)}`;
	else if (path.match(/^\w:\//)) return `file:///${path}`;
	else return path;
}

const debugRequest = createDebug("vite-node:server:request");
class ViteNodeServer {
	fetchPromiseMap = {
		ssr: /* @__PURE__ */ new Map(),
		web: /* @__PURE__ */ new Map()
	};
	transformPromiseMap = {
		ssr: /* @__PURE__ */ new Map(),
		web: /* @__PURE__ */ new Map()
	};
	durations = {
		ssr: /* @__PURE__ */ new Map(),
		web: /* @__PURE__ */ new Map()
	};
	existingOptimizedDeps = /* @__PURE__ */ new Set();
	fetchCaches = {
		ssr: /* @__PURE__ */ new Map(),
		web: /* @__PURE__ */ new Map()
	};
	fetchCache = /* @__PURE__ */ new Map();
	externalizeCache = /* @__PURE__ */ new Map();
	debugger;
	constructor(server, options = {}) {
		var _options$deps3;
		this.server = server;
		this.options = options;
		const ssrOptions = server.config.ssr;
		options.deps ?? (options.deps = {});
		options.deps.cacheDir = pathe.relative(server.config.root, options.deps.cacheDir || server.config.cacheDir);
		if (ssrOptions) {
			// we don't externalize ssr, because it has different semantics in Vite
			// if (ssrOptions.external) {
			//   options.deps.external ??= []
			//   options.deps.external.push(...ssrOptions.external)
			// }
			if (ssrOptions.noExternal === true) {
				var _options$deps;
				(_options$deps = options.deps).inline ?? (_options$deps.inline = true);
			} else if (options.deps.inline !== true) {
				var _options$deps2;
				(_options$deps2 = options.deps).inline ?? (_options$deps2.inline = []);
				const inline = options.deps.inline;
				options.deps.inline.push(...utils.toArray(ssrOptions.noExternal).filter((dep) => !inline.includes(dep)));
			}
		}
		if (process.env.VITE_NODE_DEBUG_DUMP) options.debug = Object.assign({
			dumpModules: !!process.env.VITE_NODE_DEBUG_DUMP,
			loadDumppedModules: process.env.VITE_NODE_DEBUG_DUMP === "load"
		}, options.debug ?? {});
		if (options.debug) this.debugger = new Debugger(server.config.root, options.debug);
		if (options.deps.inlineFiles) options.deps.inlineFiles = options.deps.inlineFiles.flatMap((file) => {
			if (file.startsWith("file://")) return file;
			const resolvedId = pathe.resolve(file);
			return [resolvedId, node_url.pathToFileURL(resolvedId).href];
		});
		(_options$deps3 = options.deps).moduleDirectories ?? (_options$deps3.moduleDirectories = []);
		const envValue = process.env.VITE_NODE_DEPS_MODULE_DIRECTORIES || process.env.npm_config_VITE_NODE_DEPS_MODULE_DIRECTORIES;
		const customModuleDirectories = envValue === null || envValue === void 0 ? void 0 : envValue.split(",");
		if (customModuleDirectories) options.deps.moduleDirectories.push(...customModuleDirectories);
		options.deps.moduleDirectories = options.deps.moduleDirectories.map((dir) => {
			if (!dir.startsWith("/")) dir = `/${dir}`;
			if (!dir.endsWith("/")) dir += "/";
			return pathe.normalize(dir);
		});
		// always add node_modules as a module directory
		if (!options.deps.moduleDirectories.includes("/node_modules/")) options.deps.moduleDirectories.push("/node_modules/");
	}
	shouldExternalize(id) {
		return shouldExternalize(id, this.options.deps, this.externalizeCache);
	}
	getTotalDuration() {
		const ssrDurations = [...this.durations.ssr.values()].flat();
		const webDurations = [...this.durations.web.values()].flat();
		return [...ssrDurations, ...webDurations].reduce((a, b) => a + b, 0);
	}
	async ensureExists(id) {
		if (this.existingOptimizedDeps.has(id)) return true;
		if (fs.existsSync(id)) {
			this.existingOptimizedDeps.add(id);
			return true;
		}
		return new Promise((resolve) => {
			setTimeout(() => {
				this.ensureExists(id).then(() => {
					resolve(true);
				});
			});
		});
	}
	async resolveId(id, importer, transformMode) {
		if (importer && !importer.startsWith(utils.withTrailingSlash(this.server.config.root))) importer = pathe.resolve(this.server.config.root, importer);
		const mode = transformMode ?? (importer && this.getTransformMode(importer) || "ssr");
		return this.server.pluginContainer.resolveId(id, importer, { ssr: mode === "ssr" });
	}
	getSourceMap(source) {
		var _this$fetchCache$get, _this$server$moduleGr;
		source = utils.normalizeModuleId(source);
		const fetchResult = (_this$fetchCache$get = this.fetchCache.get(source)) === null || _this$fetchCache$get === void 0 ? void 0 : _this$fetchCache$get.result;
		if (fetchResult === null || fetchResult === void 0 ? void 0 : fetchResult.map) return fetchResult.map;
		const ssrTransformResult = (_this$server$moduleGr = this.server.moduleGraph.getModuleById(source)) === null || _this$server$moduleGr === void 0 ? void 0 : _this$server$moduleGr.ssrTransformResult;
		return (ssrTransformResult === null || ssrTransformResult === void 0 ? void 0 : ssrTransformResult.map) || null;
	}
	assertMode(mode) {
		assert(mode === "web" || mode === "ssr", `"transformMode" can only be "web" or "ssr", received "${mode}".`);
	}
	async fetchModule(id, transformMode) {
		const mode = transformMode || this.getTransformMode(id);
		return this.fetchResult(id, mode).then((r) => {
			return this.options.sourcemap !== true ? {
				...r,
				map: void 0
			} : r;
		});
	}
	async fetchResult(id, mode) {
		const modul HHH\$0H _Ð@SH0HHIHt4HE3ɋSE3H    HKHc HtHH@ H0[LI[UVWH033IC A|$`HHEt:MKMC HHD$hHt|$`u16qx  ;uHttH+c  HC{PE33H4  ;v>  H+HS;r~H
ADHH / s HCHHHKsH\$PH0_^]H\$Hl$Ht$ WH IIHH[HtHHH@ HOH_HtHH@ 3HD$0Ht HLD$0H HH  HD$0HOHGHtHH@v HOH6HHtH tHH@N t2G Ho(   8   HD$0HHt+H  H` H`    HKc  HuH!C(C13Hw8H;tHtHH_8HH_HH?H1HtHHH@ HNH^HtHH@ HNHRF0 H\$8Hl$@Ht$HH _ÐH\$WH HHL$8ϴH\$8HtHHHH@05 HLI[IsWH0y  @ISAHt%HIA   LK(HMK|$(H@  HA(HI8HD$ |$(   @tH{(H\$@Ht$HH0_ÐLI[IKVWAVH0LHكz    LqIHHH;HFAFHE@LL;LCL;v.L+AH7H;s%ICU1MK3ҹ  DB 3HI>AvI>ut,HKHE3D8K0ADL$ E3LC(IH@ HK(3C1 H\$`H0A^_^ÐHHXHpHxUAVAWHhH   H?& H3HEHHd$H d$P d$T HL$8HH\$@HHL$Xl0 CHL$H 4 HH  H|$0HtHHAHG HH;HtHH@/ HT$0HL$XduHL$84 D@E2HEHEe e EP   HN& HEHEHEEP   HT$HHL$X/ HT$8HL$X   Ht$8HHH@  uf@2Hd$0 HHL$0H\$0HtHAHH@ ` tAHHUHH@0C HtHHH@- HT$8HL$Xbj@u!Et HEAUHH e HEHMH;t @HL$H@HMH3L$   I[ Is(I{0IA_A^]Ð@SHPHHd$  d$( d$, HHT$ H   j A   Hb   t=HT$ HL$0?. HT$`HL$0|t-HL$`H;tA   %   uHL$ 72HP[HL$ %H\$Ht$UWAVHl$H   ADHٸ   He e e Hu   HMcH H]HKH]HHM- {H}gWA-u@tcH?HEHEHMHEHEHM0 HH  HtHHAH2 HH;HtHH@ HMHUgHM. pHMHMHML$   I[(Is0IA^_]ÐH\$Ht$UWAVHH@ALHHy tnHe  HHM ZHG(HEuH] HD$    E3MHUHH@] Hw(HtHHH@D H\$hHt$pH@A^_]ÅtHG(HEuHOHD$    LM LE8HUH@ HU8Ht<E t5DI HOHA   HUH@  E L+u HG(뇋  ̐H\$Ht$WH`IHHI IH@  DOI;tHD$xbc3mLL$x3ҹ  DB LHHL$ $LHL$ : HL$ L\$`I[Is I_Ð@SH H! 3HHD$0H
HtHLD$0H9 H  HD$0HHHtHH@ HH [ÐH8EtLL$ EL3u  	MtA! H8ÐHL$SH H3HHAHAHA(}  HH [HL$SH H3HHAHAHAHA8ME3+HH [Ð3HHQBHIQHuHQ0HQQ(HQ Q,Q8ÐH(H	Ht   H(Ð@SH HHI(Ht   HKHtHH@ HKHtHH@ HHtHH@ H [Ð@SH HHI0Ht%HKHtHH@S HHtHH@> H [@SH HH޿HH [Ð@SH 3LHD$0HHt HLD$0Hi IH  HD$0HHHtHH@ H [Ðt  A,;CЋH9A BA A(A(ÐLI[WH@y MHA HH|$pICECtHIMCI{HH@Z HI(HT$0LM   HC H\$PH@_ÐH\$Ht$H|$ UATAUAVAWHHpMMLHy8   z uHHH  H
H;O   HWHu
    H;   GHH;   DOMEWI
L;   DG(E;   E+L]DEM+L+LL]AI;ECDEe0 Hw0IHWHM,H]LLEHtHHM0HL$ HUHH@ HOHHU0HT$ 3H@ E0GHtHHH@ AEAOMHEHWHH;HFHDGLL;LCL;v.L+EI6H;s&HE0U1LM03ҹ  DB HE3Et	I;7  Dw(Eƀ, u*HO I+   A9W% DDG(L;vO(DIHUDEAEAOMHEHH;HFHELL;LCL;v9L+AHH;s!HEU1LM3ҹ  DB DG(H]ȉu	HMe Hw0E;uH> uHA\HHe0 HWHM\H]LLEHtHHM0HL$ HUHH@J HOHHU0HT$ 3H@, u0DLuI6I;sHEU1LM3ҹ  DBL LwwHMHL;IGEHK>H;HCH;v.H+DI6H;s&HEU1LM3ҹ  DB HE3DuHuHtHHH@ DuHuEtHG0H+GHIE E4$G8
Ie  A$$ L\$pI[8Is@I{HIA_A^A]A\]ÐH\$Ht$H|$ UATAUAVAWHHPy MDH   HuPHt& EIMM;s}He HE0e0 LMEHD$ D+AEHHMHtJE0A;v$3HE1LM  DB HME0DH" E0HH  I;rHtMA+މFHW LEHIe0 HHUHU0HT$ ADMMH@' HMPE0HtHG L\$PI[8Is@I{HIA_A^A]A\]ÐH\$Ht$WH IHHG3HD$0Ht HLD$0H$ HH  HD$0HKHCHtHH@ HKHmH   HtH{ tHH@d ;t@2@{Hs @uH@   HD$0HtHH3HK(H;tHtH{(HE3H   H\$8Ht$@H _H\$Ht$WH AHHKHNH^HHH@  H\$0   HF H;F, GF(Ht$8H _Ðy tHIHH@ H%| HA(@8 Ð@SH H! 3HD$0LHHt HLD$0H IH 9 HD$0HHHtHH@ HH [Ð3Hn QAHHn HAHKn HAHHQ HQ(ÐH	n HHm HAHm HAN@SH Hon HHHI HtHH@ HKHtHH@u H [Ð@SH Hm HHHm HAHm HAHI(HtHH@) HK HtHH@ H [ÐHHꐐHڐH8HIHE3H    3D$@H8ÐH\$WH HHHtHtHHH@ HHH\$0H _ÐHL$H(0   !HD$03҉P@HP HPPHP(Hk HH(ÐHL$H(0   HHD$0L=l LHk HAHl HAHH(HHXHpL@WH IHH` HHtHHHB HtHHH@ HK Hs HtHH@y HtHHH@d HK(H{(HtHH@J HLD$@H HH / HtHHH@ HT$PHL$@_HL$@HtHH@ H\$0Ht$8H _H\$WH Hu3BHHL$0TH\$0Ht&HHH@H HHAH @ H\$8H _H\$Ht$WH@M$I؋LA EHAAEA0EDك0AIB@HAEӃd$0 Hd$( E3D$  HHH@ HOH_HtHH@ Hg( H\$PwHt$XH@_Ð ÐHI HH@H% H\$WH HIH
H+V uHJH+Q 3HtHHH@U 3*H
H+I uHJH+I 3Huɸ@ 3HH\$0H _Ð  HꐐHڐH\$Ht$H|$ AVH@ILHHH@p = uSHOHH    LL;G(rNHL+G(L;v   )LIHH@pl ؅x   H\$X